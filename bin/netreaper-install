#!/usr/bin/env bash
#═══════════════════════════════════════════════════════════════════════════════
#
#    NETREAPER ARSENAL INSTALLER v6.3.4
#    Premium tool installation experience
#
#    Copyright (c) 2025 Nerds489
#    Licensed under the Apache License, Version 2.0
#
#═══════════════════════════════════════════════════════════════════════════════

set -o pipefail

# --- Version Handling ---------------------------------------------------------
# Read version from VERSION file to prevent drift.
# See lib/version.sh for the shared implementation.
NETREAPER_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
# shellcheck source=../lib/version.sh
source "$NETREAPER_ROOT/lib/version.sh"
readonly SCRIPT_NAME="netreaper-install"
SCRIPT_DIR="$NETREAPER_ROOT"
readonly SCRIPT_DIR

# Colors
readonly C_RESET='\033[0m'
readonly C_RED='\033[38;5;196m'
readonly C_GREEN='\033[38;5;46m'
readonly C_YELLOW='\033[38;5;226m'
readonly C_CYAN='\033[38;5;51m'
readonly C_BLUE='\033[38;5;39m'
readonly C_SHADOW='\033[38;5;244m'

#═══════════════════════════════════════════════════════════════════════════════
# SYSTEM DETECTION - Multi-Distro Support (v5.2.0)
#═══════════════════════════════════════════════════════════════════════════════

# Detected system info (populated by detect_system)
declare -g DISTRO=""
declare -g DISTRO_FAMILY=""
declare -g PKG_MANAGER=""
declare -g PKG_INSTALL=""
declare -g PKG_UPDATE=""
declare -g PKG_SEARCH=""
declare -g PKG_REMOVE=""

# Detect Linux distribution
# NOTE: We parse instead of source to avoid VERSION variable conflicts with /etc/os-release
detect_distro() {
    local distro=""

    if [[ -f /etc/os-release ]]; then
        # Parse instead of source to avoid variable conflicts (VERSION, etc.)
        distro=$(grep -oP '^ID=\K.*' /etc/os-release | tr -d '"')
    elif [[ -f /etc/lsb-release ]]; then
        distro=$(grep -oP '^DISTRIB_ID=\K.*' /etc/lsb-release | tr -d '"' | tr '[:upper:]' '[:lower:]')
    elif [[ -f /etc/debian_version ]]; then
        distro="debian"
    elif [[ -f /etc/fedora-release ]]; then
        distro="fedora"
    elif [[ -f /etc/centos-release ]]; then
        distro="centos"
    elif [[ -f /etc/arch-release ]]; then
        distro="arch"
    elif [[ -f /etc/gentoo-release ]]; then
        distro="gentoo"
    elif [[ -f /etc/alpine-release ]]; then
        distro="alpine"
    fi

    echo "${distro:-unknown}"
}

# Detect distro family
detect_distro_family() {
    local distro="$1"

    case "$distro" in
        debian|ubuntu|kali|parrot|linuxmint|pop|elementary|zorin|mx)
            echo "debian"
            ;;
        fedora|rhel|centos|rocky|alma|oracle|amazon)
            echo "redhat"
            ;;
        arch|manjaro|endeavouros|blackarch|arcolinux|garuda)
            echo "arch"
            ;;
        opensuse*|suse|sles)
            echo "suse"
            ;;
        alpine)
            echo "alpine"
            ;;
        gentoo|funtoo)
            echo "gentoo"
            ;;
        void)
            echo "void"
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

# Detect and set package manager
# shellcheck disable=SC2034  # PKG_* vars available for external use
detect_package_manager() {
    if command -v apt-get &>/dev/null; then
        PKG_MANAGER="apt"
        PKG_INSTALL="apt-get install -y"
        PKG_UPDATE="apt-get update"
        PKG_SEARCH="apt-cache search"
        PKG_REMOVE="apt-get remove -y"
    elif command -v dnf &>/dev/null; then
        PKG_MANAGER="dnf"
        PKG_INSTALL="dnf install -y"
        PKG_UPDATE="dnf check-update"
        PKG_SEARCH="dnf search"
        PKG_REMOVE="dnf remove -y"
    elif command -v yum &>/dev/null; then
        PKG_MANAGER="yum"
        PKG_INSTALL="yum install -y"
        PKG_UPDATE="yum check-update"
        PKG_SEARCH="yum search"
        PKG_REMOVE="yum remove -y"
    elif command -v pacman &>/dev/null; then
        PKG_MANAGER="pacman"
        PKG_INSTALL="pacman -S --noconfirm"
        PKG_UPDATE="pacman -Sy"
        PKG_SEARCH="pacman -Ss"
        PKG_REMOVE="pacman -R --noconfirm"
    elif command -v zypper &>/dev/null; then
        PKG_MANAGER="zypper"
        PKG_INSTALL="zypper install -y"
        PKG_UPDATE="zypper refresh"
        PKG_SEARCH="zypper search"
        PKG_REMOVE="zypper remove -y"
    elif command -v apk &>/dev/null; then
        PKG_MANAGER="apk"
        PKG_INSTALL="apk add"
        PKG_UPDATE="apk update"
        PKG_SEARCH="apk search"
        PKG_REMOVE="apk del"
    elif command -v emerge &>/dev/null; then
        PKG_MANAGER="emerge"
        PKG_INSTALL="emerge"
        PKG_UPDATE="emerge --sync"
        PKG_SEARCH="emerge --search"
        PKG_REMOVE="emerge --unmerge"
    elif command -v xbps-install &>/dev/null; then
        PKG_MANAGER="xbps"
        PKG_INSTALL="xbps-install -y"
        PKG_UPDATE="xbps-install -S"
        PKG_SEARCH="xbps-query -Rs"
        PKG_REMOVE="xbps-remove -y"
    else
        PKG_MANAGER="unknown"
        return 1
    fi

    return 0
}

# Main system detection - call on startup
detect_system() {
    DISTRO=$(detect_distro)
    DISTRO_FAMILY=$(detect_distro_family "$DISTRO")

    if ! detect_package_manager; then
        echo -e "${C_RED}[!] Could not detect package manager${C_RESET}"
        echo -e "${C_SHADOW}    Supported: apt, dnf, yum, pacman, zypper, apk, emerge, xbps${C_RESET}"
        return 1
    fi

    return 0
}

# Show detected system info
show_system_info() {
    echo -e "    ${C_CYAN}System Information:${C_RESET}"
    echo -e "    ${C_SHADOW}├─${C_RESET} Distro: ${C_GREEN}${DISTRO}${C_RESET}"
    echo -e "    ${C_SHADOW}├─${C_RESET} Family: ${C_GREEN}${DISTRO_FAMILY}${C_RESET}"
    echo -e "    ${C_SHADOW}└─${C_RESET} Package Manager: ${C_GREEN}${PKG_MANAGER}${C_RESET}"
}

#═══════════════════════════════════════════════════════════════════════════════
# PACKAGE NAME MAPPING
#═══════════════════════════════════════════════════════════════════════════════

# Get the correct package name for current distro
# Usage: pkg=$(get_package_name "nmap")
get_package_name() {
    local tool="$1"
    local pkg=""

    case "$tool" in
        # SCANNING
        nmap|masscan|netdiscover)
            pkg="$tool"
            ;;

        # WIRELESS
        aircrack-ng|kismet|wifite|reaver|bully|mdk4)
            pkg="$tool"
            ;;
        hcxdumptool)
            case "$DISTRO_FAMILY" in
                debian) pkg="hcxdumptool" ;;
                arch)   pkg="hcxdumptool" ;;
                *)      pkg="" ;;
            esac
            ;;

        # EXPLOITATION
        metasploit-framework|metasploit)
            case "$DISTRO_FAMILY" in
                debian) pkg="metasploit-framework" ;;
                arch)   pkg="metasploit" ;;
                *)      pkg="" ;;
            esac
            ;;
        exploitdb|searchsploit)
            case "$DISTRO_FAMILY" in
                debian) pkg="exploitdb" ;;
                arch)   pkg="exploitdb" ;;
                *)      pkg="" ;;
            esac
            ;;

        # CREDENTIALS
        hashcat|john|hydra|medusa|ncrack)
            pkg="$tool"
            ;;

        # WEB
        nikto|dirb|whatweb)
            pkg="$tool"
            ;;
        sqlmap)
            case "$DISTRO_FAMILY" in
                debian|arch) pkg="sqlmap" ;;
                *)           pkg="" ;;
            esac
            ;;
        gobuster)
            case "$DISTRO_FAMILY" in
                debian) pkg="gobuster" ;;
                arch)   pkg="gobuster" ;;
                *)      pkg="" ;;
            esac
            ;;
        wpscan)
            case "$DISTRO_FAMILY" in
                debian) pkg="wpscan" ;;
                *)      pkg="" ;;
            esac
            ;;

        # TRAFFIC
        wireshark)
            case "$DISTRO_FAMILY" in
                arch) pkg="wireshark-qt" ;;
                *)    pkg="wireshark" ;;
            esac
            ;;
        tcpdump|tshark|ettercap|bettercap)
            pkg="$tool"
            ;;

        # OSINT
        theharvester)
            case "$DISTRO_FAMILY" in
                debian) pkg="theharvester" ;;
                *)      pkg="" ;;
            esac
            ;;
        maltego|recon-ng|spiderfoot)
            case "$DISTRO_FAMILY" in
                debian) pkg="$tool" ;;
                *)      pkg="" ;;
            esac
            ;;

        # STRESS
        hping3)
            pkg="hping3"
            ;;
        slowloris)
            pkg=""  # pip install
            ;;

        # UTILITIES
        netcat)
            case "$DISTRO_FAMILY" in
                debian) pkg="netcat-openbsd" ;;
                redhat) pkg="nmap-ncat" ;;
                arch)   pkg="openbsd-netcat" ;;
                *)      pkg="netcat" ;;
            esac
            ;;
        curl|wget|git|unzip|jq|socat|proxychains|tor)
            pkg="$tool"
            ;;
        python3-pip|pip)
            case "$DISTRO_FAMILY" in
                debian) pkg="python3-pip" ;;
                redhat) pkg="python3-pip" ;;
                arch)   pkg="python-pip" ;;
                suse)   pkg="python3-pip" ;;
                alpine) pkg="py3-pip" ;;
                *)      pkg="python3-pip" ;;
            esac
            ;;
        build-essential)
            case "$DISTRO_FAMILY" in
                debian) pkg="build-essential" ;;
                redhat) pkg="gcc make" ;;
                arch)   pkg="base-devel" ;;
                suse)   pkg="gcc make" ;;
                alpine) pkg="build-base" ;;
                *)      pkg="" ;;
            esac
            ;;
        golang|go)
            case "$DISTRO_FAMILY" in
                debian) pkg="golang-go" ;;
                redhat) pkg="golang" ;;
                arch)   pkg="go" ;;
                suse)   pkg="go" ;;
                *)      pkg="" ;;
            esac
            ;;

        # Default - try same name
        *)
            pkg="$tool"
            ;;
    esac

    echo "$pkg"
}

#═══════════════════════════════════════════════════════════════════════════════
# UNIVERSAL PACKAGE INSTALLATION
#═══════════════════════════════════════════════════════════════════════════════

# Check if a tool is installed
check_tool_installed() {
    local tool="$1"
    local binary="${2:-$tool}"
    verify_tool_installed "$tool" "$binary"
}

# Enhanced tool verification - checks binary exists, not just exit code
verify_tool_installed() {
    local tool="$1"
    local binary="${2:-$tool}"

    # Check if command exists
    if command -v "$binary" &>/dev/null; then
        return 0
    fi

    # Check common binary locations
    for path in /usr/bin /usr/local/bin /usr/sbin /sbin ~/.local/bin ~/go/bin /opt; do
        if [[ -x "$path/$binary" ]]; then
            return 0
        fi
    done

    # Check for alternative binary names
    case "$tool" in
        hcxtools)
            command -v hcxpcapngtool &>/dev/null && return 0
            ;;
        metasploit-framework)
            command -v msfconsole &>/dev/null && return 0
            ;;
        exploitdb)
            command -v searchsploit &>/dev/null && return 0
            ;;
        theharvester)
            command -v theHarvester &>/dev/null && return 0
            ;;
    esac

    return 1
}

# Install a package using detected package manager
pkg_install() {
    local package="$1"
    [[ -z "$package" ]] && return 1

    case "$PKG_MANAGER" in
        apt)
            DEBIAN_FRONTEND=noninteractive apt-get install -y "$package" &>/dev/null
            ;;
        dnf)
            dnf install -y "$package" &>/dev/null
            ;;
        yum)
            yum install -y "$package" &>/dev/null
            ;;
        pacman)
            pacman -S --noconfirm --needed "$package" &>/dev/null
            ;;
        zypper)
            zypper install -y "$package" &>/dev/null
            ;;
        apk)
            apk add "$package" &>/dev/null
            ;;
        emerge)
            emerge "$package" &>/dev/null
            ;;
        xbps)
            xbps-install -y "$package" &>/dev/null
            ;;
        *)
            return 1
            ;;
    esac
}

# Update package lists
pkg_update() {
    echo -e "    ${C_CYAN}○${C_RESET} Updating package lists..."

    case "$PKG_MANAGER" in
        apt)
            apt-get update &>/dev/null
            ;;
        dnf)
            dnf check-update &>/dev/null || true
            ;;
        yum)
            yum check-update &>/dev/null || true
            ;;
        pacman)
            pacman -Sy &>/dev/null
            ;;
        zypper)
            zypper refresh &>/dev/null
            ;;
        apk)
            apk update &>/dev/null
            ;;
        emerge)
            emerge --sync &>/dev/null
            ;;
        xbps)
            xbps-install -S &>/dev/null
            ;;
    esac

    echo -e "\r    ${C_GREEN}✓${C_RESET} Package lists updated    "
}

# Install a tool with fallback methods
install_tool() {
    local tool="$1"
    local binary="${2:-$tool}"

    # Already installed?
    if check_tool_installed "$tool" "$binary"; then
        echo -e "    ${C_GREEN}✓${C_RESET} $tool ${C_SHADOW}(installed)${C_RESET}"
        return 0
    fi

    echo -ne "    ${C_CYAN}○${C_RESET} Installing $tool..."

    # Get distro-specific package name
    local package
    package=$(get_package_name "$tool")

    # Method 1: Package manager
    if [[ -n "$package" ]]; then
        if pkg_install "$package"; then
            if check_tool_installed "$tool" "$binary"; then
                echo -e "\r    ${C_GREEN}✓${C_RESET} $tool                    "
                return 0
            fi
        fi
    fi

    # Method 2: pip
    if command -v pip3 &>/dev/null; then
        if pip3 install "$tool" --user --break-system-packages &>/dev/null 2>&1 || \
           pip3 install "$tool" --user &>/dev/null 2>&1; then
            if check_tool_installed "$tool" "$binary"; then
                echo -e "\r    ${C_GREEN}✓${C_RESET} $tool ${C_SHADOW}(pip)${C_RESET}          "
                return 0
            fi
        fi
    fi

    # Method 3: Go install
    if command -v go &>/dev/null; then
        case "$tool" in
            gobuster)
                go install github.com/OJ/gobuster/v3@latest &>/dev/null
                ;;
            ffuf)
                go install github.com/ffuf/ffuf@latest &>/dev/null
                ;;
            nuclei)
                go install github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest &>/dev/null
                ;;
            httpx)
                go install github.com/projectdiscovery/httpx/cmd/httpx@latest &>/dev/null
                ;;
            subfinder)
                go install github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest &>/dev/null
                ;;
        esac

        if check_tool_installed "$tool" "$binary"; then
            echo -e "\r    ${C_GREEN}✓${C_RESET} $tool ${C_SHADOW}(go)${C_RESET}           "
            return 0
        fi
    fi

    # Method 4: GitHub release
    if install_from_github "$tool"; then
        echo -e "\r    ${C_GREEN}✓${C_RESET} $tool ${C_SHADOW}(github)${C_RESET}       "
        return 0
    fi

    # All methods failed - add to FAILED_TOOLS array
    echo -e "\r    ${C_RED}✗${C_RESET} $tool ${C_SHADOW}(unavailable for $DISTRO)${C_RESET}"
    FAILED_TOOLS+=("$tool")
    return 1
}

# Install from GitHub releases
install_from_github() {
    local tool="$1"
    local repo=""

    # Map tools to GitHub repos
    case "$tool" in
        rustscan)     repo="RustScan/RustScan" ;;
        nuclei)       repo="projectdiscovery/nuclei" ;;
        httpx)        repo="projectdiscovery/httpx" ;;
        subfinder)    repo="projectdiscovery/subfinder" ;;
        amass)        repo="owasp-amass/amass" ;;
        *)            return 1 ;;
    esac

    local api_url="https://api.github.com/repos/$repo/releases/latest"
    local release_json

    release_json=$(curl -sL --connect-timeout 10 "$api_url") || return 1

    # Find binary for architecture
    local arch
    arch=$(uname -m)
    case "$arch" in
        x86_64)  arch="amd64\|x86_64\|linux64" ;;
        aarch64) arch="arm64\|aarch64" ;;
        armv7l)  arch="armv7\|arm\|armhf" ;;
        *)       arch="$arch" ;;
    esac

    local download_url
    download_url=$(echo "$release_json" | grep -oP '"browser_download_url":\s*"\K[^"]+' | \
        grep -iE "linux.*($arch)" | grep -vE '\.sha256|\.sig|\.asc|\.txt' | head -1)

    [[ -z "$download_url" ]] && return 1

    local tmp_file="/tmp/${tool}_download_$$"
    curl -sL --connect-timeout 10 --max-time 120 "$download_url" -o "$tmp_file" || return 1

    # Handle different archive types
    case "$download_url" in
        *.deb)
            dpkg -i "$tmp_file" &>/dev/null
            apt-get install -f -y &>/dev/null
            ;;
        *.rpm)
            rpm -i "$tmp_file" &>/dev/null || dnf install -y "$tmp_file" &>/dev/null
            ;;
        *.tar.gz|*.tgz)
            local extract_dir="/tmp/${tool}_extract_$$"
            mkdir -p "$extract_dir"
            tar -xzf "$tmp_file" -C "$extract_dir" &>/dev/null
            local binary
            binary=$(find "$extract_dir" -type f -executable -name "*$tool*" 2>/dev/null | head -1)
            [[ -z "$binary" ]] && binary=$(find "$extract_dir" -type f -executable 2>/dev/null | head -1)
            [[ -n "$binary" ]] && install -m 755 "$binary" /usr/local/bin/"$tool"
            rm -rf "$extract_dir"
            ;;
        *.zip)
            local extract_dir="/tmp/${tool}_extract_$$"
            mkdir -p "$extract_dir"
            unzip -q "$tmp_file" -d "$extract_dir" &>/dev/null
            local binary
            binary=$(find "$extract_dir" -type f -executable 2>/dev/null | head -1)
            [[ -n "$binary" ]] && install -m 755 "$binary" /usr/local/bin/"$tool"
            rm -rf "$extract_dir"
            ;;
        *)
            install -m 755 "$tmp_file" /usr/local/bin/"$tool"
            ;;
    esac

    rm -f "$tmp_file"
    command -v "$tool" &>/dev/null
}

#═══════════════════════════════════════════════════════════════════════════════
# DISTRO-SPECIFIC SETUP
#═══════════════════════════════════════════════════════════════════════════════

# Setup additional repos for security tools
setup_repos() {
    case "$DISTRO_FAMILY" in
        redhat)
            # RHEL/CentOS/Rocky/Alma need EPEL
            if [[ "$DISTRO" != "fedora" ]]; then
                if ! rpm -q epel-release &>/dev/null; then
                    echo -e "    ${C_CYAN}○${C_RESET} Installing EPEL repository..."
                    dnf install -y epel-release &>/dev/null || \
                    yum install -y epel-release &>/dev/null
                    echo -e "\r    ${C_GREEN}✓${C_RESET} EPEL repository installed    "
                fi
            fi
            ;;

        arch)
            if [[ "$DISTRO" != "blackarch" ]]; then
                echo -e "    ${C_YELLOW}!${C_RESET} For more tools, consider BlackArch repo:"
                echo -e "      ${C_SHADOW}curl -O https://blackarch.org/strap.sh && sudo ./strap.sh${C_RESET}"
            fi
            ;;

        suse)
            echo -e "    ${C_YELLOW}!${C_RESET} Some tools may need security repos on openSUSE"
            ;;
    esac
}

# Install base dependencies
install_base_deps() {
    echo -e "\n${C_CYAN}[*] Installing base dependencies...${C_RESET}"

    local deps=(curl wget git unzip jq)

    # Add distro-specific build tools
    case "$DISTRO_FAMILY" in
        debian)  deps+=(python3-pip build-essential) ;;
        redhat)  deps+=(python3-pip gcc make) ;;
        arch)    deps+=(python-pip base-devel) ;;
        suse)    deps+=(python3-pip gcc make) ;;
        alpine)  deps+=(py3-pip build-base) ;;
    esac

    for dep in "${deps[@]}"; do
        install_tool "$dep" || true
    done

    # Install Go if not present
    if ! command -v go &>/dev/null; then
        install_tool "golang" "go"
    fi
}

#═══════════════════════════════════════════════════════════════════════════════
# STARTUP INITIALIZATION
#═══════════════════════════════════════════════════════════════════════════════

# Initialize system - call this early in script
init_system() {
    # Detect system
    if ! detect_system; then
        echo -e "${C_RED}╔═══════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "${C_RED}║  UNSUPPORTED SYSTEM                                       ║${C_RESET}"
        echo -e "${C_RED}╠═══════════════════════════════════════════════════════════╣${C_RESET}"
        echo -e "${C_RED}║  Could not detect a supported package manager.            ║${C_RESET}"
        echo -e "${C_RED}║                                                           ║${C_RESET}"
        echo -e "${C_RED}║  Supported:                                               ║${C_RESET}"
        echo -e "${C_RED}║    • apt    (Debian, Ubuntu, Kali, Parrot)                ║${C_RESET}"
        echo -e "${C_RED}║    • dnf    (Fedora, RHEL 8+, Rocky, Alma)                ║${C_RESET}"
        echo -e "${C_RED}║    • yum    (RHEL 7, CentOS 7)                            ║${C_RESET}"
        echo -e "${C_RED}║    • pacman (Arch, Manjaro, BlackArch)                    ║${C_RESET}"
        echo -e "${C_RED}║    • zypper (openSUSE, SUSE)                              ║${C_RESET}"
        echo -e "${C_RED}║    • apk    (Alpine)                                      ║${C_RESET}"
        echo -e "${C_RED}╚═══════════════════════════════════════════════════════════╝${C_RESET}"
        exit 1
    fi
}

# Show system banner (optional - for verbose mode)
show_system_banner() {
    echo -e "${C_SHADOW}┌─────────────────────────────────────┐${C_RESET}"
    echo -e "${C_SHADOW}│${C_RESET} System: ${C_GREEN}${DISTRO}${C_RESET} (${DISTRO_FAMILY})"
    echo -e "${C_SHADOW}│${C_RESET} Package Manager: ${C_GREEN}${PKG_MANAGER}${C_RESET}"
    echo -e "${C_SHADOW}└─────────────────────────────────────┘${C_RESET}"
}

# Dry-run mode
NR_DRY_RUN=0
export NR_DRY_RUN

# Logging
log_info()    { echo -e "    ${C_CYAN}[*]${C_RESET} $*"; }
log_success() { echo -e "    ${C_GREEN}[✓]${C_RESET} $*"; }
log_warning() { echo -e "    ${C_YELLOW}[!]${C_RESET} $*"; }
log_error()   { echo -e "    ${C_RED}[✗]${C_RESET} $*"; }
log_verbose() { [[ -n "${VERBOSE:-}" ]] && echo -e "    ${C_SHADOW}[-]${C_RESET} $*"; }

# Global tracking
declare -a FAILED_TOOLS=()
declare -a SKIPPED_TOOLS=()
declare -a INSTALL_ATTEMPTED=()
declare -a ALL_FAILED_TOOLS=()
declare -a ALL_SKIPPED_TOOLS=()
declare -a ALL_INSTALL_ATTEMPTED=()
INSTALL_ERRORS=0

# Tool installation hints for failed tools (shown in summary)
declare -A TOOL_INSTALL_HINTS=(
    [rustscan]="GitHub release available"
    [theharvester]="pip install"
    [maltego]="Manual download required"
    [empire]="pip install"
    [iperf3]="Check EPEL repo"
    [metasploit-framework]="Manual install script"
    [bettercap]="go install"
    [nuclei]="go install"
    [httpx]="go install"
    [subfinder]="go install"
    [amass]="GitHub release"
    [gobuster]="go install"
    [ffuf]="go install"
    [wpscan]="gem install"
    [recon-ng]="pip install"
    [shodan]="pip install"
    [crackmapexec]="pipx install"
    [hcxdumptool]="Build from source"
    [hcxtools]="Build from source"
    [exploitdb]="Kali/Parrot only"
    [sqlmap]="pip install"
    [wifite]="pip install"
)

# Error handler (non-fatal)
handle_error() {
    local tool="$1"
    local method="$2"
    local exit_code="$3"

    FAILED_TOOLS+=("$tool:$method:$exit_code")
    ((INSTALL_ERRORS++))

    log_warning "$tool installation failed ($method, exit code: $exit_code)"
    return 0
}

# Tool definitions
# Format: [tool]="binary:package:primary_method:fallback_method"
# shellcheck disable=SC2034  # Used by install functions
declare -A TOOLS=(
    # SCANNING
    [nmap]="nmap:nmap:apt:-"
    [masscan]="masscan:masscan:apt:-"
    [rustscan]="rustscan:RustScan/RustScan:github:-"
    [zmap]="zmap:zmap:apt:-"
    [arp-scan]="arp-scan:arp-scan:apt:-"
    [netdiscover]="netdiscover:netdiscover:apt:-"
    [hping3]="hping3:hping3:apt:-"
    [fping]="fping:fping:apt:-"

    # WIRELESS
    [aircrack-ng]="aircrack-ng:aircrack-ng:apt:-"
    [reaver]="reaver:reaver:apt:-"
    [bully]="bully:bully:apt:-"
    [pixiewps]="pixiewps:pixiewps:apt:-"
    [wifite]="wifite:wifite:apt:pip"
    [bettercap]="bettercap:bettercap:apt:github"
    [mdk3]="mdk3:mdk3:apt:-"
    [mdk4]="mdk4:mdk4:apt:-"
    [hostapd]="hostapd:hostapd:apt:-"
    [cowpatty]="cowpatty:cowpatty:apt:-"

    # WEB
    [nikto]="nikto:nikto:apt:-"
    [sqlmap]="sqlmap:sqlmap:apt:pip"
    [dirb]="dirb:dirb:apt:-"
    [gobuster]="gobuster:gobuster:apt:go"
    [ffuf]="ffuf:ffuf:apt:go"
    [wpscan]="wpscan:wpscan:gem:apt"
    [nuclei]="nuclei:projectdiscovery/nuclei:github:go"
    [httpx]="httpx:projectdiscovery/httpx:github:go"
    [subfinder]="subfinder:projectdiscovery/subfinder:github:go"
    [amass]="amass:owasp-amass/amass:github:snap"

    # EXPLOIT
    [metasploit-framework]="msfconsole:metasploit-framework:apt:-"
    [exploitdb]="searchsploit:exploitdb:apt:-"
    [crackmapexec]="crackmapexec:crackmapexec:pipx:pip"

    # OSINT
    [theharvester]="theHarvester:theHarvester:apt:pip"
    [recon-ng]="recon-ng:recon-ng:apt:pip"
    [maltego]="maltego:maltego:apt:-"
    [shodan]="shodan:shodan:pip:-"

    # CREDENTIALS
    [hashcat]="hashcat:hashcat:apt:-"
    [john]="john:john:apt:-"
    [hydra]="hydra:hydra:apt:-"
    [medusa]="medusa:medusa:apt:-"

    # TRAFFIC
    [tcpdump]="tcpdump:tcpdump:apt:-"
    [wireshark]="wireshark:wireshark:apt:-"
    [tshark]="tshark:tshark:apt:-"
    [ettercap]="ettercap:ettercap-common:apt:-"

    # WIRELESS (additional)
    [hcxdumptool]="hcxdumptool:hcxdumptool:apt:-"
    [hcxtools]="hcxpcapngtool:hcxtools:apt:-"

    # STRESS
    [iperf3]="iperf3:iperf3:apt:-"

    # POST-EXPLOITATION
    [empire]="empire:empire:pip:github"
)

# Categories
declare -A CATEGORIES=(
    [scanning]="nmap masscan rustscan zmap arp-scan netdiscover hping3 fping"
    [wireless]="aircrack-ng reaver bully pixiewps wifite bettercap mdk3 mdk4 hostapd cowpatty hcxdumptool hcxtools"
    [web]="nikto sqlmap dirb gobuster wpscan ffuf nuclei httpx subfinder amass"
    [exploit]="metasploit-framework exploitdb crackmapexec"
    [osint]="theharvester recon-ng maltego shodan"
    [creds]="hashcat john hydra medusa"
    [traffic]="tcpdump wireshark tshark ettercap"
    [stress]="hping3 iperf3"
    [post]="empire"
)

preflight_checks() {
    echo -e "    ${C_CYAN}[*]${C_RESET} Running pre-flight checks..."

    if [[ $EUID -ne 0 ]]; then
        echo -e "    ${C_RED}[!]${C_RESET} This installer requires root privileges"
        echo -e "    ${C_SHADOW}    Run: sudo $SCRIPT_NAME${C_RESET}"
        exit 1
    fi

    # Initialize system detection
    init_system

    # Show detected system
    echo ""
    show_system_info
    echo ""

    # Setup additional repos
    setup_repos

    if ! ping -c 1 -W 3 8.8.8.8 &>/dev/null; then
        echo -e "    ${C_YELLOW}[!]${C_RESET} No internet connection detected"
        echo -e "    ${C_SHADOW}    Some installations may fail${C_RESET}"
    fi

    # Update package lists
    pkg_update

    # Install base dependencies using the new function
    install_base_deps

    echo -e "    ${C_GREEN}[✓]${C_RESET} Pre-flight checks complete"
    echo
}

# Create manual installation guide for failed tools
create_manual_fix_guide() {
    local guide_dir="$HOME/.netreaper"
    local guide_file="${guide_dir}/MANUAL_INSTALL.md"
    local current_date
    current_date=$(date '+%Y-%m-%d %H:%M:%S')

    # Ensure directory exists
    mkdir -p "$guide_dir" 2>/dev/null

    # Format distro name nicely
    local distro_display="${DISTRO^}"
    [[ "$DISTRO" == "kali" ]] && distro_display="Kali Linux"
    [[ "$DISTRO" == "ubuntu" ]] && distro_display="Ubuntu"
    [[ "$DISTRO" == "debian" ]] && distro_display="Debian"
    [[ "$DISTRO" == "parrot" ]] && distro_display="Parrot OS"
    [[ "$DISTRO" == "fedora" ]] && distro_display="Fedora"
    [[ "$DISTRO" == "arch" ]] && distro_display="Arch Linux"
    [[ "$DISTRO" == "manjaro" ]] && distro_display="Manjaro"
    [[ "$DISTRO" == "blackarch" ]] && distro_display="BlackArch"

    # Write header
    cat > "$guide_file" << EOF
# NETREAPER - Manual Installation Guide
Generated: ${current_date}
System: ${distro_display} (${PKG_MANAGER})

## Failed Tools

EOF

    # Track which tools we've added (to avoid duplicates)
    local -A added_tools=()

    # Add each failed tool with distro-specific instructions
    for tool in "${FAILED_TOOLS[@]}"; do
        # Extract just the tool name (remove any :method:exitcode suffix)
        local tool_name="${tool%%:*}"

        # Skip if already added
        [[ -n "${added_tools[$tool_name]:-}" ]] && continue
        added_tools[$tool_name]=1

        case "$tool_name" in
            rustscan)
                cat >> "$guide_file" << 'EOF'
### rustscan
```bash
# Option 1: Cargo (requires Rust)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.cargo/env
cargo install rustscan

# Option 2: Download binary
EOF
                case "$DISTRO_FAMILY" in
                    debian)
                        cat >> "$guide_file" << 'EOF'
wget https://github.com/RustScan/RustScan/releases/latest/download/rustscan_2.1.1_amd64.deb
sudo dpkg -i rustscan_*.deb
EOF
                        ;;
                    redhat)
                        cat >> "$guide_file" << 'EOF'
# Download from: https://github.com/RustScan/RustScan/releases
# Use cargo install or download the binary manually
EOF
                        ;;
                    arch)
                        cat >> "$guide_file" << 'EOF'
# Available in AUR
yay -S rustscan
# Or: paru -S rustscan
EOF
                        ;;
                esac
                echo -e '```\n' >> "$guide_file"
                ;;

            theharvester)
                echo "### theharvester" >> "$guide_file"
                echo '```bash' >> "$guide_file"
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "# Option 1: Package manager (Kali/Parrot)" >> "$guide_file"
                        echo "sudo apt install theharvester" >> "$guide_file"
                        echo "" >> "$guide_file"
                        echo "# Option 2: pip" >> "$guide_file"
                        ;;
                    *)
                        echo "# Install via pip" >> "$guide_file"
                        ;;
                esac
                cat >> "$guide_file" << 'EOF'
pip3 install theHarvester --break-system-packages
# Or without --break-system-packages on older systems:
pip3 install theHarvester --user
```

EOF
                ;;

            maltego)
                cat >> "$guide_file" << 'EOF'
### maltego
```bash
# Maltego requires manual download:
# https://www.maltego.com/downloads/
# Choose Community Edition (free) or Commercial

# After downloading:
EOF
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "sudo dpkg -i Maltego*.deb" >> "$guide_file"
                        echo "sudo apt install -f  # Fix dependencies" >> "$guide_file"
                        ;;
                    redhat)
                        echo "sudo rpm -i Maltego*.rpm" >> "$guide_file"
                        ;;
                    arch)
                        echo "# Extract and run manually, or check AUR for maltego" >> "$guide_file"
                        ;;
                esac
                echo -e '```\n' >> "$guide_file"
                ;;

            empire)
                cat >> "$guide_file" << 'EOF'
### empire
```bash
# Option 1: pip
pip3 install empire-powershell --break-system-packages

# Option 2: From source
git clone https://github.com/BC-SECURITY/Empire.git
cd Empire && ./setup/install.sh
```

EOF
                ;;

            iperf3)
                echo "### iperf3" >> "$guide_file"
                echo '```bash' >> "$guide_file"
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "sudo apt install iperf3" >> "$guide_file"
                        ;;
                    redhat)
                        echo "# Enable EPEL repository first:" >> "$guide_file"
                        echo "sudo dnf install epel-release  # RHEL/Rocky/Alma" >> "$guide_file"
                        echo "sudo dnf install iperf3" >> "$guide_file"
                        ;;
                    arch)
                        echo "sudo pacman -S iperf3" >> "$guide_file"
                        ;;
                    suse)
                        echo "sudo zypper install iperf" >> "$guide_file"
                        ;;
                    alpine)
                        echo "sudo apk add iperf3" >> "$guide_file"
                        ;;
                esac
                echo -e '```\n' >> "$guide_file"
                ;;

            hcxdumptool)
                echo "### hcxdumptool" >> "$guide_file"
                echo '```bash' >> "$guide_file"
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "sudo apt install hcxdumptool" >> "$guide_file"
                        ;;
                    arch)
                        echo "sudo pacman -S hcxdumptool" >> "$guide_file"
                        ;;
                    *)
                        echo "# Build from source:" >> "$guide_file"
                        ;;
                esac
                cat >> "$guide_file" << 'EOF'

# Or build from source:
git clone https://github.com/ZerBea/hcxdumptool.git
cd hcxdumptool
make
sudo make install
```

EOF
                ;;

            hcxtools)
                echo "### hcxtools" >> "$guide_file"
                echo '```bash' >> "$guide_file"
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "sudo apt install hcxtools" >> "$guide_file"
                        ;;
                    arch)
                        echo "sudo pacman -S hcxtools" >> "$guide_file"
                        ;;
                    *)
                        echo "# Build from source:" >> "$guide_file"
                        ;;
                esac
                cat >> "$guide_file" << 'EOF'

# Or build from source:
git clone https://github.com/ZerBea/hcxtools.git
cd hcxtools
make
sudo make install
```

EOF
                ;;

            metasploit-framework)
                echo "### metasploit-framework" >> "$guide_file"
                echo '```bash' >> "$guide_file"
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "# Kali/Parrot:" >> "$guide_file"
                        echo "sudo apt install metasploit-framework" >> "$guide_file"
                        echo "" >> "$guide_file"
                        echo "# Other Debian-based:" >> "$guide_file"
                        ;;
                    *)
                        echo "# Universal install script:" >> "$guide_file"
                        ;;
                esac
                cat >> "$guide_file" << 'EOF'
curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb > msfinstall
chmod +x msfinstall && ./msfinstall
```

EOF
                ;;

            bettercap)
                echo "### bettercap" >> "$guide_file"
                echo '```bash' >> "$guide_file"
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "sudo apt install bettercap" >> "$guide_file"
                        ;;
                    arch)
                        echo "sudo pacman -S bettercap" >> "$guide_file"
                        ;;
                    *)
                        echo "# Package not available, use go install:" >> "$guide_file"
                        ;;
                esac
                cat >> "$guide_file" << 'EOF'

# Or install via Go:
go install github.com/bettercap/bettercap@latest
sudo cp ~/go/bin/bettercap /usr/local/bin/
```

EOF
                ;;

            gobuster)
                echo "### gobuster" >> "$guide_file"
                echo '```bash' >> "$guide_file"
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "sudo apt install gobuster" >> "$guide_file"
                        ;;
                    arch)
                        echo "sudo pacman -S gobuster" >> "$guide_file"
                        ;;
                esac
                cat >> "$guide_file" << 'EOF'

# Or install via Go:
go install github.com/OJ/gobuster/v3@latest
sudo cp ~/go/bin/gobuster /usr/local/bin/
```

EOF
                ;;

            ffuf)
                echo "### ffuf" >> "$guide_file"
                echo '```bash' >> "$guide_file"
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "sudo apt install ffuf" >> "$guide_file"
                        ;;
                    arch)
                        echo "sudo pacman -S ffuf" >> "$guide_file"
                        ;;
                esac
                cat >> "$guide_file" << 'EOF'

# Or install via Go:
go install github.com/ffuf/ffuf@latest
sudo cp ~/go/bin/ffuf /usr/local/bin/
```

EOF
                ;;

            nuclei)
                cat >> "$guide_file" << 'EOF'
### nuclei
```bash
# Install via Go:
go install github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest
sudo cp ~/go/bin/nuclei /usr/local/bin/

# Or download from GitHub releases:
# https://github.com/projectdiscovery/nuclei/releases
```

EOF
                ;;

            httpx)
                cat >> "$guide_file" << 'EOF'
### httpx
```bash
# Install via Go:
go install github.com/projectdiscovery/httpx/cmd/httpx@latest
sudo cp ~/go/bin/httpx /usr/local/bin/

# Or download from GitHub releases:
# https://github.com/projectdiscovery/httpx/releases
```

EOF
                ;;

            subfinder)
                cat >> "$guide_file" << 'EOF'
### subfinder
```bash
# Install via Go:
go install github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest
sudo cp ~/go/bin/subfinder /usr/local/bin/

# Or download from GitHub releases:
# https://github.com/projectdiscovery/subfinder/releases
```

EOF
                ;;

            amass)
                cat >> "$guide_file" << 'EOF'
### amass
```bash
# Install via Go:
go install github.com/owasp-amass/amass/v4/...@master
sudo cp ~/go/bin/amass /usr/local/bin/

# Or via snap:
sudo snap install amass

# Or download from GitHub releases:
# https://github.com/owasp-amass/amass/releases
```

EOF
                ;;

            wpscan)
                echo "### wpscan" >> "$guide_file"
                echo '```bash' >> "$guide_file"
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "sudo apt install wpscan" >> "$guide_file"
                        ;;
                esac
                cat >> "$guide_file" << 'EOF'

# Or install via RubyGems:
sudo gem install wpscan
```

EOF
                ;;

            recon-ng)
                echo "### recon-ng" >> "$guide_file"
                echo '```bash' >> "$guide_file"
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "sudo apt install recon-ng" >> "$guide_file"
                        echo "" >> "$guide_file"
                        ;;
                esac
                cat >> "$guide_file" << 'EOF'
# Or install via pip:
pip3 install recon-ng --break-system-packages

# Or from source:
git clone https://github.com/lanmaster53/recon-ng.git
cd recon-ng
pip3 install -r REQUIREMENTS --break-system-packages
```

EOF
                ;;

            shodan)
                cat >> "$guide_file" << 'EOF'
### shodan
```bash
pip3 install shodan --break-system-packages

# Initialize with API key:
shodan init YOUR_API_KEY
```

EOF
                ;;

            crackmapexec)
                cat >> "$guide_file" << 'EOF'
### crackmapexec
```bash
# Option 1: pipx (recommended)
pipx install crackmapexec

# Option 2: pip
pip3 install crackmapexec --break-system-packages

# Option 3: From source
git clone https://github.com/Porchetta-Industries/CrackMapExec
cd CrackMapExec
pip3 install . --break-system-packages
```

EOF
                ;;

            sqlmap)
                echo "### sqlmap" >> "$guide_file"
                echo '```bash' >> "$guide_file"
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "sudo apt install sqlmap" >> "$guide_file"
                        ;;
                    arch)
                        echo "sudo pacman -S sqlmap" >> "$guide_file"
                        ;;
                esac
                cat >> "$guide_file" << 'EOF'

# Or install via pip:
pip3 install sqlmap --break-system-packages

# Or from source:
git clone https://github.com/sqlmapproject/sqlmap.git
cd sqlmap && python3 sqlmap.py
```

EOF
                ;;

            wifite)
                echo "### wifite" >> "$guide_file"
                echo '```bash' >> "$guide_file"
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "sudo apt install wifite" >> "$guide_file"
                        ;;
                    arch)
                        echo "sudo pacman -S wifite" >> "$guide_file"
                        ;;
                esac
                cat >> "$guide_file" << 'EOF'

# Or install via pip:
pip3 install wifite --break-system-packages

# Or from source:
git clone https://github.com/derv82/wifite2.git
cd wifite2 && sudo python3 setup.py install
```

EOF
                ;;

            exploitdb)
                echo "### exploitdb (searchsploit)" >> "$guide_file"
                echo '```bash' >> "$guide_file"
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "# Available on Kali/Parrot:" >> "$guide_file"
                        echo "sudo apt install exploitdb" >> "$guide_file"
                        ;;
                    arch)
                        echo "# Available in BlackArch repo:" >> "$guide_file"
                        echo "sudo pacman -S exploitdb" >> "$guide_file"
                        ;;
                esac
                cat >> "$guide_file" << 'EOF'

# Manual installation:
git clone https://gitlab.com/exploit-database/exploitdb.git /opt/exploitdb
ln -sf /opt/exploitdb/searchsploit /usr/local/bin/searchsploit
cp -n /opt/exploitdb/.searchsploit_rc ~/
```

EOF
                ;;

            *)
                # Generic fallback based on distro
                echo "### $tool_name" >> "$guide_file"
                echo '```bash' >> "$guide_file"
                case "$DISTRO_FAMILY" in
                    debian)
                        echo "sudo apt install $tool_name" >> "$guide_file"
                        ;;
                    redhat)
                        echo "sudo dnf install $tool_name" >> "$guide_file"
                        ;;
                    arch)
                        echo "sudo pacman -S $tool_name" >> "$guide_file"
                        ;;
                    suse)
                        echo "sudo zypper install $tool_name" >> "$guide_file"
                        ;;
                    alpine)
                        echo "sudo apk add $tool_name" >> "$guide_file"
                        ;;
                    *)
                        echo "# Check your package manager for: $tool_name" >> "$guide_file"
                        ;;
                esac
                echo -e '```\n' >> "$guide_file"
                ;;
        esac
    done

    cat >> "$guide_file" << 'EOF'
---

## After Installing

Run the following to verify your installations:
```bash
netreaper-install status
```

Or check individual tools:
```bash
which <toolname>
<toolname> --version
```
EOF

    echo "$guide_file"
}

show_install_summary() {
    echo
    echo -e "    ${C_CYAN}═══════════════════════════════════════════════════════════════${C_RESET}"
    echo -e "                        ${C_CYAN}INSTALLATION COMPLETE${C_RESET}"
    echo -e "    ${C_CYAN}═══════════════════════════════════════════════════════════════${C_RESET}"
    echo

    local total_attempted=${#INSTALL_ATTEMPTED[@]}
    local total_failed=${#FAILED_TOOLS[@]}
    local total_success=$((total_attempted - total_failed))

    echo -e "    ${C_GREEN}✓${C_RESET} Successful: ${C_GREEN}${total_success}${C_RESET}"
    echo -e "    ${C_RED}✗${C_RESET} Failed:     ${C_RED}${total_failed}${C_RESET}"
    echo

    if [[ ${#FAILED_TOOLS[@]} -gt 0 ]]; then
        echo -e "    ${C_RED}Failed tools:${C_RESET}"

        # Track tools we've already displayed (to avoid duplicates)
        local -A displayed_tools=()

        for tool in "${FAILED_TOOLS[@]}"; do
            local tool_name="${tool%%:*}"

            # Skip if already displayed
            [[ -n "${displayed_tools[$tool_name]:-}" ]] && continue
            displayed_tools[$tool_name]=1

            # Get hint for this tool
            local hint="${TOOL_INSTALL_HINTS[$tool_name]:-Package manager}"

            # Format: bullet, tool name (padded), dash, hint
            printf "      ${C_RED}•${C_RESET} %-18s ${C_SHADOW}- %s${C_RESET}\n" "$tool_name" "$hint"
        done

        echo

        # Create manual guide
        local guide_path
        guide_path=$(create_manual_fix_guide)

        echo -e "    ${C_YELLOW}[!]${C_RESET} Manual installation guide created:"
        echo -e "        ${C_CYAN}${guide_path}${C_RESET}"
        echo
        read -rp "    Open guide now? [y/N]: " open_guide

        if [[ "${open_guide,,}" == "y" ]]; then
            echo
            echo -e "    ${C_SHADOW}────────────────────────────────────────────────────────────${C_RESET}"

            # Use less if available and output is a terminal, otherwise cat
            if [[ -t 1 ]] && command -v less &>/dev/null; then
                less -R "$guide_path"
            else
                cat "$guide_path"
            fi

            echo -e "    ${C_SHADOW}────────────────────────────────────────────────────────────${C_RESET}"
            echo

            read -rp "    Open in new terminal? [y/N]: " new_term
            if [[ "${new_term,,}" == "y" ]]; then
                local term_launched=false

                # Try various terminal emulators
                if command -v x-terminal-emulator &>/dev/null; then
                    x-terminal-emulator -e bash -c "less '$guide_path'; echo; echo 'Press Enter to close...'; read" &
                    term_launched=true
                elif command -v gnome-terminal &>/dev/null; then
                    gnome-terminal -- bash -c "less '$guide_path'; echo; echo 'Press Enter to close...'; read" &
                    term_launched=true
                elif command -v konsole &>/dev/null; then
                    konsole -e bash -c "less '$guide_path'; echo; echo 'Press Enter to close...'; read" &
                    term_launched=true
                elif command -v xfce4-terminal &>/dev/null; then
                    xfce4-terminal -e "bash -c \"less '$guide_path'; echo; echo 'Press Enter to close...'; read\"" &
                    term_launched=true
                elif command -v mate-terminal &>/dev/null; then
                    mate-terminal -e "bash -c \"less '$guide_path'; echo; echo 'Press Enter to close...'; read\"" &
                    term_launched=true
                elif command -v kitty &>/dev/null; then
                    kitty bash -c "less '$guide_path'; echo; echo 'Press Enter to close...'; read" &
                    term_launched=true
                elif command -v alacritty &>/dev/null; then
                    alacritty -e bash -c "less '$guide_path'; echo; echo 'Press Enter to close...'; read" &
                    term_launched=true
                elif command -v xterm &>/dev/null; then
                    xterm -e bash -c "less '$guide_path'; echo; echo 'Press Enter to close...'; read" &
                    term_launched=true
                fi

                if [[ "$term_launched" == "true" ]]; then
                    echo -e "    ${C_GREEN}[✓]${C_RESET} Opened in new terminal window"
                else
                    echo -e "    ${C_YELLOW}[!]${C_RESET} No supported terminal emulator found"
                    echo -e "        ${C_SHADOW}View the guide at: ${guide_path}${C_RESET}"
                fi
            fi
        fi
    else
        echo -e "    ${C_GREEN}All tools installed successfully!${C_RESET}"
    fi

    echo
}

install_category() {
    local category="$1"
    local tools="${CATEGORIES[$category]:-}"

    if [[ -z "$tools" ]]; then
        log_error "Unknown category: $category"
        return 1
    fi

    echo
    echo -e "    ${C_CYAN}━━━ Installing ${category^^} tools ━━━${C_RESET}"

    FAILED_TOOLS=()
    SKIPPED_TOOLS=()
    INSTALL_ATTEMPTED=()

    for tool in $tools; do
        INSTALL_ATTEMPTED+=("$tool")
        install_tool "$tool" || true
    done

    ALL_FAILED_TOOLS+=("${FAILED_TOOLS[@]}")
    ALL_SKIPPED_TOOLS+=("${SKIPPED_TOOLS[@]}")
    ALL_INSTALL_ATTEMPTED+=("${INSTALL_ATTEMPTED[@]}")

    if [[ ${#FAILED_TOOLS[@]} -gt 0 ]]; then
        echo -e "    ${C_YELLOW}⚠${C_RESET} ${#FAILED_TOOLS[@]} tool(s) failed in ${category^^}"
    fi

    return 0
}

install_all() {
    local all_failed=()
    local all_skipped=()
    local all_attempted=()

    for category in scanning wireless web exploit osint creds traffic; do
        install_category "$category" || true
        all_failed+=("${FAILED_TOOLS[@]}")
        all_skipped+=("${SKIPPED_TOOLS[@]}")
        all_attempted+=("${INSTALL_ATTEMPTED[@]}")
        FAILED_TOOLS=()
        SKIPPED_TOOLS=()
        INSTALL_ATTEMPTED=()
    done

    FAILED_TOOLS=("${all_failed[@]}")
    SKIPPED_TOOLS=("${all_skipped[@]}")
    INSTALL_ATTEMPTED=("${all_attempted[@]}")

    show_install_summary
}

install_essentials() {
    local essentials="nmap masscan aircrack-ng hashcat john hydra nikto gobuster sqlmap tcpdump wireshark netdiscover arp-scan"
    CATEGORIES[essentials]="$essentials"
    install_category "essentials"
    show_install_summary
}

show_status() {
    echo
    echo -e "    ${C_BLUE}━━━ ARSENAL STATUS ━━━${C_RESET}"
    echo

    local installed=0
    local missing=0

    for category in "${!CATEGORIES[@]}"; do
        echo -e "    ${C_CYAN}${category^^}:${C_RESET}"
        echo -n "    "
        for tool in ${CATEGORIES[$category]}; do
            if check_tool_installed "$tool"; then
                echo -ne "${C_GREEN}✓${C_RESET}${tool}  "
                ((installed++))
            else
                echo -ne "${C_RED}✗${C_RESET}${tool}  "
                ((missing++))
            fi
        done
        echo
    done

    echo
    echo -e "    ${C_GREEN}Installed: $installed${C_RESET}  ${C_RED}Missing: $missing${C_RESET}"
}

#═══════════════════════════════════════════════════════════════════════════════
# STARTUP SCAN - Arsenal Status Overview
#═══════════════════════════════════════════════════════════════════════════════

# Tool arrays for scanning (matches CATEGORIES but in array format for iteration)
# shellcheck disable=SC2034  # Used for category iteration and status display
SCANNING_TOOLS=(nmap masscan rustscan zmap arp-scan netdiscover hping3 fping)
# shellcheck disable=SC2034
WIRELESS_TOOLS=(aircrack-ng reaver bully pixiewps wifite bettercap mdk3 mdk4 hostapd cowpatty hcxdumptool hcxtools)
# shellcheck disable=SC2034
WEB_TOOLS=(nikto sqlmap dirb gobuster wpscan ffuf nuclei httpx subfinder amass)
# shellcheck disable=SC2034
EXPLOIT_TOOLS=(metasploit-framework exploitdb crackmapexec)
# shellcheck disable=SC2034
OSINT_TOOLS=(theharvester recon-ng maltego shodan)
# shellcheck disable=SC2034
CREDS_TOOLS=(hashcat john hydra medusa)
# shellcheck disable=SC2034
TRAFFIC_TOOLS=(tcpdump wireshark tshark ettercap)
# shellcheck disable=SC2034
STRESS_TOOLS=(hping3 iperf3)
# shellcheck disable=SC2034
POST_TOOLS=(empire)

# Generate a progress bar
# Usage: generate_progress_bar installed total width
generate_progress_bar() {
    local installed="$1"
    local total="$2"
    local width="${3:-10}"

    if [[ $total -eq 0 ]]; then
        printf '%*s' "$width" '' | tr ' ' '░'
        return
    fi

    local percent=$((installed * 100 / total))
    local filled=$((installed * width / total))
    local empty=$((width - filled))

    local bar=""
    for ((i=0; i<filled; i++)); do
        bar+="█"
    done
    for ((i=0; i<empty; i++)); do
        bar+="░"
    done

    echo "$bar"
}

# Scan a category and return installed/total counts
# Usage: scan_category "CATEGORY_NAME" tool1 tool2 tool3...
# Sets: SCAN_INSTALLED, SCAN_TOTAL, SCAN_MISSING (array)
scan_category() {
    local -n tools_array="$1"
    SCAN_INSTALLED=0
    SCAN_TOTAL=${#tools_array[@]}
    SCAN_MISSING=()

    for tool in "${tools_array[@]}"; do
        if check_tool_installed "$tool"; then
            ((SCAN_INSTALLED++))
        else
            SCAN_MISSING+=("$tool")
        fi
    done
}

# Main startup scan function
startup_scan() {
    clear

    # Welcome banner
    echo
    echo -e "    ${C_RED}╔═══════════════════════════════════════════════════════════╗${C_RESET}"
    echo -e "    ${C_RED}║${C_RESET}           ${C_CYAN}NETREAPER ARSENAL INSTALLER${C_RESET} v${VERSION}            ${C_RED}║${C_RESET}"
    echo -e "    ${C_RED}╚═══════════════════════════════════════════════════════════╝${C_RESET}"
    echo

    # System detection
    echo -e "    ${C_CYAN}[*]${C_RESET} System Detection..."

    if ! detect_system; then
        echo -e "    ${C_RED}├─${C_RESET} Distro: ${C_RED}Unknown${C_RESET}"
        echo -e "    ${C_RED}├─${C_RESET} Family: ${C_RED}Unknown${C_RESET}"
        echo -e "    ${C_RED}└─${C_RESET} Package Manager: ${C_RED}Not detected${C_RESET}"
        echo
        echo -e "    ${C_RED}[!] Could not detect supported package manager${C_RESET}"
        echo -e "    ${C_SHADOW}    Supported: apt, dnf, yum, pacman, zypper, apk, emerge, xbps${C_RESET}"
        echo
        read -rp "    Press Enter to exit..."
        exit 1
    fi

    # Format distro name nicely
    local distro_display="${DISTRO^}"
    [[ "$DISTRO" == "kali" ]] && distro_display="Kali Linux"
    [[ "$DISTRO" == "ubuntu" ]] && distro_display="Ubuntu"
    [[ "$DISTRO" == "debian" ]] && distro_display="Debian"
    [[ "$DISTRO" == "parrot" ]] && distro_display="Parrot OS"
    [[ "$DISTRO" == "fedora" ]] && distro_display="Fedora"
    [[ "$DISTRO" == "arch" ]] && distro_display="Arch Linux"
    [[ "$DISTRO" == "manjaro" ]] && distro_display="Manjaro"
    [[ "$DISTRO" == "blackarch" ]] && distro_display="BlackArch"

    echo -e "    ${C_SHADOW}├─${C_RESET} Distro: ${C_GREEN}${distro_display}${C_RESET}"
    echo -e "    ${C_SHADOW}├─${C_RESET} Family: ${C_GREEN}${DISTRO_FAMILY}${C_RESET}"
    echo -e "    ${C_SHADOW}└─${C_RESET} Package Manager: ${C_GREEN}${PKG_MANAGER}${C_RESET}"
    echo

    # Arsenal status scan
    echo -e "    ${C_CYAN}[*]${C_RESET} Arsenal Status..."
    echo

    local total_installed=0
    local total_tools=0

    # Category display config: name, array_name, display_width
    local -a categories=("SCANNING:SCANNING_TOOLS" "WIRELESS:WIRELESS_TOOLS" "WEB:WEB_TOOLS" "EXPLOIT:EXPLOIT_TOOLS" "CREDS:CREDS_TOOLS" "TRAFFIC:TRAFFIC_TOOLS" "OSINT:OSINT_TOOLS" "POST:POST_TOOLS" "STRESS:STRESS_TOOLS")

    for cat_config in "${categories[@]}"; do
        local cat_name="${cat_config%%:*}"
        local cat_array="${cat_config##*:}"

        scan_category "$cat_array"

        local bar
        bar=$(generate_progress_bar "$SCAN_INSTALLED" "$SCAN_TOTAL" 10)

        local percent=0
        [[ $SCAN_TOTAL -gt 0 ]] && percent=$((SCAN_INSTALLED * 100 / SCAN_TOTAL))

        # Color based on percentage
        local percent_color="$C_RED"
        [[ $percent -ge 50 ]] && percent_color="$C_YELLOW"
        [[ $percent -eq 100 ]] && percent_color="$C_GREEN"

        # Format output line
        printf "    ${C_CYAN}%-10s${C_RESET} %2d/%-2d ${percent_color}%s${C_RESET} %3d%%" \
            "${cat_name}:" "$SCAN_INSTALLED" "$SCAN_TOTAL" "$bar" "$percent"

        # Show missing tools if any
        if [[ ${#SCAN_MISSING[@]} -gt 0 && ${#SCAN_MISSING[@]} -le 4 ]]; then
            local missing_str
            missing_str=$(IFS=', '; echo "${SCAN_MISSING[*]}")
            echo -e "  ${C_SHADOW}(missing: ${missing_str})${C_RESET}"
        elif [[ ${#SCAN_MISSING[@]} -gt 4 ]]; then
            echo -e "  ${C_SHADOW}(missing: ${#SCAN_MISSING[@]} tools)${C_RESET}"
        else
            echo
        fi

        ((total_installed += SCAN_INSTALLED))
        ((total_tools += SCAN_TOTAL))
    done

    echo
    echo -e "    ${C_CYAN}════════════════════════════════════════════════════════════${C_RESET}"

    local total_percent=0
    [[ $total_tools -gt 0 ]] && total_percent=$((total_installed * 100 / total_tools))

    local total_color="$C_RED"
    [[ $total_percent -ge 50 ]] && total_color="$C_YELLOW"
    [[ $total_percent -ge 80 ]] && total_color="$C_GREEN"

    printf "    ${C_CYAN}TOTAL:${C_RESET} ${total_color}%d/%d${C_RESET} installed (${total_color}%d%%${C_RESET})\n" \
        "$total_installed" "$total_tools" "$total_percent"
    echo -e "    ${C_CYAN}════════════════════════════════════════════════════════════${C_RESET}"
    echo

    read -rp "    Press Enter to continue to menu..."
}

#═══════════════════════════════════════════════════════════════════════════════
# UNINSTALL FUNCTIONS
#═══════════════════════════════════════════════════════════════════════════════

uninstall_tool() {
    local tool="$1"
    echo -ne "    Removing $tool... "

    if $PKG_REMOVE "$tool" &>/dev/null; then
        echo -e "${C_GREEN}✓${C_RESET}"
        return 0
    else
        echo -e "${C_RED}✗${C_RESET}"
        return 1
    fi
}

uninstall_category() {
    local category="$1"
    local tools="${CATEGORIES[$category]:-}"

    if [[ -z "$tools" ]]; then
        echo -e "    ${C_RED}[!] Unknown category: $category${C_RESET}"
        return 1
    fi

    echo -e "\n    ${C_RED}━━━ Uninstalling ${category^^} tools ━━━${C_RESET}"

    for tool in $tools; do
        uninstall_tool "$tool"
    done
}

uninstall_all() {
    echo -e "\n    ${C_RED}[!] WARNING: This will remove ALL installed tools${C_RESET}"
    read -rp "    Are you sure? [y/N]: " confirm

    if [[ "${confirm,,}" == "y" ]]; then
        for cat in scanning wireless web exploit osint creds traffic stress post; do
            uninstall_category "$cat" 2>/dev/null || true
        done
        echo
        echo -e "    ${C_GREEN}[✓] Uninstall complete${C_RESET}"
    else
        echo -e "    ${C_YELLOW}[!] Cancelled${C_RESET}"
    fi
}

uninstall_specific() {
    read -rp "    Enter tool name: " tool
    if [[ -n "$tool" ]]; then
        uninstall_tool "$tool"
    fi
}

uninstall_category_menu() {
    echo
    echo -e "    ${C_CYAN}Select category to uninstall:${C_RESET}"
    echo -e "    ${C_SHADOW}[1]${C_RESET} Scanning"
    echo -e "    ${C_SHADOW}[2]${C_RESET} Wireless"
    echo -e "    ${C_SHADOW}[3]${C_RESET} Web"
    echo -e "    ${C_SHADOW}[4]${C_RESET} Exploit"
    echo -e "    ${C_SHADOW}[5]${C_RESET} Credentials"
    echo -e "    ${C_SHADOW}[6]${C_RESET} OSINT"
    echo -e "    ${C_SHADOW}[7]${C_RESET} Traffic"
    echo -e "    ${C_SHADOW}[B]${C_RESET} Back"
    echo
    read -rp "    ▶ " choice

    case "$choice" in
        1) uninstall_category "scanning" ;;
        2) uninstall_category "wireless" ;;
        3) uninstall_category "web" ;;
        4) uninstall_category "exploit" ;;
        5) uninstall_category "creds" ;;
        6) uninstall_category "osint" ;;
        7) uninstall_category "traffic" ;;
        [bB]) return ;;
    esac
}

uninstall_menu() {
    clear
    echo -e "
    ${C_RED}╔═══════════════════════════════════════════════════════════╗
    ║           NETREAPER ARSENAL UNINSTALLER                   ║
    ╚═══════════════════════════════════════════════════════════╝${C_RESET}

    ${C_SHADOW}[1]${C_RESET} Uninstall ALL tools
    ${C_SHADOW}[2]${C_RESET} Uninstall by category
    ${C_SHADOW}[3]${C_RESET} Uninstall specific tool

    ${C_SHADOW}[B]${C_RESET} Back
"
    read -rp "    ▶ " choice

    case "$choice" in
        1) uninstall_all ;;
        2) uninstall_category_menu ;;
        3) uninstall_specific ;;
        [bB]) return ;;
    esac
}

show_menu() {
    while true; do
        clear
        echo
        echo -e "    ${C_RED}╔═══════════════════════════════════════════════════════════╗${C_RESET}"
        echo -e "    ${C_RED}║${C_RESET}           ${C_CYAN}NETREAPER ARSENAL INSTALLER${C_RESET}                    ${C_RED}║${C_RESET}"
        echo -e "    ${C_RED}╚═══════════════════════════════════════════════════════════╝${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[1]${C_RESET} Install ALL tools      ${C_SHADOW}(~3-5GB, 15-30 min)${C_RESET}"
        echo -e "    ${C_SHADOW}[2]${C_RESET} Install essentials     ${C_SHADOW}(~500MB, 5 min)${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[3]${C_RESET} Install SCANNING       ${C_SHADOW}nmap, masscan, rustscan...${C_RESET}"
        echo -e "    ${C_SHADOW}[4]${C_RESET} Install WIRELESS       ${C_SHADOW}aircrack-ng, wifite, bettercap...${C_RESET}"
        echo -e "    ${C_SHADOW}[5]${C_RESET} Install WEB            ${C_SHADOW}nikto, sqlmap, gobuster...${C_RESET}"
        echo -e "    ${C_SHADOW}[6]${C_RESET} Install EXPLOIT        ${C_SHADOW}metasploit, searchsploit...${C_RESET}"
        echo -e "    ${C_SHADOW}[7]${C_RESET} Install CREDENTIALS    ${C_SHADOW}hashcat, john, hydra...${C_RESET}"
        echo -e "    ${C_SHADOW}[8]${C_RESET} Install OSINT          ${C_SHADOW}theharvester, recon-ng...${C_RESET}"
        echo -e "    ${C_SHADOW}[9]${C_RESET} Install TRAFFIC        ${C_SHADOW}tcpdump, wireshark...${C_RESET}"
        echo
        echo -e "    ${C_SHADOW}[S]${C_RESET} Show status"
        echo -e "    ${C_SHADOW}[U]${C_RESET} Uninstall tools"
        echo -e "    ${C_SHADOW}[Q]${C_RESET} Quit"
        echo
        echo -ne "    ${C_CYAN}▶${C_RESET} "
        read -r choice

        case "$choice" in
            1) preflight_checks; install_all ;;
            2) preflight_checks; install_essentials ;;
            3) preflight_checks; install_category "scanning"; show_install_summary ;;
            4) preflight_checks; install_category "wireless"; show_install_summary ;;
            5) preflight_checks; install_category "web"; show_install_summary ;;
            6) preflight_checks; install_category "exploit"; show_install_summary ;;
            7) preflight_checks; install_category "creds"; show_install_summary ;;
            8) preflight_checks; install_category "osint"; show_install_summary ;;
            9) preflight_checks; install_category "traffic"; show_install_summary ;;
            s|S) show_status ;;
            u|U) init_system; uninstall_menu ;;
            q|Q) exit 0 ;;
            *) log_error "Invalid option" ;;
        esac

        echo
        echo -ne "    ${C_SHADOW}Press Enter to continue...${C_RESET}"
        read -r
    done
}

show_usage() {
    echo "NETREAPER Arsenal Installer v${VERSION}"
    echo
    echo "Usage: sudo $SCRIPT_NAME [options] [command]"
    echo
    echo "Options:"
    echo "    --dry-run    Simulate installation without making changes"
    echo
    echo "Commands:"
    echo "    all          Install all tools"
    echo "    essentials   Install essential tools only"
    echo "    scanning     Install scanning tools"
    echo "    wireless     Install wireless tools"
    echo "    web          Install web tools"
    echo "    exploit      Install exploit tools"
    echo "    creds        Install credential tools"
    echo "    osint        Install OSINT tools"
    echo "    traffic      Install traffic tools"
    echo "    status       Show installation status"
    echo "    menu         Interactive menu (default)"
    echo
}

main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                NR_DRY_RUN=1
                export NR_DRY_RUN
                echo -e "${C_CYAN}[*]${C_RESET} Dry-run mode enabled"
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    case "${1:-menu}" in
        all)
            preflight_checks
            install_all
            ;;
        essentials)
            preflight_checks
            install_essentials
            ;;
        scanning)
            preflight_checks
            install_category "scanning"
            show_install_summary
            ;;
        wireless)
            preflight_checks
            install_category "wireless"
            show_install_summary
            ;;
        web)
            preflight_checks
            install_category "web"
            show_install_summary
            ;;
        exploit)
            preflight_checks
            install_category "exploit"
            show_install_summary
            ;;
        creds)
            preflight_checks
            install_category "creds"
            show_install_summary
            ;;
        osint)
            preflight_checks
            install_category "osint"
            show_install_summary
            ;;
        traffic)
            preflight_checks
            install_category "traffic"
            show_install_summary
            ;;
        status)
            init_system
            show_status
            ;;
        menu|"")
            # Run startup scan before showing menu
            startup_scan
            show_menu
            ;;
        -h|--help)
            show_usage
            ;;
        *)
            log_error "Unknown command: $1"
            show_usage
            exit 1
            ;;
    esac
}

main "$@"
